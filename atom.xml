<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucky&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-10T14:12:32.618Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TensorFlow安装/tensorflow</title>
    <link href="http://yoursite.com/2021/01/30/TensorFlow%E5%AE%89%E8%A3%85/tensorflow/"/>
    <id>http://yoursite.com/2021/01/30/TensorFlow%E5%AE%89%E8%A3%85/tensorflow/</id>
    <published>2021-01-30T07:21:25.227Z</published>
    <updated>2020-11-10T14:12:32.618Z</updated>
    
    <content type="html"><![CDATA[<p><a href="../../images/python+TensorFlow/1604996441598.png" data-fancybox="group" data-caption="1604996441598" class="fancybox"><img alt="1604996441598" title="1604996441598" data-src="../../images/python+TensorFlow/1604996441598.png" class="lazyload"></a></p><p><a href="../../images/python+TensorFlow/1604996478286.png" data-fancybox="group" data-caption="1604996478286" class="fancybox"><img alt="1604996478286" title="1604996478286" data-src="../../images/python+TensorFlow/1604996478286.png" class="lazyload"></a></p><p><a href="../../images/python+TensorFlow/1604996569683.png" data-fancybox="group" data-caption="1604996569683" class="fancybox"><img alt="1604996569683" title="1604996569683" data-src="../../images/python+TensorFlow/1604996569683.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;../../images/python+TensorFlow/1604996441598.png&quot; data-fancybox=&quot;group&quot; data-caption=&quot;1604996441598&quot; class=&quot;fancybox&quot;&gt;&lt;img alt=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>目标检测与配准/3_IR与TV配准</title>
    <link href="http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/3_IR%E4%B8%8ETV%E9%85%8D%E5%87%86/"/>
    <id>http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/3_IR%E4%B8%8ETV%E9%85%8D%E5%87%86/</id>
    <published>2021-01-30T07:21:25.204Z</published>
    <updated>2020-11-05T13:21:21.555Z</updated>
    
    <content type="html"><![CDATA[<p><strong>需求</strong>：将IR图像（1024x768，视场大）与TV图像（1920x1080，视场小）根据delta_x，delta_y，Sx，Sy对图像进行配准，便于后续的融合</p><p><strong>方法</strong>：由于TV图像的像素密度大，对TV图像进行下采样缩小处理，TV_Width缩小到TV_Width x Sx，TV_Height缩小到TV_Height x Sy，将缩小后的TV图像存储在一个IR大小（1024x768）的空间中，缩小的TV应该是比IR小的，但是存在TV和IR图像拍的视野不同的问题，IR镜头偏左上，TV偏右下，所以TV的部分视野可能不包含在IR图像中，所以需要对超出IR视野的部分进行判断处理</p><p><strong>软件环境</strong>：vs2019、Code Composer Studio 5.5.0</p><p><strong>文件</strong>：.dat文件两个，IR图像和TV图像</p><h3 id="0、一些基本参数设置"><a href="#0、一些基本参数设置" class="headerlink" title="0、一些基本参数设置"></a>0、一些基本参数设置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红外图像</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IR_Height  768</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IR_Width  1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IR_SIZE  768 * 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可见光图像的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_Height  1080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_Width  1920</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_SIZE  1080 * 1920</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给配准图像分配空间，设置好所需参数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* TV_trans_img = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(<span class="number">0x80000000</span>+<span class="number">0x400000</span>);<span class="comment">//0x200000</span></span><br><span class="line"><span class="built_in">memset</span>(TV_trans_img,<span class="number">0</span>,IR_Width*IR_Height);</span><br><span class="line"><span class="keyword">int</span> delta_x = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">int</span> delta_y = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> uart_Sx = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">int</span> uart_Sy = <span class="number">80</span>;</span><br></pre></td></tr></table></figure></div><h3 id="1、TV图像缩小"><a href="#1、TV图像缩小" class="headerlink" title="1、TV图像缩小"></a>1、TV图像缩小</h3><p>方法：先将缩小的TV图像TV_narrow_img的长和宽进行计算：</p><p>int TV_narrow_Height = (int)(TV_Height * Sx+0.5);<br>int TV_narrow_Width = (int)(TV_Width * Sy+0.5);</p><p>然后计算出TV_narrow_img在原图像TV_ori_img所对应的像素位置：</p><p>TV_x = (int)(x / Sx+0.5);<br>TV_y = (int)(y / Sy+0.5);</p><p>并将对应像素位置填充到新开辟的内存空间中的位置</p><p>(fusion_img+row_index x IR_Width+col_index)=*(TV_ori_img+TV_x x TV_Width+TV_y);</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downscale_ori</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* TV_ori_img,<span class="keyword">unsigned</span> <span class="keyword">char</span>* fusion_img,<span class="keyword">int</span> delta_x,<span class="keyword">int</span> delta_y,<span class="keyword">int</span> uart_Sx,<span class="keyword">int</span> uart_Sy)</span></span>&#123;</span><br><span class="line"><span class="comment">// x:row    y:col</span></span><br><span class="line"><span class="keyword">float</span> Sx = uart_Sx * <span class="number">0.01</span> ;</span><br><span class="line"><span class="keyword">float</span> Sy = uart_Sy * <span class="number">0.01</span> ;</span><br><span class="line"><span class="keyword">int</span> TV_narrow_Height = (<span class="keyword">int</span>)(TV_Height * Sx+<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">int</span> TV_narrow_Width = (<span class="keyword">int</span>)(TV_Width * Sy+<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> TV_x=<span class="number">0</span>,TV_y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row_index = <span class="number">0</span>;<span class="keyword">int</span> col_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; TV_narrow_Height; x++)&#123;</span><br><span class="line">row_index = delta_x + x;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; TV_narrow_Width; y++)&#123;</span><br><span class="line">col_index = delta_y + y;</span><br><span class="line"><span class="comment">//插值计算，输出图像的像素点由原图像对应的最近的像素点得到（四舍五入）</span></span><br><span class="line">TV_x = (<span class="keyword">int</span>)(x / Sx+<span class="number">0.5</span>);</span><br><span class="line">TV_y = (<span class="keyword">int</span>)(y / Sy+<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">if</span> (TV_x &gt;(TV_Height - <span class="number">1</span>))</span><br><span class="line">TV_x = TV_Height - <span class="number">1</span>;<span class="comment">//防止越界</span></span><br><span class="line"><span class="keyword">if</span> (TV_y &gt;(TV_Width - <span class="number">1</span>))</span><br><span class="line">TV_y = TV_Width - <span class="number">1</span>;<span class="comment">//防止越界</span></span><br><span class="line">*(fusion_img+row_index*IR_Width+col_index)=*(TV_ori_img+TV_x*TV_Width+TV_y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2、边界判断"><a href="#2、边界判断" class="headerlink" title="2、边界判断"></a>2、边界判断</h3><p>若缩小后的TV中的行数+行数偏移（delta_x）超过IR_Height，则跳出第一个遍历行数的循环；</p><p>若缩小后的TV中的列数_列数偏移（delta_y）超过IR_Width，则跳出第二个遍历列的循环，直接进行下一行对应像素点的填充</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downscale</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* TV_ori_img,<span class="keyword">unsigned</span> <span class="keyword">char</span>* TV_trans_img,<span class="keyword">int</span> delta_x,<span class="keyword">int</span> delta_y,<span class="keyword">int</span> uart_Sx,<span class="keyword">int</span> uart_Sy)</span></span>&#123;</span><br><span class="line"><span class="comment">// x:row    y:col</span></span><br><span class="line"><span class="keyword">float</span> Sx = uart_Sx * <span class="number">0.01</span> ;</span><br><span class="line"><span class="keyword">float</span> Sy = uart_Sy * <span class="number">0.01</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TV_narrow_Height = (<span class="keyword">int</span>)(TV_Height * Sx+<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">int</span> TV_narrow_Width = (<span class="keyword">int</span>)(TV_Width * Sy+<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> TV_x=<span class="number">0</span>,TV_y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row_index = <span class="number">0</span>;<span class="keyword">int</span> col_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; TV_narrow_Height; x++)&#123;</span><br><span class="line">row_index = delta_x + x;</span><br><span class="line"><span class="keyword">if</span>(row_index&gt;=IR_Height)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; TV_narrow_Width; y++)&#123;</span><br><span class="line">col_index = delta_y + y;</span><br><span class="line"><span class="comment">//插值计算，输出图像的像素点由原图像对应的最近的像素点得到（四舍五入）</span></span><br><span class="line">TV_x = (<span class="keyword">int</span>)(x / Sx+<span class="number">0.5</span>);</span><br><span class="line">TV_y = (<span class="keyword">int</span>)(y / Sy+<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">if</span> (TV_x &gt;(TV_Height - <span class="number">1</span>))</span><br><span class="line">TV_x = TV_Height - <span class="number">1</span>;<span class="comment">//防止越界</span></span><br><span class="line"><span class="keyword">if</span> (TV_y &gt;(TV_Width - <span class="number">1</span>))</span><br><span class="line">TV_y = TV_Width - <span class="number">1</span>;<span class="comment">//防止越界</span></span><br><span class="line"><span class="keyword">if</span>(col_index&lt;IR_Width)*(TV_trans_img+row_index*IR_Width+col_index)=*(TV_ori_img+TV_x*TV_Width+TV_y);</span><br><span class="line"><span class="keyword">else</span><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>效果展示</strong></p><p>TV原图像</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1603076407045.png" data-fancybox="group" data-caption="1603076407045" class="fancybox"><img alt="1603076407045" title="1603076407045" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1603076407045.png" class="lazyload"></a></p><p>配准后图像</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1603077626036.png" data-fancybox="group" data-caption="1603077626036" class="fancybox"><img alt="1603077626036" title="1603077626036" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1603077626036.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：将IR图像（1024x768，视场大）与TV图像（1920x1080，视场小）根据delta_x，delta_y，Sx，Sy对图像进行配准，便于后续的融合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;：由于TV图像的像素密度大
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>目标检测与配准/2_目标检测</title>
    <link href="http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/2_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    <id>http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/2_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</id>
    <published>2021-01-30T07:21:25.197Z</published>
    <updated>2020-10-12T08:59:44.986Z</updated>
    
    <content type="html"><![CDATA[<p><strong>需求</strong>：在IR图像中寻找目标，即从左向右从上到下第一个目标框像素最大值，在其周围标注方框以示目标区域；并且在TV图像中寻找对应的</p><p><strong>难点</strong>：</p><p>a、由于寻找目标的滑动窗口（n）与标记窗口（N）的大小不同，N&gt;n，故存在标记窗口标记到非图像区域，目标位置有九种情况：左上角区域，右上角区域、左下角区域、右下角区域、上边界区域、下边界区域、左边界区域、有边界区域以及中间区域（即不会标记到图像外部的区域），需要分情况画框</p><p>b、配准，找到IR最大区域后需要寻找其在TV图像的对应位置</p><p><strong>软件环境</strong>：vs2019、Code Composer Studio 5.5.0</p><p><strong>文件</strong>：.dat文件两个，IR图像和TV图像</p><h3 id="0、一些基本参数设置"><a href="#0、一些基本参数设置" class="headerlink" title="0、一些基本参数设置"></a>0、一些基本参数设置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红外图像</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IR_Height  768</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IR_Width  1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IR_SIZE  768 * 1024</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可见光图像的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_Height  1080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_Width  1920</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TV_SIZE  1080 * 1920</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N  5<span class="comment">//目标检测框大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_out  35<span class="comment">//目标画框大小</span></span></span><br></pre></td></tr></table></figure></div><h3 id="1、寻找第一个最大区域（5x5）中心点坐标"><a href="#1、寻找第一个最大区域（5x5）中心点坐标" class="headerlink" title="1、寻找第一个最大区域（5x5）中心点坐标"></a>1、寻找第一个最大区域（5x5）中心点坐标</h3><p>最大区域中心点为IR_x,IR_y（x为行，y为列）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找IR图像最大区域</span></span><br><span class="line"><span class="keyword">int</span> sum_c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x，y为N*N区域的中心点</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//m,n为以x，y为中心的矩阵像素遍历</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>; <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//IR_x,IR_y为IR图像的最大值中心点</span></span><br><span class="line"><span class="keyword">int</span> IR_x=<span class="number">0</span>;<span class="keyword">int</span> IR_y=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x = N / <span class="number">2</span>; x &lt; IR_Height - N / <span class="number">2</span>; x += <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (y = N / <span class="number">2</span>; y &lt; IR_Width - N / <span class="number">2</span>; y += <span class="number">5</span>) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (m = x - N / <span class="number">2</span>; m &lt;= x + N / <span class="number">2</span>; m++) &#123;</span><br><span class="line"><span class="keyword">for</span> (n = y - N / <span class="number">2</span>; n &lt;= y + N / <span class="number">2</span>; n++) &#123;</span><br><span class="line">sum += *(IR_ori_img+m*IR_Width+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; sum_c) &#123;</span><br><span class="line">sum_c = sum;</span><br><span class="line">IR_x = x;</span><br><span class="line">IR_y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2、配准"><a href="#2、配准" class="headerlink" title="2、配准"></a>2、配准</h3><p>（即寻找在TV图像中对应的目标区域）</p><p>相对位移和缩放（TV相对IR）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Sx=<span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">float</span> Sy=<span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> deta_x=<span class="number">900</span>;</span><br><span class="line"><span class="keyword">int</span> deta_y=<span class="number">800</span>;</span><br></pre></td></tr></table></figure></div><p>寻找IR最大值区域在TV中的相对位置（加0.5的目的是为了四舍五入）</p><p>TV图像缩小3倍即TV_x乘以Sx，TV_y乘以Sy，再向x方向移动deta_x，向y方向移动deta_y即可得到对应于IR图像中的相对位置<br>$$<br>TV_x<em>Sx+deta_x=IR_xand<br>TV_y</em>Sy+deta_y=IR_y<br>$$</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> TV_x = <span class="number">0</span>; <span class="keyword">int</span> TV_y = <span class="number">0</span>;</span><br><span class="line">TV_x = (<span class="keyword">int</span>)((IR_x/Sx-deta_x)+<span class="number">0.5</span>);</span><br><span class="line">TV_y = (<span class="keyword">int</span>)((IR_y/Sy-deta_y)+<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure></div><h3 id="3、画框"><a href="#3、画框" class="headerlink" title="3、画框"></a>3、画框</h3><p>给IR、TV图像画框</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint_obj(IR_ori_img,IR_Width,IR_Height,IR_x,IR_y);</span><br><span class="line">paint_obj(TV_ori_img,TV_Width,TV_Height,TV_x,TV_y);</span><br></pre></td></tr></table></figure></div><p>画框函数paint_obj</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画框</span></span><br><span class="line"><span class="comment">//(x,y)为中心点，Width为目标画框图像的宽，Height为目标画框图像的高</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paint_obj</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* ori_img,<span class="keyword">int</span> Width,<span class="keyword">int</span> Height,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;<span class="keyword">int</span> y=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//左上角</span></span><br><span class="line"><span class="keyword">if</span> ((i - N_out / <span class="number">2</span> &lt; <span class="number">0</span>) &amp;&amp; (j - N_out / <span class="number">2</span> &lt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i + N_out / <span class="number">2</span> - <span class="number">7</span>; x &lt;= i + N_out / <span class="number">2</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j + N_out / <span class="number">2</span> - <span class="number">7</span>; y &lt;= j + N_out / <span class="number">2</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右上角</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i - N_out / <span class="number">2</span> &lt; <span class="number">0</span>) &amp;&amp; (j + N_out / <span class="number">2</span> &gt; Width - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i + N_out / <span class="number">2</span> - <span class="number">7</span>; x &lt;= i + N_out / <span class="number">2</span>; x++) &#123;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j - N_out / <span class="number">2</span>; y &lt;= j - N_out / <span class="number">2</span> + <span class="number">7</span>; y++) &#123;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左下角</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + N_out / <span class="number">2</span> &gt; Height - <span class="number">1</span>) &amp;&amp; (j - N_out / <span class="number">2</span> &lt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i - N_out / <span class="number">2</span>; x &lt;= i - N_out / <span class="number">2</span> + <span class="number">7</span>; x++) &#123;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j + N_out / <span class="number">2</span> - <span class="number">7</span>; y &lt;= j + N_out / <span class="number">2</span>; y++) &#123;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右下角</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + N_out / <span class="number">2</span> &gt; Height - <span class="number">1</span>) &amp;&amp; (j + N_out / <span class="number">2</span> &gt; <span class="number">1920</span> - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i - N_out / <span class="number">2</span>; x &lt;= i - N_out / <span class="number">2</span> + <span class="number">7</span>; x++) &#123;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j - N_out / <span class="number">2</span>; y &lt;= j - N_out / <span class="number">2</span> + <span class="number">7</span>; y++) &#123;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上边界</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i - N_out / <span class="number">2</span> &lt; <span class="number">0</span>) &amp;&amp; (j - N_out / <span class="number">2</span> &gt;= <span class="number">0</span>) &amp;&amp; (j + N_out / <span class="number">2</span> &lt;= <span class="number">1920</span> - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i + N_out / <span class="number">2</span> - <span class="number">7</span>; x &lt;= i + N_out / <span class="number">2</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j - N_out / <span class="number">2</span>; y &lt;= j - N_out / <span class="number">2</span> + <span class="number">7</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j + N_out / <span class="number">2</span> - <span class="number">7</span>; y &lt;= j + N_out / <span class="number">2</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下边界</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((i + N_out / <span class="number">2</span> &gt; Height - <span class="number">1</span>) &amp;&amp; (j - N_out / <span class="number">2</span> &gt;= <span class="number">0</span>) &amp;&amp; (j + N_out / <span class="number">2</span> &lt;= <span class="number">1920</span> - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i - N_out / <span class="number">2</span>; x &lt;= i - N_out / <span class="number">2</span> + <span class="number">7</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j - N_out / <span class="number">2</span>; y &lt;= j - N_out / <span class="number">2</span> + <span class="number">7</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j + N_out / <span class="number">2</span> - <span class="number">7</span>; y &lt;= j + N_out / <span class="number">2</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左边界</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((j - N_out / <span class="number">2</span> &lt; <span class="number">0</span>) &amp;&amp; (i - N_out / <span class="number">2</span> &gt;= <span class="number">0</span>) &amp;&amp; (i + N_out / <span class="number">2</span> &lt;= Height - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i - N_out / <span class="number">2</span>; x &lt;= i - N_out / <span class="number">2</span> + <span class="number">7</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (x = i + N_out / <span class="number">2</span> - <span class="number">7</span>; x &lt;= i + N_out / <span class="number">2</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j + N_out / <span class="number">2</span> - <span class="number">7</span>; y &lt;= j + N_out / <span class="number">2</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右边界</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((j + N_out / <span class="number">2</span> &gt; <span class="number">1920</span> - <span class="number">1</span>) &amp;&amp; (i - N_out / <span class="number">2</span> &gt;= <span class="number">0</span>) &amp;&amp; (i + N_out / <span class="number">2</span> &lt;= Height - <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i - N_out / <span class="number">2</span>; x &lt;= i - N_out / <span class="number">2</span> + <span class="number">7</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (x = i + N_out / <span class="number">2</span> - <span class="number">7</span>; x &lt;= i + N_out / <span class="number">2</span>; x++) &#123;<span class="comment">//左</span></span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j - N_out / <span class="number">2</span>; y &lt;= j - N_out / <span class="number">2</span> + <span class="number">7</span>; y++) &#123;<span class="comment">//上</span></span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中间区域</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (x = i - N_out / <span class="number">2</span>; x &lt;= i - N_out / <span class="number">2</span> + <span class="number">7</span>; x++) &#123;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x = i + N_out / <span class="number">2</span> - <span class="number">7</span>; x &lt;= i + N_out / <span class="number">2</span>; x++) &#123;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j - N_out / <span class="number">2</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">ori_img[x*Width+j + N_out / <span class="number">2</span> - <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j - N_out / <span class="number">2</span>; y &lt;= j - N_out / <span class="number">2</span> + <span class="number">7</span>; y++) &#123;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (y = j + N_out / <span class="number">2</span> - <span class="number">7</span>; y &lt;= j + N_out / <span class="number">2</span>; y++) &#123;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i - N_out / <span class="number">2</span> + <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">1</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">2</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">ori_img[(i + N_out / <span class="number">2</span> - <span class="number">3</span>)*Width+y] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>效果展示</strong></p><p>IR原图像</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602492662013.png" data-fancybox="group" data-caption="1602492662013" class="fancybox"><img alt="1602492662013" title="1602492662013" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602492662013.png" class="lazyload"></a></p><p>IR目标检测图像</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602493069122.png" data-fancybox="group" data-caption="1602493069122" class="fancybox"><img alt="1602493069122" title="1602493069122" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602493069122.png" class="lazyload"></a></p><h3 id="4、目标增强"><a href="#4、目标增强" class="headerlink" title="4、目标增强"></a>4、目标增强</h3><p>首先统计出目标图像的直方图</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hist</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>* ori_img, <span class="keyword">int</span> Width, <span class="keyword">int</span> Height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Height * Width; i++) &#123;</span><br><span class="line"><span class="built_in">array</span>[ori_img[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对直方图进行均衡化操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">histeq</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">char</span>* ori_img, <span class="keyword">unsigned</span> <span class="keyword">char</span>* eq_img, <span class="keyword">int</span> Width, <span class="keyword">int</span> Height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//直方图均衡化</span></span><br><span class="line"><span class="keyword">float</span> n = Width * Height;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//累加数组</span></span><br><span class="line"><span class="comment">//float temp;</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="comment">//temp = sum + array[i] / n;</span></span><br><span class="line">sum = sum + <span class="built_in">array</span>[i] / n;</span><br><span class="line"><span class="built_in">array</span>[i]=<span class="number">0</span>;</span><br><span class="line">p[i] = (<span class="keyword">int</span>)(sum * <span class="number">255</span> + <span class="number">0.5</span>);<span class="comment">//四舍五入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Height * Width; i++) &#123;</span><br><span class="line">eq_img[i] = p[ori_img[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>效果展示</strong></p><p>IR原图像</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602492694386.png" data-fancybox="group" data-caption="1602492694386" class="fancybox"><img alt="1602492694386" title="1602492694386" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602492694386.png" class="lazyload"></a></p><p>IR增强图像</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602492857510.png" data-fancybox="group" data-caption="1602492857510" class="fancybox"><img alt="1602492857510" title="1602492857510" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602492857510.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：在IR图像中寻找目标，即从左向右从上到下第一个目标框像素最大值，在其周围标注方框以示目标区域；并且在TV图像中寻找对应的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;a、由于寻找目标的滑动窗口（n）与标记窗口
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>目标检测与配准/1_.dat文件转换方式与图形裁剪</title>
    <link href="http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1_.dat%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E8%A3%81%E5%89%AA/"/>
    <id>http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1_.dat%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E8%A3%81%E5%89%AA/</id>
    <published>2021-01-30T07:21:25.191Z</published>
    <updated>2020-10-12T08:04:50.057Z</updated>
    
    <content type="html"><![CDATA[<p><strong>需求</strong>：</p><p>1、由于ccs（Code Composer Studio 5.5.0）测试时需要.dat文件，所以需要将一幅图像文件转换为该格式文件，文件内容为每个像素的8bit表示，接下来会对该文件格式进行介绍</p><p>2、由于需要造出两幅图像，一幅为TV图像，一幅为IR图像，其中TV图像的大小为（1080x1920），IR图像大小为（768x1024），并且IR图像的视角更广（即广角），TV相对视野范围更窄，且两幅图像有一定的位置偏移量</p><p><strong>解决方法</strong>：</p><p>将一副更大的图像（大于1080x1920），先将其裁剪为像素密度更大的TV（10890x1920）图像，再将图像裁剪为（（768x3）x（1024x3））（切记要包含TV图像的内容），再将该图像三倍下采样得到（768x1024）的IR图像</p><p><strong>软件环境</strong>：matlab2019</p><p><strong>文件准备</strong>：彩色图像或灰度图像皆可</p><p>（完整代码在最下方）</p><h3 id="1、认识-dat文件"><a href="#1、认识-dat文件" class="headerlink" title="1、认识.dat文件"></a>1、认识.dat文件</h3><p>如下图所示是一个.dat文件，对于其文件头的解释如下</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602486059360.png" data-fancybox="group" data-caption="1602486059360" class="fancybox"><img alt="1602486059360" title="1602486059360" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602486059360.png" class="lazyload"></a></p><p>下图中1fa400（十六进制）是一幅1080*1920图像的像素个数，接下来的每一个8位二进制代表一个像素的灰度值，排列顺序为由上到下，由左到右</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602485925403.png" data-fancybox="group" data-caption="1602485925403" class="fancybox"><img alt="1602485925403" title="1602485925403" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602485925403.png" class="lazyload"></a></p><h3 id="2、TV、IR图像构造"><a href="#2、TV、IR图像构造" class="headerlink" title="2、TV、IR图像构造"></a>2、TV、IR图像构造</h3><p>读图像并将其转换为灰度图像</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">matlab</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B=imread(<span class="string">'E:\Yu_Jiao\zaotu\1.jpg'</span>);</span><br><span class="line">B=rgb2gray(B);</span><br></pre></td></tr></table></figure></div><p>尽量靠中间裁剪，得到1080x1024的TV图像</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">matlab</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ori_tv=B(<span class="number">1</span>+<span class="number">900</span>:<span class="number">1080</span>+<span class="number">900</span>,<span class="number">1</span>+<span class="number">800</span>:<span class="number">1920</span>+<span class="number">800</span>);</span><br></pre></td></tr></table></figure></div><p>包含TV图像像素点再次对原图像B进行裁剪，得到像素密度丰富的IR图像，再进行下采样得到所需IR图像（由于matlab的dowmsamle只能对行进行下采样，故采样后进行转置即为对列下采样，最好再转置回来即可）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">matlab</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ori_ir_temp=B(<span class="number">1</span>:<span class="number">2304</span>,<span class="number">1</span>:<span class="number">3072</span>);</span><br><span class="line">ori_ir=downsample(ori_ir_temp,<span class="number">3</span>);</span><br><span class="line">ori_ir=downsample(ori_ir',<span class="number">3</span>);</span><br><span class="line">ori_ir=ori_ir';</span><br><span class="line">imwrite(ori_tv,<span class="string">'ori_tv.bmp'</span>);</span><br><span class="line">imwrite(ori_ir,<span class="string">'ori_ir.bmp'</span>);</span><br></pre></td></tr></table></figure></div><p>得到的图像如下所示</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602487539361.png" data-fancybox="group" data-caption="1602487539361" class="fancybox"><img alt="1602487539361" title="1602487539361" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602487539361.png" class="lazyload"></a></p><h3 id="3、将逐个像素点写入-dat文件"><a href="#3、将逐个像素点写入-dat文件" class="headerlink" title="3、将逐个像素点写入.dat文件"></a>3、将逐个像素点写入.dat文件</h3><p>（即按照行扫描的方式进行，一边将unit8的数据转换为二进制）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">matlab</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(<span class="string">'ori_tv.dat'</span>,<span class="string">'wb'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">1080</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">1920</span></span><br><span class="line">        fprintf(fid,<span class="string">'%s\n'</span>,dec2bin(ori_tv(<span class="built_in">i</span>,<span class="built_in">j</span>)));</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br><span class="line">fid = fopen(<span class="string">'ori_ir.dat'</span>,<span class="string">'wb'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">768</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">1024</span></span><br><span class="line">        fprintf(fid,<span class="string">'%s\n'</span>,dec2bin(ori_ir(<span class="built_in">i</span>,<span class="built_in">j</span>)));</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure></div><h3 id="4、对-dat文件的文件头修改"><a href="#4、对-dat文件的文件头修改" class="headerlink" title="4、对.dat文件的文件头修改"></a>4、对.dat文件的文件头修改</h3><p>按照1给出的格式头样式进行修改即可，一般用计算器算一下图像大小（16进制），其余不需要怎么变化</p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602487802915.png" data-fancybox="group" data-caption="1602487802915" class="fancybox"><img alt="1602487802915" title="1602487802915" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602487802915.png" class="lazyload"></a></p><p><a href="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602487820558.png" data-fancybox="group" data-caption="1602487820558" class="fancybox"><img alt="1602487820558" title="1602487820558" data-src="../../images/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1602487820558.png" class="lazyload"></a></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">matlab</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">B=imread(<span class="string">'E:\Yu_Jiao\zaotu\1.jpg'</span>);</span><br><span class="line"><span class="comment">%imshow(B);</span></span><br><span class="line">B=rgb2gray(B);</span><br><span class="line"><span class="comment">%figure(1);</span></span><br><span class="line"><span class="comment">%imshow(B);</span></span><br><span class="line">ori_tv=B(<span class="number">1</span>+<span class="number">900</span>:<span class="number">1080</span>+<span class="number">900</span>,<span class="number">1</span>+<span class="number">800</span>:<span class="number">1920</span>+<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">ori_ir_temp=B(<span class="number">1</span>:<span class="number">2304</span>,<span class="number">1</span>:<span class="number">3072</span>);</span><br><span class="line"></span><br><span class="line">ori_ir=downsample(ori_ir_temp,<span class="number">3</span>);</span><br><span class="line">ori_ir=downsample(ori_ir',<span class="number">3</span>);</span><br><span class="line">ori_ir=ori_ir';</span><br><span class="line"></span><br><span class="line">imwrite(ori_tv,<span class="string">'ori_tv.bmp'</span>);</span><br><span class="line">imwrite(ori_ir,<span class="string">'ori_ir.bmp'</span>);</span><br><span class="line"><span class="comment">%tv图像</span></span><br><span class="line">fid = fopen(<span class="string">'ori_tv.dat'</span>,<span class="string">'wb'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">1080</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">1920</span></span><br><span class="line">        fprintf(fid,<span class="string">'%s\n'</span>,dec2bin(ori_tv(<span class="built_in">i</span>,<span class="built_in">j</span>)));</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br><span class="line">fid = fopen(<span class="string">'ori_ir.dat'</span>,<span class="string">'wb'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">768</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">1024</span></span><br><span class="line">        fprintf(fid,<span class="string">'%s\n'</span>,dec2bin(ori_ir(<span class="built_in">i</span>,<span class="built_in">j</span>)));</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1、由于ccs（Code Composer Studio 5.5.0）测试时需要.dat文件，所以需要将一幅图像文件转换为该格式文件，文件内容为每个像素的8bit表示，接下来会对该文件格式进行介绍&lt;/p&gt;
&lt;p&gt;2、由
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day7/Day7/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day7/Day7/</id>
    <published>2021-01-30T07:20:26.591Z</published>
    <updated>2021-01-14T07:41:42.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等</span><br><span class="line">而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。</span><br></pre></td></tr></table></figure></div><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">同步即协同步调，按预定的先后次序运行。</span><br><span class="line">线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</span><br><span class="line">举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</span><br><span class="line">举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</span><br><span class="line">产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</span><br><span class="line">“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</span><br><span class="line">因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210113095950695.png" data-fancybox="group" data-caption="image-20210113095950695" class="fancybox"><img alt="image-20210113095950695" title="image-20210113095950695" data-src="image-20210113095950695.png" class="lazyload"></a></p><p>例子：假设存折和银行卡都操作同一个账户，在存折需要提款时对账户进行查询发现20000&gt;5000可以提款，之后银行卡方先于存折将10000提取，自动设置账户剩余金额为10000，接下来待柜员将金钱清点交于提款方后，将账户金额设置为15000，产生了错误。</p><p>1、共享数据；2、存在竞争；3、多个对象访问共享数据，且无同步机制—&gt;发生与时间有关的错误。</p><h3 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 资源共享（独享资源则不会）</span><br><span class="line">2. 调度随机（意味着数据访问会出现竞争）</span><br><span class="line">3. 线程间缺乏必要的同步机制。</span><br><span class="line">以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</span><br><span class="line">所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</span><br></pre></td></tr></table></figure></div><h2 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux中提供一把互斥锁mutex（也称之为互斥量）。</span><br><span class="line">每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</span><br><span class="line">资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210113102516774.png" data-fancybox="group" data-caption="image-20210113102516774" class="fancybox"><img alt="image-20210113102516774" title="image-20210113102516774" data-src="image-20210113102516774.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">但，应注意：同一时刻，只能有一个线程持有该锁。</span><br><span class="line">当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</span><br><span class="line">所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</span><br><span class="line">因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</span><br></pre></td></tr></table></figure></div><h3 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init函数</span><br><span class="line">pthread_mutex_destroy函数</span><br><span class="line">pthread_mutex_lock函数</span><br><span class="line">pthread_mutex_trylock函数</span><br><span class="line">pthread_mutex_unlock函数</span><br><span class="line">以上5个函数的返回值都是：成功返回0， 失败返回错误号。</span><br><span class="line">pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</span><br><span class="line">pthread_mutex_t mutex; 变量mutex只有两种取值1、0。</span><br></pre></td></tr></table></figure></div><h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化一个互斥锁(互斥量) ---&gt; 初值可看作1</span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</span><br><span class="line">参1：传出参数，调用时应传 &amp;mutex</span><br><span class="line">restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</span><br><span class="line">参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</span><br><span class="line">1.静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">2.动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</span><br></pre></td></tr></table></figure></div><h4 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一个互斥锁</span><br><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加锁。可理解为将mutex--（或-1）</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解锁。可理解为将mutex ++（或+1）</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a>pthread_mutex_trylock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">尝试加锁</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div><h3 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a>加锁与解锁</h3><h4 id="lock与unlock"><a href="#lock与unlock" class="headerlink" title="lock与unlock"></a>lock与unlock</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</span><br><span class="line">unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</span><br><span class="line">例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。</span><br><span class="line">可假想mutex锁 init成功初值为1。lock 功能是将mutex--。unlock将mutex++</span><br></pre></td></tr></table></figure></div><h4 id="lock与trylock"><a href="#lock与trylock" class="headerlink" title="lock与trylock"></a>lock与trylock</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock加锁失败会阻塞，等待锁释放。</span><br><span class="line">trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</span><br></pre></td></tr></table></figure></div><h3 id="加锁步骤测试"><a href="#加锁步骤测试" class="headerlink" title="加锁步骤测试"></a>加锁步骤测试</h3><p>​    看如下程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误，造成数据混乱：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210113103905670.png" data-fancybox="group" data-caption="image-20210113103905670" class="fancybox"><img alt="image-20210113103905670" title="image-20210113103905670" data-src="image-20210113103905670.png" class="lazyload"></a></p><p>如图，打印出现了混乱，本来子线程应该打印hello world，主线程应该打印HELLO WORLD，但是由于存在竞争所以打印结果出现了混乱。</p><p>【练习】：修改该程序，使用mutex互斥锁进行同步。                                           </p><ol><li><p>定义全局互斥量，初始化init(&amp;m, NULL)互斥量，添加对应的destry</p></li><li><p>两个线程while中，两次printf前后，分别加lock和unlock</p></li><li><p>将unlock挪至第二个sleep后，发现交替现象很难出现。</p><p>线程在操作完共享资源后本应该立即解锁，但修改后，线程抱着锁睡眠。睡醒解锁后又立即加锁，这两个库函数本身不会阻塞。</p><p>所以在这两行代码之间失去cpu的概率很小。因此，另外一个线程很难得到加锁的机会。</p></li><li><p>main 中加flag = 5 将flg在while中– 这时，主线程输出5次后试图销毁锁，但子线程未将锁释放，无法完成。</p></li><li><p>main 中加pthread_cancel()将子线程取消。</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);<span class="comment">//mutex=1</span></span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210113110311406.png" data-fancybox="group" data-caption="image-20210113110311406" class="fancybox"><img alt="image-20210113110311406" title="image-20210113110311406" data-src="image-20210113110311406.png" class="lazyload"></a></p><p>如图，数据未出现混乱，由于每个线程之间是相互独立的。</p><p>1、将解锁放在sleep后，修改代码如下</p><ol start="4"><li><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line">        </span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);<span class="comment">//mutex=1</span></span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line">        </span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ol><p><a href="image-20210113110728552.png" data-fancybox="group" data-caption="image-20210113110728552" class="fancybox"><img alt="image-20210113110728552" title="image-20210113110728552" data-src="image-20210113110728552.png" class="lazyload"></a></p><p>如图，将会连续出现主线程打印与子线程连续打印，由于没有及时解锁，其他线程很难抢到cpu，所以出现此现象。</p><p><strong>结论：</strong></p><p>​     <strong>在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</strong></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>（现象）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 线程试图对同一个互斥量A加锁两次。</span><br><span class="line">2. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁</span><br></pre></td></tr></table></figure></div><p><a href="04_%E6%AD%BB%E9%94%81.png" data-fancybox="group" data-caption="04_死锁" class="fancybox"><img alt="04_死锁" title="04_死锁" data-src="04_%E6%AD%BB%E9%94%81.png" class="lazyload"></a></p><p>【作业】：编写程序，实现上述两种死锁现象。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</span><br></pre></td></tr></table></figure></div><h3 id="读写锁状态"><a href="#读写锁状态" class="headerlink" title="读写锁状态"></a>读写锁状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一把读写锁具备三种状态：</span><br><span class="line">1. 读模式下加锁状态 (读锁)</span><br><span class="line">2. 写模式下加锁状态 (写锁)</span><br><span class="line">3. 不加锁状态</span><br></pre></td></tr></table></figure></div><h3 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</span><br><span class="line">2.读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</span><br><span class="line">3.读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</span><br><span class="line">读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</span><br><span class="line">读写锁非常适合于对数据结构读的次数远大于写的情况。</span><br></pre></td></tr></table></figure></div><p><a href="03_%E8%AF%BB%E5%86%99%E9%94%81.png" data-fancybox="group" data-caption="03_读写锁" class="fancybox"><img alt="03_读写锁" title="03_读写锁" data-src="03_%E8%AF%BB%E5%86%99%E9%94%81.png" class="lazyload"></a></p><h3 id="主要应用函数-1"><a href="#主要应用函数-1" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_init函数</span><br><span class="line">pthread_rwlock_destroy函数</span><br><span class="line">pthread_rwlock_rdlock函数  </span><br><span class="line">pthread_rwlock_wrlock函数</span><br><span class="line">pthread_rwlock_tryrdlock函数</span><br><span class="line">pthread_rwlock_trywrlock函数</span><br><span class="line">pthread_rwlock_unlock函数</span><br><span class="line">以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。</span><br><span class="line">pthread_rwlock_t类型用于定义一个读写锁变量。</span><br><span class="line">pthread_rwlock_t rwlock;</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化一把读写锁</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</span><br><span class="line">参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一把读写锁</span><br><span class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以读方式请求读写锁。（常简称为：请求读锁）</span><br><span class="line">    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以写方式请求读写锁。（常简称为：请求写锁）</span><br><span class="line">    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解锁</span><br><span class="line">int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-tryrdlock函数"><a href="#pthread-rwlock-tryrdlock函数" class="headerlink" title="pthread_rwlock_tryrdlock函数"></a>pthread_rwlock_tryrdlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非阻塞以读方式请求读写锁（非阻塞请求读锁）</span><br><span class="line">int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_trywrlock函数"></a>pthread_rwlock_trywrlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非阻塞以写方式请求读写锁（非阻塞请求写锁）</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div><h3 id="读写锁示例"><a href="#读写锁示例" class="headerlink" title="读写锁示例"></a>读写锁示例</h3><p>【rwlock.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_write</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        t=counter;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"====write %d:%lu:counter=%d ++counter=%d\n"</span>,i,pthread_self(),t,++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_read</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----read %d:%lu:%d\n"</span>,i,pthread_self(),counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i],<span class="literal">NULL</span>,th_write,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i+<span class="number">3</span>],<span class="literal">NULL</span>,th_read,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210113155305435.png" data-fancybox="group" data-caption="image-20210113155305435" class="fancybox"><img alt="image-20210113155305435" title="image-20210113155305435" data-src="image-20210113155305435.png" class="lazyload"></a></p><p>如图，每次写线程都是独立的，读线程是共享的，可以看见好几个读线程读到的都是同一个count，而写锁是相互独立的，图中有两个连续的写操作，其中肯定是先执行一个写线程再执行另一个写线程。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</span><br></pre></td></tr></table></figure></div><h3 id="主要应用函数-2"><a href="#主要应用函数-2" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init函数</span><br><span class="line">pthread_cond_destroy函数</span><br><span class="line">pthread_cond_wait函数</span><br><span class="line">pthread_cond_timedwait函数</span><br><span class="line">pthread_cond_signal函数</span><br><span class="line">pthread_cond_broadcast函数</span><br><span class="line">以上<span class="number">6</span> 个函数的返回值都是：成功返回<span class="number">0</span>， 失败直接返回错误号。</span><br><span class="line"><span class="keyword">pthread_cond_t</span>类型用于定义条件变量</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure></div><h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化一个条件变量</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line">参<span class="number">2</span>：attr表条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></div><h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一个条件变量</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div><h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">阻塞等待一个条件变量</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line">函数作用：</span><br><span class="line"><span class="number">1.</span>阻塞等待条件变量cond（参<span class="number">1</span>）满足</span><br><span class="line"><span class="number">2.</span>释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"> <span class="number">1.2</span>.两步为一个原子操作。</span><br><span class="line"><span class="number">3.</span>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure></div><h4 id="pthread-cond-timedwait函数"><a href="#pthread-cond-timedwait函数" class="headerlink" title="pthread_cond_timedwait函数"></a>pthread_cond_timedwait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">限时等待一个条件变量</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line">参<span class="number">3</span>：参看man sem_timedwait函数，查看<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>结构体。</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line"><span class="keyword">time_t</span> tv_sec;<span class="comment">/* seconds */</span> 秒</span><br><span class="line"><span class="keyword">long</span>   tv_nsec;<span class="comment">/* nanosecondes*/</span> 纳秒</span><br><span class="line">&#125;</span><br><span class="line">形参abstime：绝对时间。</span><br><span class="line">如：time(<span class="literal">NULL</span>)返回的就是绝对时间。而alarm(<span class="number">1</span>)是相对时间，相对当前时间定时<span class="number">1</span>秒钟。</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> = &#123;</span><span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 <span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>秒(早已经过去) </span><br><span class="line">正确用法：</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>定义timespec 结构体变量t</span><br><span class="line">t.tv_sec = cur+<span class="number">1</span>; 定时<span class="number">1</span>秒</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参  参考APUE<span class="number">.11</span><span class="number">.6</span>线程同步条件变量小节</span><br><span class="line">在讲解setitimer函数时我们还提到另外一种时间类型：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">             <span class="keyword">time_t</span>      tv_sec;  <span class="comment">/* seconds */</span> 秒</span><br><span class="line">             <span class="keyword">suseconds_t</span> tv_usec; <span class="comment">/* microseconds */</span> 微秒</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></div><h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div><h4 id="pthread-cond-broadcast函数"><a href="#pthread-cond-broadcast函数" class="headerlink" title="pthread_cond_broadcast函数"></a>pthread_cond_broadcast函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">唤醒全部阻塞在条件变量上的线程</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div><h3 id="生产者消费者条件变量模型"><a href="#生产者消费者条件变量模型" class="headerlink" title="生产者消费者条件变量模型"></a>生产者消费者条件变量模型</h3><p><a href="05_%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.png" data-fancybox="group" data-caption="05_条件变量" class="fancybox"><img alt="05_条件变量" title="05_条件变量" data-src="05_%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</span><br></pre></td></tr></table></figure></div><p>【conditionVar_product_consumer.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">head</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">mp</span>=<span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product=PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mp=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));</span><br><span class="line">        mp-&gt;num=rand()%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"produced----%d\n"</span>,mp-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        mp-&gt;next=head;</span><br><span class="line">        head=mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;has_product,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        mp=head;</span><br><span class="line">        head=mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----comsumer--%d\n"</span>,mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        mp=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid,ctid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;ptid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;ctid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(ptid,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(ctid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210113200805248.png" data-fancybox="group" data-caption="image-20210113200805248" class="fancybox"><img alt="image-20210113200805248" title="image-20210113200805248" data-src="image-20210113200805248.png" class="lazyload"></a></p><p>一个顺序向下生产，一个逆序向上消费</p><h3 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相较于mutex而言，条件变量可以减少竞争。</span><br><span class="line">如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</span><br></pre></td></tr></table></figure></div><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进化版的互斥锁（1 --&gt; N）</span><br><span class="line">由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</span><br><span class="line">信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</span><br></pre></td></tr></table></figure></div><h3 id="主要应用函数-3"><a href="#主要应用函数-3" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sem_init函数</span><br><span class="line">sem_destroy函数</span><br><span class="line">sem_wait函数</span><br><span class="line">sem_trywait函数</span><br><span class="line">sem_timedwait函数</span><br><span class="line">sem_post函数</span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</span><br><span class="line">sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 </span><br><span class="line">sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure></div><h4 id="信号量基本操作"><a href="#信号量基本操作" class="headerlink" title="信号量基本操作"></a>信号量基本操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait:1. 信号量大于0，则信号量--（类比pthread_mutex_lock）</span><br><span class="line">|2. 信号量等于0，造成线程阻塞</span><br><span class="line">   对应</span><br><span class="line">|</span><br><span class="line">sem_post：将信号量++，同时唤醒阻塞在信号量上的线程（类比pthread_mutex_unlock）</span><br><span class="line">但，由于sem_t的实现对用户隐藏，所以所谓的++、--操作只能通过函数来实现，而不能直接++、--符号。</span><br></pre></td></tr></table></figure></div><p><strong>信号量的初值，决定了占用信号量的线程的个数。</strong></p><h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化一个信号量</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">参1：sem信号量</span><br><span class="line">参2：pshared取0用于线程间；取非0（一般为1）用于进程间</span><br><span class="line">参3：value指定信号量初值</span><br></pre></td></tr></table></figure></div><h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一个信号量</span><br><span class="line">int sem_destroy(sem_t *sem);</span><br></pre></td></tr></table></figure></div><h4 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a>sem_wait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给信号量加锁 -- </span><br><span class="line">int sem_wait(sem_t *sem);</span><br></pre></td></tr></table></figure></div><h4 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a>sem_post函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给信号量解锁 ++</span><br><span class="line"> int sem_post(sem_t *sem);</span><br></pre></td></tr></table></figure></div><h4 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a>sem_trywait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">尝试对信号量加锁 --(与sem_wait的区别类比lock和trylock)</span><br><span class="line"> int sem_trywait(sem_t *sem);</span><br></pre></td></tr></table></figure></div><h4 id="sem-timedwait函数"><a href="#sem-timedwait函数" class="headerlink" title="sem_timedwait函数"></a>sem_timedwait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">限时尝试对信号量加锁 --</span><br><span class="line">int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="line">参2：abs_timeout采用的是绝对时间。</span><br><span class="line">定时1秒：</span><br><span class="line">time_t cur &#x3D; time(NULL); 获取当前时间。</span><br><span class="line">struct timespec t;定义timespec 结构体变量t</span><br><span class="line">t.tv_sec &#x3D; cur+1; 定时1秒</span><br><span class="line">t.tv_nsec &#x3D; t.tv_sec +100; </span><br><span class="line">sem_timedwait(&amp;sem, &amp;t); 传参</span><br></pre></td></tr></table></figure></div><p><a href="07_%E4%BF%A1%E5%8F%B7%E9%87%8F.png" data-fancybox="group" data-caption="07_信号量" class="fancybox"><img alt="07_信号量" title="07_信号量" data-src="07_%E4%BF%A1%E5%8F%B7%E9%87%8F.png" class="lazyload"></a></p><h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a>生产者消费者信号量模型</h3><p>【练习】：使用信号量完成线程间同步，模拟生产者，消费者问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">规定：如果□中有数据，生产者不能生产，只能阻塞。</span><br><span class="line">如果□中没有数据，消费者不能消费，只能等待数据。</span><br><span class="line">定义两个信号量：S满 &#x3D; 0， S空 &#x3D; 1 （S满代表满格的信号量，S空表示空格的信号量，程序起始，格子一定为空）</span><br><span class="line">所以有：T生产者主函数 &#123;T消费者主函数 &#123;</span><br><span class="line">     sem_wait(S空);     sem_wait(S满);</span><br><span class="line">    生产....      消费....</span><br><span class="line">     sem_post(S满);     sem_post(S空);</span><br><span class="line">&#125;&#125;</span><br><span class="line">假设：线程到达的顺序是:T生、T生、T消。</span><br><span class="line">那么：T生1 到达，将S空-1，生产，将S满+1</span><br><span class="line">T生2 到达，S空已经为0， 阻塞</span><br><span class="line">T消  到达，将S满-1，消费，将S空+1</span><br><span class="line">三个线程到达的顺序是：T生1、T生2、T消。而执行的顺序是T生1、T消、T生2</span><br><span class="line">这里，S空 表示空格子的总数，代表可占用信号量的线程总数--&gt;1。其实这样的话，信号量就等同于互斥锁。</span><br><span class="line">但，如果S空&#x3D;2、3、4……就不一样了，该信号量同时可以由多个线程占用，不再是互斥的形式。因此我们说信号量是互斥锁的加强版。</span><br></pre></td></tr></table></figure></div><p>【sem_product_consumer.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[NUM];</span><br><span class="line"><span class="keyword">sem_t</span> blank_number,product_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);</span><br><span class="line">        <span class="built_in">queue</span>[i]=rand()%<span class="number">1000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---product----%d\n"</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number);</span><br><span class="line">        </span><br><span class="line">        i=(i+<span class="number">1</span>)%NUM;</span><br><span class="line">        sleep(rand()%<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;product_number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"consume----%d\n"</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i]=<span class="number">0</span>;</span><br><span class="line">        sem_post(&amp;blank_number);</span><br><span class="line">        i=(i+<span class="number">1</span>)%NUM;</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid,ctid;</span><br><span class="line">    </span><br><span class="line">    sem_init(&amp;blank_number,<span class="number">0</span>,NUM);</span><br><span class="line">    sem_init(&amp;product_number,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;ptid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;ctid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(ptid,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(ctid,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210114102538864.png" data-fancybox="group" data-caption="image-20210114102538864" class="fancybox"><img alt="image-20210114102538864" title="image-20210114102538864" data-src="image-20210114102538864.png" class="lazyload"></a></p><h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。</span><br></pre></td></tr></table></figure></div><h4 id="主要应用函数-4"><a href="#主要应用函数-4" class="headerlink" title="主要应用函数"></a>主要应用函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t mattr 类型：用于定义mutex锁的【属性】</span><br><span class="line">pthread_mutexattr_init函数：初始化一个mutex属性对象</span><br><span class="line">int pthread_mutexattr_init(pthread_mutexattr_t *attr);</span><br><span class="line">pthread_mutexattr_destroy函数：销毁mutex属性对象 (而非销毁锁)</span><br><span class="line">int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</span><br><span class="line">pthread_mutexattr_setpshared函数：修改mutex属性。</span><br><span class="line">int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</span><br><span class="line">参2：pshared取值：</span><br><span class="line">线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)</span><br><span class="line">进程锁：PTHREAD_PROCESS_SHARED</span><br></pre></td></tr></table></figure></div><h4 id="进程间mutex示例"><a href="#进程间mutex示例" class="headerlink" title="进程间mutex示例"></a>进程间mutex示例</h4><p>进程间使用mutex来实现同步：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mt</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    mm=mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(*mm),PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mm,<span class="number">0</span>,<span class="keyword">sizeof</span>(*mm));</span><br><span class="line">    </span><br><span class="line">    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr,PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;mm-&gt;mutex,&amp;mm-&gt;mutexattr);</span><br><span class="line">    </span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child-----num++   %d\n"</span>,mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)+=<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent-----num+=2   %d\n"</span>,mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);</span><br><span class="line">    pthread_mutex_destroy(&amp;mm-&gt;mutex);</span><br><span class="line">    munmap(mm,<span class="keyword">sizeof</span>(*mm));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210114112524450.png" data-fancybox="group" data-caption="image-20210114112524450" class="fancybox"><img alt="image-20210114112524450" title="image-20210114112524450" data-src="image-20210114112524450.png" class="lazyload"></a></p><h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">借助 fcntl函数来实现锁机制。操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。</span><br><span class="line">fcntl函数：获取、设置文件访问控制属性。</span><br><span class="line">int fcntl(int fd, int cmd, ... &#x2F;* arg *&#x2F; );</span><br><span class="line">参2：</span><br><span class="line">F_SETLK (struct flock *)设置文件锁（trylock）</span><br><span class="line">F_SETLKW (struct flock *) 设置文件锁（lock）W --&gt; wait</span><br><span class="line">F_GETLK (struct flock *)获取文件锁</span><br><span class="line">参3：</span><br><span class="line">        struct flock &#123;</span><br><span class="line">              ...</span><br><span class="line">              short l_type;    锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span><br><span class="line">              short l_whence;  偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span><br><span class="line">              off_t l_start;   起始偏移：1000</span><br><span class="line">              off_t l_len;     长度：0表示整个文件加锁</span><br><span class="line">              pid_t l_pid;     持有该锁的进程ID：(F_GETLK only)</span><br><span class="line">              ...</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure></div><p><a href="01_fcntl%E5%92%8C%E4%BD%8D%E5%9B%BE.png" data-fancybox="group" data-caption="01_fcntl和位图" class="fancybox"><img alt="01_fcntl和位图" title="01_fcntl和位图" data-src="01_fcntl%E5%92%8C%E4%BD%8D%E5%9B%BE.png" class="lazyload"></a></p><h4 id="进程间文件锁示例"><a href="#进程间文件锁示例" class="headerlink" title="进程间文件锁示例"></a>进程间文件锁示例</h4><p>多个进程对加锁文件进行访问： </p><p>1、选读锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">f_lock</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out filename\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fd==<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR))&lt;<span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">"open"</span>);</span><br><span class="line">    <span class="comment">//f_lock.l_type=F_WRLCK;</span></span><br><span class="line">    f_lock.l_type=F_RDLCK;</span><br><span class="line">    f_lock.l_whence=SEEK_SET;</span><br><span class="line">    f_lock.l_start=<span class="number">0</span>;</span><br><span class="line">    f_lock.l_len=<span class="number">0</span>;<span class="comment">//将整个文件加锁</span></span><br><span class="line">    </span><br><span class="line">    fcntl(fd,F_SETLKW,&amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get flock\n"</span>);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    f_lock.l_type=F_UNLCK;</span><br><span class="line">    fcntl(fd,F_SETLKW,&amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"un flock\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210114120330676.png" data-fancybox="group" data-caption="image-20210114120330676" class="fancybox"><img alt="image-20210114120330676" title="image-20210114120330676" data-src="image-20210114120330676.png" class="lazyload"></a></p><p>如图，两个进程可以对加读锁的文件进行操作。</p><p>2、选写锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f_lock.l_type=F_WRLCK;</span><br><span class="line"><span class="comment">//f_lock.l_type=F_RDLCK;</span></span><br><span class="line">f_lock.l_whence=SEEK_SET;</span><br><span class="line">f_lock.l_start=<span class="number">0</span>;</span><br><span class="line">f_lock.l_len=<span class="number">0</span>;<span class="comment">//将整个文件加锁</span></span><br></pre></td></tr></table></figure></div><p>​    依然遵循“读共享、写独占”特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p><p>【思考】：多线程中，可以使用文件锁吗？</p><p>​    多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p><h2 id="哲学家用餐模型分析"><a href="#哲学家用餐模型分析" class="headerlink" title="哲学家用餐模型分析"></a>哲学家用餐模型分析</h2><p><a href="08_%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%94%A8%E9%A4%90%E7%AE%80%E6%9E%90.png" data-fancybox="group" data-caption="08_哲学家用餐简析" class="fancybox"><img alt="08_哲学家用餐简析" title="08_哲学家用餐简析" data-src="08_%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%94%A8%E9%A4%90%E7%AE%80%E6%9E%90.png" class="lazyload"></a></p><h3 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选用互斥锁mutex，如创建5个， pthread_mutex_t m[5];</span><br><span class="line">模型抽象：</span><br><span class="line">5个哲学家 --&gt; 5个线程；5支筷子 --&gt; 5把互斥锁int left(左手)， right(右手)</span><br><span class="line">5个哲学家使用相同的逻辑，可通用一个线程主函数，void *tfn(void *arg)，使用参数来表示线程编号：int i &#x3D; (int)arg;</span><br><span class="line">哲学家线程根据编号知道自己是第几个哲学家，而后选定锁，锁住，吃饭。否则哲学家thinking。</span><br><span class="line">     A   B   C   D   E</span><br><span class="line">5支筷子，在逻辑上形成环： 0   1   2   3   4   分别对应5个哲学家：</span><br></pre></td></tr></table></figure></div><p><a href="image-20210114121742982.png" data-fancybox="group" data-caption="image-20210114121742982" class="fancybox"><img alt="image-20210114121742982" title="image-20210114121742982" data-src="image-20210114121742982.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">所以有：</span><br><span class="line">if(i &#x3D;&#x3D; 4)</span><br><span class="line">left &#x3D; i, right &#x3D; 0;</span><br><span class="line">else </span><br><span class="line">left &#x3D; i, right &#x3D; i+1;</span><br><span class="line">振荡：如果每个人都攥着自己左手的锁，尝试去拿右手锁，拿不到则将锁释放。过会儿五个人又同时再攥着左手锁尝试拿右手锁，依然拿不到。如此往复形成另外一种极端死锁的现象——振荡。</span><br><span class="line">避免振荡现象：只需5个人中，任意一个人，拿锁的方向与其他人相逆即可(如：E，原来：左：4，右：0现在：左：0， 右：4)。</span><br><span class="line">所以以上if else语句应改为：</span><br><span class="line">if(i &#x3D;&#x3D; 4)</span><br><span class="line">left &#x3D; 0, right &#x3D; i;</span><br><span class="line">else </span><br><span class="line">left &#x3D; i, right &#x3D; i+1;</span><br><span class="line">而后， 首先应让哲学家尝试加左手锁：</span><br><span class="line">while &#123; </span><br><span class="line">pthread_mutex_lock(&amp;m[left]); 如果加锁成功，函数返回再加右手锁，</span><br><span class="line">如果失败，应立即释放左手锁，等待。</span><br><span class="line">若，左右手都加锁成功 --&gt; 吃 --&gt; 吃完 --&gt; 释放锁（应先释放右手、再释放左手，是加锁顺序的逆序）</span><br><span class="line">&#125;</span><br><span class="line">主线程(main)中，初始化5把锁，销毁5把锁，创建5个线程（并将i传递给线程主函数），回收5个线程。</span><br></pre></td></tr></table></figure></div><p><strong>避免死锁的方法：</strong></p><p>​     <strong>1.</strong> <strong>当得不到所有所需资源时，放弃已经获得的资源，等待。</strong></p><p>​     <strong>2.</strong> <strong>保证资源的获取顺序，要求每个线程获取资源的顺序一致。</strong>如：A获取顺序1、2、3；B顺序应也是1、2、3。若B为3、2、1则易出现死锁现象。</p><h3 id="多进程版"><a href="#多进程版" class="headerlink" title="多进程版"></a>多进程版</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">相较于多线程需注意问题：</span><br><span class="line">需注意如何共享信号量 (注意：坚决不能使用全局变量 sem_t s[5])</span><br><span class="line">实现：</span><br><span class="line">main函数中：</span><br><span class="line">循环 sem_init(&amp;s[i], 0, 1); 将信号量初值设为1，信号量变为互斥锁。</span><br><span class="line">循环 sem_destroy(&amp;s[i]);</span><br><span class="line">循环 创建 5 个子进程。 if(i &lt; 5) 中完成子进程的代码逻辑。</span><br><span class="line">循环 回收 5 个子进程。</span><br><span class="line">子进程中：</span><br><span class="line">if(i &#x3D;&#x3D; 4)  </span><br><span class="line">left &#x3D; 0, right &#x3D;&#x3D; 4;</span><br><span class="line">else</span><br><span class="line">left &#x3D; i, right &#x3D; i+1;</span><br><span class="line">while (1) &#123;</span><br><span class="line">使用 sem_wait(&amp;s[left]) 锁左手，尝试锁右手，若成功 --&gt; 吃； 若不成功 --&gt; 将左手锁释放。</span><br><span class="line">吃完后， 先释放右手锁，再释放左手锁。</span><br><span class="line">&#125;</span><br><span class="line">【重点注意】：</span><br><span class="line">直接将sem_t s[5]放在全局位置，试图用于子进程间共享是错误的！应将其定义放置与mmap共享映射区中。main中：</span><br><span class="line">sem_t *s &#x3D; mmap(NULL, sizeof(sem_t) * 5, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON， -1， 0);</span><br><span class="line">使用方式：将s当成数组首地址看待，与使用数组s[5]没有差异。</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步概念&quot;&gt;&lt;a href=&quot;#同步概念&quot; class=&quot;headerlink&quot; title=&quot;同步概念&quot;&gt;&lt;/a&gt;同步概念&lt;/h2&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/</id>
    <published>2021-01-30T07:20:26.456Z</published>
    <updated>2021-01-22T02:25:51.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</span><br><span class="line">进程：独立地址空间，拥有PCB</span><br><span class="line">线程：也有PCB，但没有独立的地址空间(共享)</span><br><span class="line">区别：在于是否共享地址空间。独居(进程)；合租(线程)。</span><br><span class="line">Linux下：线程：最小的执行单位</span><br><span class="line">         进程：最小分配资源单位，可看成是只有一个线程的进程。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111200002778.png" data-fancybox="group" data-caption="image-20210111200002778" class="fancybox"><img alt="image-20210111200002778" title="image-20210111200002778" data-src="image-20210111200002778.png" class="lazyload"></a></p><p><a href="02_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" data-fancybox="group" data-caption="02_进程和线程" class="fancybox"><img alt="02_进程和线程" title="02_进程和线程" data-src="02_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" class="lazyload"></a></p><p>有3个进程，相当于要把cpu分成三份，同时去抢夺cpu资源，若第一个进程变成了5个线程就相当于cpu要将自己分成5+2=7部分，进程1获得cpu的概率要大一些，故多线程可以提高程序的执行效率。若存在线程则与进程处于相同的地位，把线程的指令直接给cpu去执行，故线程为最小执行单元，不管多少个线程，使用的地址空间就只有一份都是0-4G的地址空间，使用进程未最小分配资源单位。</p><h3 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</span><br><span class="line">1. 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone（即大部分资源都是从父进程赋值而来的）</span><br><span class="line">2. 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</span><br><span class="line">3. 进程可以蜕变成线程</span><br><span class="line">4. 线程可看做寄存器和栈的集合</span><br><span class="line">5. 在linux下，线程最是小的执行单位；进程是最小的分配资源单位</span><br><span class="line">察看LWP号：ps –Lf pid 查看指定线程的lwp号。</span><br></pre></td></tr></table></figure></div><p><a href="03_%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84.png" data-fancybox="group" data-caption="03_三级映射" class="fancybox"><img alt="03_三级映射" title="03_三级映射" data-src="03_%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84.png" class="lazyload"></a></p><p>在PCB中有一个成员变量，是一个指针，指向一片空间（页目录  4K），页目录中有一条条的目录项，每个目录项都是一个指针，指向页表，页表中也对应一条条的子内容，该指针指向物理页面，里面存的是内存单元；每个进程都有一张映射表保存在内核空间，MMU通过映射表再映射到物理内存。线程间PCD指向页目录的指针相同。</p><p><a href="05_%E6%A0%88%E7%A9%BA%E9%97%B4.png" data-fancybox="group" data-caption="05_栈空间" class="fancybox"><img alt="05_栈空间" title="05_栈空间" data-src="05_%E6%A0%88%E7%A9%BA%E9%97%B4.png" class="lazyload"></a></p><p>每调用一个函数就会本来在一起的esp和ebp指针就会拉开距离，esp后移产生一块栈帧空间，再一次调用就继续后移，但是栈帧再向下一块栈帧空间移动的时候会将当前的esp和ebp保存再进行移动，显然每个线程对于用户这块栈区间不共享，若一样则线程和线程之间无法进行区分。</p><p>内核区的栈用于保存寄存器的值，由于进程间的切换，cpu给不同的进程分配时间轮片，保存以 用于后续的恢复，所以对于内核区的栈线程间也不一样，所以线程可看做寄存器和栈的集合。</p><p><strong>查看firefox浏览器有多少个线程？</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep firefox</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111204303061.png" data-fancybox="group" data-caption="image-20210111204303061" class="fancybox"><img alt="image-20210111204303061" title="image-20210111204303061" data-src="image-20210111204303061.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -Lf 12242</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111204357523.png" data-fancybox="group" data-caption="image-20210111204357523" class="fancybox"><img alt="image-20210111204357523" title="image-20210111204357523" data-src="image-20210111204357523.png" class="lazyload"></a></p><p>LWP线程号的作用：cpu分配时间轮片的依据</p><p>线程ID：用于进程内部区分线程</p><p><a href="image-20210111204708425.png" data-fancybox="group" data-caption="image-20210111204708425" class="fancybox"><img alt="image-20210111204708425" title="image-20210111204708425" data-src="image-20210111204708425.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三级映射：进程PCB --&gt; 页目录(可看成数组，首地址位于PCB中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元</span><br><span class="line"></span><br><span class="line">对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</span><br><span class="line">但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</span><br><span class="line">实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</span><br><span class="line">如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</span><br><span class="line">因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</span><br></pre></td></tr></table></figure></div><h3 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.文件描述符表</span><br><span class="line">2.每种信号的处理方式</span><br><span class="line">3.当前工作目录</span><br><span class="line">4.用户ID和组ID</span><br><span class="line">5.内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</span><br></pre></td></tr></table></figure></div><h3 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.线程id</span><br><span class="line">2.处理器现场和栈指针(内核栈)</span><br><span class="line">3.独立的栈空间(用户空间栈)</span><br><span class="line">4.errno变量</span><br><span class="line">5.信号屏蔽字</span><br><span class="line">6.调度优先级</span><br></pre></td></tr></table></figure></div><h3 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：1. 提高程序并发性2. 开销小3. 数据通信、共享数据方便</span><br><span class="line">缺点：1. 库函数，不稳定2. 调试、编写困难、gdb不支持3. 对信号支持不好</span><br><span class="line">优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</span><br></pre></td></tr></table></figure></div><h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h2><h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h3><p><a href="image-20210111210743448.png" data-fancybox="group" data-caption="image-20210111210743448" class="fancybox"><img alt="image-20210111210743448" title="image-20210111210743448" data-src="image-20210111210743448.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取线程ID。其作用对应进程中 getpid() 函数。</span><br><span class="line">pthread_t pthread_self(void);返回值：成功：0；失败：无！</span><br><span class="line">线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</span><br><span class="line">线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</span><br><span class="line">注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</span><br></pre></td></tr></table></figure></div><h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h3><p><a href="image-20210111210931650.png" data-fancybox="group" data-caption="image-20210111210931650" class="fancybox"><img alt="image-20210111210931650" title="image-20210111210931650" data-src="image-20210111210931650.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建一个新线程。其作用，对应进程中fork() 函数。</span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="line">返回值：成功：0；失败：错误号-----Linux环境下，所有线程特点，失败均直接返回错误号。</span><br><span class="line">参数：</span><br><span class="line">pthread_t：当前Linux中可理解为：typedef  unsigned long int  pthread_t;</span><br><span class="line">参数1：传出参数，保存系统为我们分配好的线程ID</span><br><span class="line">参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</span><br><span class="line">参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</span><br><span class="line">参数4：线程主函数执行期间所使用的参数。</span><br><span class="line">在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</span><br><span class="line">pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</span><br><span class="line">attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</span><br></pre></td></tr></table></figure></div><p>【练习】：创建一个新线程，打印线程ID。注意：链接线程库 -lpthread</p><p>【pthrd_crt.c】</p><p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In thread :thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    </span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将其打印到标准错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main2:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112094350992.png" data-fancybox="group" data-caption="image-20210112094350992" class="fancybox"><img alt="image-20210112094350992" title="image-20210112094350992" data-src="image-20210112094350992.png" class="lazyload"></a></p><p>如图，主线程的线程id没变，所有的线程的进程id都一样。</p><p>【练习】：循环创建多个线程，每个线程打印自己是第几个被创建的线程。(类似于进程循环创建子进程) </p><p>【more_pthrd.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dth thread :thread id=%lu,pid=%u\n"</span>,i+<span class="number">1</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将其打印到标准错误</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112101728306.png" data-fancybox="group" data-caption="image-20210112101728306" class="fancybox"><img alt="image-20210112101728306" title="image-20210112101728306" data-src="image-20210112101728306.png" class="lazyload"></a></p><p>如图，不会出现像fork创建进程一样，出现子进程创建子进程的现象，因为每次创建线程创建成功后会调用自己的回调函数，而创建子线程是在main函数中进行，代码逻辑不同。对于(void*)i，在32位系统中，将int类型转换为void类型的指针，都是4字节，因此不会出错，在64位系统中int（4字节）转换为void指针（8字节）提升精度，高位提升，之后void指针截断为int也是高位截断也不会出错。</p><p>拓展思考：将pthread_create函数参4修改为(void <em>)&amp;i, 将线程主函数内改为 i=</em>((int *)arg) 是否可以？</p><p><a href="image-20210112102657631.png" data-fancybox="group" data-caption="image-20210112102657631" class="fancybox"><img alt="image-20210112102657631" title="image-20210112102657631" data-src="image-20210112102657631.png" class="lazyload"></a></p><p>不可以，因为5个线程几乎同时创建，每个线程保存的是i的地址，在对i取值的过程中，i的值可能早就变了。如图一条子线程的数据都没有打印，每次情况都不定。</p><h4 id="线程与共享"><a href="#线程与共享" class="headerlink" title="线程与共享"></a>线程与共享</h4><p><strong>线程间共享全局变量！</strong></p><p>【<strong>牢记</strong>】：线程默认共享数据段、代码段等地址空间，常用的是全局变量。而进程不共享全局变量，只能借助mmap。</p><p>【练习】：设计程序，验证线程之间共享全局数据。</p><p>【glb_var_pthrd.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"At first var=%d\n"</span>,var);</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after pthread_create,var=%d\n"</span>,var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112103449535.png" data-fancybox="group" data-caption="image-20210112103449535" class="fancybox"><img alt="image-20210112103449535" title="image-20210112103449535" data-src="image-20210112103449535.png" class="lazyload"></a></p><h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将单个线程退出</span><br><span class="line">void pthread_exit(void *retval);参数：retval表示线程退出状态，通常传NULL</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112104825952.png" data-fancybox="group" data-caption="image-20210112104825952" class="fancybox"><img alt="image-20210112104825952" title="image-20210112104825952" data-src="image-20210112104825952.png" class="lazyload"></a></p><p>思考：使用exit将指定线程退出，可以吗？ </p><p>【pthrd_exit.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In thread :thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    </span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将其打印到标准错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main2:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112104912783.png" data-fancybox="group" data-caption="image-20210112104912783" class="fancybox"><img alt="image-20210112104912783" title="image-20210112104912783" data-src="image-20210112104912783.png" class="lazyload"></a>    </p><p>如图，没有sleep子线程也可以正常打印输出，如果是return或exit，函数结束就整个进程都结束了。</p><p> 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</span><br><span class="line"></span><br><span class="line">所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</span><br><span class="line"></span><br><span class="line">另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</span><br></pre></td></tr></table></figure></div><p>【练习】：编写多线程程序，总结exit、return、pthread_exit各自退出效果。</p><p>​     return：返回到调用者那里去。</p><p>​     pthread_exit()：将调用该函数的线程          </p><p>​     exit: 将进程退出。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">   <span class="comment">//exit(1);</span></span><br><span class="line">    <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        func(<span class="number">888</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dth thread :thread id=%lu,pid=%u\n"</span>,i+<span class="number">1</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将其打印到标准错误</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>1、return a</p><p><a href="image-20210112110351952.png" data-fancybox="group" data-caption="image-20210112110351952" class="fancybox"><img alt="image-20210112110351952" title="image-20210112110351952" data-src="image-20210112110351952.png" class="lazyload"></a></p><p>所有线程成功打印输出，因为return表示返回调用处。</p><p>2、exit(1)</p><p><a href="image-20210112110454767.png" data-fancybox="group" data-caption="image-20210112110454767" class="fancybox"><img alt="image-20210112110454767" title="image-20210112110454767" data-src="image-20210112110454767.png" class="lazyload"></a></p><p>如图未打印完全，exit(1)表示退出进程，在第3个线程的时候退出了，好几个线程可能产生但没来得及打印。</p><p>3、pthread_exit(NULL)</p><p><a href="image-20210112110639903.png" data-fancybox="group" data-caption="image-20210112110639903" class="fancybox"><img alt="image-20210112110639903" title="image-20210112110639903" data-src="image-20210112110639903.png" class="lazyload"></a></p><p>如图只有第3个线程为被打印，由于调用函数，函数执行pthread_exit(1)，只退出来第3个线程。</p><h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">阻塞等待线程退出，获取线程退出状态其作用，对应进程中 waitpid() 函数。</span><br><span class="line">int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号</span><br><span class="line">参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。</span><br><span class="line">对比记忆：</span><br><span class="line">进程中：main返回值、exit参数--&gt;int；等待子进程结束 wait 函数参数--&gt;int *</span><br><span class="line">线程中：线程主函数返回值、pthread_exit--&gt;void *；等待线程结束 pthread_join 函数参数--&gt;void **</span><br></pre></td></tr></table></figure></div><p>【练习】：参数 retval 非空用法。</p><p>【pthrd_exit_join.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;<span class="keyword">exit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">exit_t</span>* ret=(<span class="keyword">exit_t</span>*)arg;</span><br><span class="line">    ret-&gt;a=<span class="number">100</span>;</span><br><span class="line">    ret-&gt;b=<span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">exit_t</span> *retval;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    retval=(<span class="keyword">exit_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">exit_t</span>));</span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="keyword">void</span>*)retval);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将其打印到标准错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,retval-&gt;a,retval-&gt;b);</span><br><span class="line">    <span class="built_in">free</span>(retval);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112151049642.png" data-fancybox="group" data-caption="image-20210112151049642" class="fancybox"><img alt="image-20210112151049642" title="image-20210112151049642" data-src="image-20210112151049642.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</span><br><span class="line">1.如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</span><br><span class="line">2.如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</span><br><span class="line">3.如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</span><br><span class="line">4.如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</span><br></pre></td></tr></table></figure></div><p>【练习】：使用pthread_join函数将循环创建的多个子线程回收。</p><p>【pthrd_loop_join.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var=<span class="number">333</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"var=%d\n"</span>,var);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)var;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var=<span class="number">777</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm %dth pthread,pthread_id=%lu,var=%d\n"</span>,i+<span class="number">1</span>,pthread_self(),var);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm %dth pthread,pthread_id=%lu,var=%d\n"</span>,i+<span class="number">1</span>,pthread_self(),var);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)var);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span>* ret[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i],<span class="literal">NULL</span>,tnf,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],(<span class="keyword">void</span>**)&amp;ret[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d's ret = %d\n"</span>,i,(<span class="keyword">int</span>)ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112153751348.png" data-fancybox="group" data-caption="image-20210112153751348" class="fancybox"><img alt="image-20210112153751348" title="image-20210112153751348" data-src="image-20210112153751348.png" class="lazyload"></a></p><h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实现线程分离</span><br><span class="line">int pthread_detach(pthread_t thread);成功：0；失败：错误号</span><br><span class="line">线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</span><br><span class="line">进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</span><br><span class="line">也可使用 pthread_create函数参2(线程属性)来设置线程分离。</span><br></pre></td></tr></table></figure></div><p>【练习】：使用pthread_detach函数实现线程分离</p><p>【pthrd_detach.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>,n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">void</span>* tret;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err=pthread_join(tid,&amp;tret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----err=%d\n"</span>,err);</span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread_join error:%s\n"</span>,strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread_join exit code:%d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112160015254.png" data-fancybox="group" data-caption="image-20210112160015254" class="fancybox"><img alt="image-20210112160015254" title="image-20210112160015254" data-src="image-20210112160015254.png" class="lazyload"></a></p><p>如图，线程分离后，主线程就无法对子线程进行回收，所以报错，并且主线程与子线程抢夺cpu，因为数字打印和错误打印轮流，本来pthread_join为阻塞回收，但分离线程不需要被回收所以互相抢夺。</p><p>将程序做如下修改（注释分离操作）:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//pthread_detach(tid);</span></span><br></pre></td></tr></table></figure></div><p><a href="image-20210112160403348.png" data-fancybox="group" data-caption="image-20210112160403348" class="fancybox"><img alt="image-20210112160403348" title="image-20210112160403348" data-src="image-20210112160403348.png" class="lazyload"></a></p><p>如图，主线程阻塞等子线程结束后进行回收并成功返回1，线程已被回收再继续进行回收报错。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</span><br></pre></td></tr></table></figure></div><h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">杀死(取消)线程其作用，对应进程中 kill() 函数。</span><br><span class="line">int pthread_cancel(pthread_t thread);成功：0；失败：错误号</span><br><span class="line">【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</span><br><span class="line">类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</span><br><span class="line">取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</span><br><span class="line">可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthread_testcancel函数自行设置一个取消点。</span><br><span class="line">被取消的线程，退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</span><br></pre></td></tr></table></figure></div><p>【练习】：终止线程的三种方法。注意“取消点”的概念。</p><p>【pthrd_endof3.c】 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf1</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1:I am returning\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf2</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2:I am exiting\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf3</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread3:I am going to be killed\n"</span>);</span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span>* tret;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 exit code:%d\n\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2 exit code:%d\n\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf3,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread3 exit code:%d\n\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112162620343.png" data-fancybox="group" data-caption="image-20210112162620343" class="fancybox"><img alt="image-20210112162620343" title="image-20210112162620343" data-src="image-20210112162620343.png" class="lazyload"></a></p><p>如图，线程被杀死后退出返回-1，而且待被杀死的线程里面必须存在返回点（系统调用等），如线程中没有取消点，可以通过调用pthread_testcancel函数自行设置一个取消点,否则无法退出，如下图所示:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf3</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        <span class="comment">//printf("thread3:I am going to be killed\n");</span></span><br><span class="line">        <span class="comment">//pthread_testcancel();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112162935751.png" data-fancybox="group" data-caption="image-20210112162935751" class="fancybox"><img alt="image-20210112162935751" title="image-20210112162935751" data-src="image-20210112162935751.png" class="lazyload"></a></p><p>第三个线程由于没有取消点，无法被杀死。</p><h4 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a>终止线程方式</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：终止某个线程而不终止整个进程，有三种方法：</span><br><span class="line">1.从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</span><br><span class="line">2.一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</span><br><span class="line">3.线程可以调用pthread_exit终止自己。</span><br></pre></td></tr></table></figure></div><h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a>pthread_equal函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比较两个线程ID是否相等。</span><br><span class="line">int pthread_equal(pthread_t t1, pthread_t t2);</span><br><span class="line">有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</span><br></pre></td></tr></table></figure></div><p>由于现在Linux的线程为整型，可以通过==进行判断。</p><h3 id="控制原语对比"><a href="#控制原语对比" class="headerlink" title="控制原语对比"></a>控制原语对比</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程线程</span><br><span class="line">forkpthread_create</span><br><span class="line">exitpthread_exit</span><br><span class="line">waitpthread_join</span><br><span class="line">killpthread_cancel</span><br><span class="line">getpidpthread_self命名空间</span><br></pre></td></tr></table></figure></div><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">本节作为指引性介绍，linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</span><br><span class="line">    typedef struct</span><br><span class="line">    &#123;</span><br><span class="line">    int etachstate; &#x2F;&#x2F;线程的分离状态</span><br><span class="line">    int schedpolicy; &#x2F;&#x2F;线程调度策略</span><br><span class="line">    struct sched_paramschedparam; &#x2F;&#x2F;线程的调度参数</span><br><span class="line">    int inheritsched; &#x2F;&#x2F;线程的继承性</span><br><span class="line">    int scope; &#x2F;&#x2F;线程的作用域</span><br><span class="line">    size_t guardsize; &#x2F;&#x2F;线程栈末尾的警戒缓冲区大小</span><br><span class="line">    intstackaddr_set; &#x2F;&#x2F;线程的栈设置</span><br><span class="line">    void* stackaddr; &#x2F;&#x2F;线程栈的位置</span><br><span class="line">    size_t stacksize; &#x2F;&#x2F;线程栈的大小</span><br><span class="line">    &#125; pthread_attr_t; </span><br><span class="line">    </span><br><span class="line">主要结构体成员：</span><br><span class="line">1. 线程分离状态</span><br><span class="line">2. 线程栈大小（默认平均分配）</span><br><span class="line">3. 线程栈警戒缓冲区大小（位于栈末尾）</span><br><span class="line">属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。</span><br><span class="line">线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</span><br></pre></td></tr></table></figure></div><h3 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：应先初始化线程属性，再pthread_create创建线程</span><br><span class="line">初始化线程属性</span><br><span class="line">int pthread_attr_init(pthread_attr_t *attr); 成功：0；失败：错误号</span><br><span class="line">销毁线程属性所占用的资源</span><br><span class="line">int pthread_attr_destroy(pthread_attr_t *attr); 成功：0；失败：错误号</span><br></pre></td></tr></table></figure></div><h3 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程的分离状态决定一个线程以什么样的方式来终止自己。</span><br><span class="line">非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</span><br><span class="line">分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</span><br><span class="line">线程分离状态的函数：</span><br><span class="line">设置线程属性，分离or非分离</span><br><span class="line">int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); </span><br><span class="line">获取程属性，分离or非分离</span><br><span class="line">int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate); </span><br><span class="line">参数：attr：已初始化的线程属性</span><br><span class="line">  detachstate：PTHREAD_CREATE_DETACHED（分离线程）</span><br><span class="line">         PTHREAD _CREATE_JOINABLE（非分离线程）</span><br><span class="line">这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</span><br></pre></td></tr></table></figure></div><p>【thrd_attr.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">77</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    </span><br><span class="line">    ret=pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_init_error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    ret=pthread_create(&amp;tid,&amp;attr,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create_error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret=pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_join_error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------join ret=%d\n"</span>,(<span class="keyword">int</span>)retval);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112204359113.png" data-fancybox="group" data-caption="image-20210112204359113" class="fancybox"><img alt="image-20210112204359113" title="image-20210112204359113" data-src="image-20210112204359113.png" class="lazyload"></a></p><p>回收出错，由于线程属于分离态，无需对其进行回收。</p><h3 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a>线程的栈地址</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POSIX.1定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。</span><br><span class="line">当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。</span><br><span class="line">int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize); 成功：0；失败：错误号</span><br><span class="line">int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize); 成功：0；失败：错误号</span><br><span class="line">参数：attr：指向一个线程属性的指针</span><br><span class="line">         stackaddr：返回获取的栈地址</span><br><span class="line">         stacksize：返回获取的栈大小</span><br></pre></td></tr></table></figure></div><p>进程默认栈空间大小8kB</p><p>测试某进程最多可以创建多少个线程？</p><p>不停的循环创建线程并且不结束即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error\n"</span>,strerror(ret));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----%d\n"</span>,count);</span><br><span class="line">        count++;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112205728832.png" data-fancybox="group" data-caption="image-20210112205728832" class="fancybox"><img alt="image-20210112205728832" title="image-20210112205728832" data-src="image-20210112205728832.png" class="lazyload"></a></p><p>如图，大概可以创建7444个线程。</p><h3 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a>线程的栈大小</h3><p><a href="image-20210112210539358.png" data-fancybox="group" data-caption="image-20210112210539358" class="fancybox"><img alt="image-20210112210539358" title="image-20210112210539358" data-src="image-20210112210539358.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</span><br><span class="line">函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。</span><br><span class="line">int pthread_attr_setstacksize(pthread_attr_t *attr,void* stackaddr, size_t stacksize); 成功：0；失败：错误号</span><br><span class="line">int pthread_attr_getstacksize(pthread_attr_t *attr, void* *stackaddr,size_t *stacksize); 成功：0；失败：错误号</span><br><span class="line">参数：attr：指向一个线程属性的指针</span><br><span class="line">         stacksize：返回线程的堆栈大小</span><br></pre></td></tr></table></figure></div><h3 id="线程的属性控制示例"><a href="#线程的属性控制示例" class="headerlink" title="线程的属性控制示例"></a>线程的属性控制示例</h3><p>循环将线程的栈空间开辟在堆区，程序的操作包含设置线程为分离态，修改线程的栈大小和地址：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 0x1000000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err,detachstate,i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">size_t</span> stacksize;<span class="comment">//typedef size_t unisigned int</span></span><br><span class="line">    <span class="keyword">void</span>* stackaddr;</span><br><span class="line">    </span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstack(&amp;attr,&amp;stackaddr,&amp;stacksize);</span><br><span class="line">    pthread_attr_getdetachstate(&amp;attr,&amp;detachstate);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(detachstate==PTHREAD_CREATE_DETACHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread detached\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(detachstate==PTHREAD_CREATE_JOINABLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread join\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread unknow\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stackaddr=<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        <span class="keyword">if</span>(stackaddr==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"malloc"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stacksize=SIZE;</span><br><span class="line">        pthread_attr_setstack(&amp;attr,stackaddr,stacksize);</span><br><span class="line">        </span><br><span class="line">        err=pthread_create(&amp;tid,&amp;attr,th_func,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i++);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112214357459.png" data-fancybox="group" data-caption="image-20210112214357459" class="fancybox"><img alt="image-20210112214357459" title="image-20210112214357459" data-src="image-20210112214357459.png" class="lazyload"></a></p><h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.察看当前pthread库版本getconf GNU_LIBPTHREAD_VERSION</span><br><span class="line">2.NPTL实现机制(POSIX)，Native POSIX Thread Library</span><br><span class="line">3.使用线程库时gcc指定 –lpthread</span><br></pre></td></tr></table></figure></div><p><a href="image-20210112214729387.png" data-fancybox="group" data-caption="image-20210112214729387" class="fancybox"><img alt="image-20210112214729387" title="image-20210112214729387" data-src="image-20210112214729387.png" class="lazyload"></a></p><h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.主线程退出其他线程不退出，主线程应调用pthread_exit</span><br><span class="line">2.避免僵尸线程</span><br><span class="line">pthread_join</span><br><span class="line">pthread_detach</span><br><span class="line">pthread_create指定分离属性</span><br><span class="line">被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</span><br><span class="line">3.malloc和mmap申请的内存可以被其他线程释放 </span><br><span class="line">4.应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</span><br><span class="line">5.信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</span><br></pre></td></tr></table></figure></div><p><a href="04_%E9%80%80%E5%87%BA%E5%80%BC.png" data-fancybox="group" data-caption="04_退出值" class="fancybox"><img alt="04_退出值" title="04_退出值" data-src="04_%E9%80%80%E5%87%BA%E5%80%BC.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; title=&quot;线程概念&quot;&gt;&lt;/a&gt;线程概念&lt;/h2&gt;&lt;h3 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day4/Day4/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day4/Day4/</id>
    <published>2021-01-30T07:20:26.207Z</published>
    <updated>2021-01-11T07:05:57.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪......他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。</span><br><span class="line">   信号是信息的载体，Linux&#x2F;UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</span><br><span class="line">Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</span><br></pre></td></tr></table></figure></div><h3 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</span><br><span class="line">信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</span><br></pre></td></tr></table></figure></div><p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p><p><a href="07_%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6.png" data-fancybox="group" data-caption="07_信号机制" class="fancybox"><img alt="07_信号机制" title="07_信号机制" data-src="07_%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6.png" class="lazyload"></a></p><p>如图，信号是由内核传给进程B，并由内核帮助进程B处理信号，并不是所说的A给B发送一个信号；并且信号不能为结构体，是因为其简单不能携带大量信息，只能携带一些状态信息。</p><h3 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">产生信号：</span><br><span class="line">1. 按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</span><br><span class="line">2. 系统调用产生，如：kill、raise、abort</span><br><span class="line">3. 软件条件产生，如：定时器alarm</span><br><span class="line">4. 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</span><br><span class="line">5. 命令产生，如：kill命令</span><br><span class="line">递达：递送并且到达进程。</span><br><span class="line">未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </span><br><span class="line">信号的处理方式: </span><br><span class="line">1. 执行默认动作 </span><br><span class="line">2. 忽略(丢弃) ---不是真的忽略，而是处理方式为忽略，将未决信号中的对应信号置0</span><br><span class="line">3. 捕捉(调用户处理函数)</span><br><span class="line">Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</span><br><span class="line">    阻塞信号集(信号屏蔽字)： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</span><br><span class="line">未决信号集: </span><br><span class="line">1. 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 </span><br><span class="line">2. 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</span><br></pre></td></tr></table></figure></div><p><a href="11_%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97_%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png" data-fancybox="group" data-caption="11_信号屏蔽字_未决信号集" class="fancybox"><img alt="11_信号屏蔽字_未决信号集" title="11_信号屏蔽字_未决信号集" data-src="11_%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97_%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png" class="lazyload"></a></p><p>如图，若发送一个信号，将对应的未决信号集中的对应位置1，若此时阻塞信号集中对应位也为1，则信号处于未决态，无法将执行的程序中断。</p><h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">可以使用kill –l命令查看当前系统可使用的信号有哪些。</span><br><span class="line">1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br><span class="line">不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210106174814199.png" data-fancybox="group" data-caption="image-20210106174814199" class="fancybox"><img alt="image-20210106174814199" title="image-20210106174814199" data-src="image-20210106174814199.png" class="lazyload"></a></p><h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">与变量三要素类似的，每个信号也有其必备4要素，分别是：</span><br><span class="line">1. 编号 2. 名称 3. 事件 4. 默认处理动作 </span><br><span class="line">可通过man 7 signal查看帮助文档获取。</span><br><span class="line">Signal     Value     Action   Comment</span><br><span class="line">────────────────────────────────────────────</span><br><span class="line">SIGHUP      1       Term    Hangup detected on controlling terminal or death of controlling process</span><br><span class="line">SIGINT       2       Term    Interrupt from keyboard</span><br><span class="line">SIGQUIT      3       Core    Quit from keyboard</span><br><span class="line">SIGILL       4       Core    Illegal Instruction</span><br><span class="line">SIGFPE       8       Core    Floating point exception</span><br><span class="line">SIGKILL      9       Term    Kill signal</span><br><span class="line">SIGSEGV     11      Core    Invalid memory reference</span><br><span class="line">SIGPIPE   13      Term    Broken pipe: write to pipe with no readers</span><br><span class="line">SIGALRM    14      Term    Timer signal from alarm(2)</span><br><span class="line">SIGTERM     15      Term    Termination signal</span><br><span class="line">SIGUSR1   30,10,16   Term    User-defined signal 1</span><br><span class="line">SIGUSR2   31,12,17   Term    User-defined signal 2</span><br><span class="line">SIGCHLD   20,17,18   Ign     Child stopped or terminated</span><br><span class="line">SIGCONT   19,18,25   Cont    Continue if stopped</span><br><span class="line">SIGSTOP   17,19,23   Stop    Stop process</span><br><span class="line">SIGTSTP   18,20,24   Stop    Stop typed at terminal</span><br><span class="line">SIGTTIN   21,21,26   Stop    Terminal input for background process</span><br><span class="line">SIGTTOU   22,22,27   Stop    Terminal output for background process</span><br></pre></td></tr></table></figure></div><p><a href="image-20210106175043191.png" data-fancybox="group" data-caption="image-20210106175043191" class="fancybox"><img alt="image-20210106175043191" title="image-20210106175043191" data-src="image-20210106175043191.png" class="lazyload"></a></p><h3 id="Linux常规信号一览表"><a href="#Linux常规信号一览表" class="headerlink" title="Linux常规信号一览表"></a>Linux常规信号一览表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</span><br><span class="line">2) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动</span><br><span class="line">作为终止进程。</span><br><span class="line">3) SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信</span><br><span class="line">号。默认动作为终止进程。</span><br><span class="line">4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</span><br><span class="line">5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</span><br><span class="line">6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。</span><br><span class="line">7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</span><br><span class="line">8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</span><br><span class="line">9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</span><br><span class="line">10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line">11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</span><br><span class="line">12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line">13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</span><br><span class="line">14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</span><br><span class="line">15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</span><br><span class="line">16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</span><br><span class="line">17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</span><br><span class="line">18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续&#x2F;忽略。</span><br><span class="line">19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</span><br><span class="line">20) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</span><br><span class="line">21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</span><br><span class="line">22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</span><br><span class="line">23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</span><br><span class="line">24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</span><br><span class="line">25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</span><br><span class="line">26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</span><br><span class="line">27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</span><br><span class="line">28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</span><br><span class="line">29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</span><br><span class="line">30) SIGPWR：关机。默认动作为终止进程。</span><br><span class="line">31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</span><br><span class="line">34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</span><br></pre></td></tr></table></figure></div><h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><h3 id="终端按键产生信号"><a href="#终端按键产生信号" class="headerlink" title="终端按键产生信号"></a>终端按键产生信号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + c  → 2) SIGINT（终止&#x2F;中断） &quot;INT&quot; ----Interrupt</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107102830056.png" data-fancybox="group" data-caption="image-20210107102830056" class="fancybox"><img alt="image-20210107102830056" title="image-20210107102830056" data-src="image-20210107102830056.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + z  → 20) SIGTSTP（暂停&#x2F;停止）  &quot;T&quot; ----Terminal 终端。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107103100433.png" data-fancybox="group" data-caption="image-20210107103100433" class="fancybox"><img alt="image-20210107103100433" title="image-20210107103100433" data-src="image-20210107103100433.png" class="lazyload"></a></p><p>SIGTSTP是20号信号，默认动作为停止与终端交互的进程，而19号信号SIGTSTOP可以停止所有进程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + \  → 3) SIGQUIT（退出）</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107103118578.png" data-fancybox="group" data-caption="image-20210107103118578" class="fancybox"><img alt="image-20210107103118578" title="image-20210107103118578" data-src="image-20210107103118578.png" class="lazyload"></a></p><p>对应3号信号，将该进程所使用的内存转移到其他地方让后将其结束。</p><h3 id="硬件异常产生信号"><a href="#硬件异常产生信号" class="headerlink" title="硬件异常产生信号"></a>硬件异常产生信号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">除0操作   → 8) SIGFPE (浮点数例外)&quot;F&quot; -----float 浮点数。</span><br><span class="line">非法访问内存  → 11) SIGSEGV (段错误)</span><br><span class="line">总线错误  → 7) SIGBUS</span><br></pre></td></tr></table></figure></div><h3 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a>kill函数/命令产生信号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill命令产生信号：kill -SIGKILL pid</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107103620930.png" data-fancybox="group" data-caption="image-20210107103620930" class="fancybox"><img alt="image-20210107103620930" title="image-20210107103620930" data-src="image-20210107103620930.png" class="lazyload"></a></p><p><a href="image-20210107103650066.png" data-fancybox="group" data-caption="image-20210107103650066" class="fancybox"><img alt="image-20210107103650066" title="image-20210107103650066" data-src="image-20210107103650066.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kill函数：给指定进程发送指定信号(不一定杀死)</span><br><span class="line">    int kill(pid_t pid, int sig); 成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</span><br><span class="line">sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">    pid &gt; 0:  发送信号给指定的进程。</span><br><span class="line">pid &#x3D; 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。</span><br><span class="line">pid &lt; 0:  取|pid|发给对应进程组。</span><br><span class="line">pid &#x3D; -1：发送给进程有权限发送的系统中所有进程。</span><br><span class="line">    进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</span><br><span class="line">权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID &#x3D;&#x3D; 接收者实际或有效用户ID</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107104546769.png" data-fancybox="group" data-caption="image-20210107104546769" class="fancybox"><img alt="image-20210107104546769" title="image-20210107104546769" data-src="image-20210107104546769.png" class="lazyload"></a></p><p><strong>练习</strong>：循环创建5个子进程，任一子进程用kill函数终止其父进程。</p><p>【kill.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            q = pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child %d, getpid = %u\n"</span>, i, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        kill(q, SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107113218286.png" data-fancybox="group" data-caption="image-20210107113218286" class="fancybox"><img alt="image-20210107113218286" title="image-20210107113218286" data-src="image-20210107113218286.png" class="lazyload"></a></p><p>如图第二次时，第2号进程被杀死故不打印到屏幕。</p><p>注意：尽量使用宏来表示信号，因为有些信号对应的值在不同平台下不一样，但是宏不会变。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat | cat | cat</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107115133132.png" data-fancybox="group" data-caption="image-20210107115133132" class="fancybox"><img alt="image-20210107115133132" title="image-20210107115133132" data-src="image-20210107115133132.png" class="lazyload"></a></p><p>执行kill -9杀死第一个cat进程，发现所有的cat进程都死了，这是因为|管道，第一个cat的结果作为第二个cat的输入，而管道的输入端被关闭，即管道的写端关闭，那所有的cat都关闭，并且这种关闭方式bash没有提示。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 -2984杀死同一进程组的进程</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107115413981.png" data-fancybox="group" data-caption="image-20210107115413981" class="fancybox"><img alt="image-20210107115413981" title="image-20210107115413981" data-src="image-20210107115413981.png" class="lazyload"></a></p><p>如图杀死同一组的进程，bash会提示已杀死。</p><h3 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raise 函数：给当前进程发送指定信号(自己给自己发)raise(signo) &#x3D;&#x3D; kill(getpid(), signo);</span><br><span class="line">    int raise(int sig); 成功：0，失败非0值</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, q;</span><br><span class="line"></span><br><span class="line">    raise(SIGINT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            q = pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child %d, getpid = %u\n"</span>, i, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        kill(q, SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107120328668.png" data-fancybox="group" data-caption="image-20210107120328668" class="fancybox"><img alt="image-20210107120328668" title="image-20210107120328668" data-src="image-20210107120328668.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件</span><br><span class="line">    void abort(void); 该函数无返回</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            q = pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child %d, getpid = %u\n"</span>, i, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        kill(q, SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107120317531.png" data-fancybox="group" data-caption="image-20210107120317531" class="fancybox"><img alt="image-20210107120317531" title="image-20210107120317531" data-src="image-20210107120317531.png" class="lazyload"></a></p><h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h3><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</span><br><span class="line">每个进程都有且只有唯一个定时器。</span><br><span class="line">unsigned int alarm(unsigned int seconds); 返回0或剩余的秒数，无失败。</span><br><span class="line">常用：取消定时器alarm(0)，返回旧闹钟余下秒数。</span><br><span class="line">例：alarm(5) → 3sec → alarm(4) → 5sec → alarm(5) → alarm(0)</span><br><span class="line">   定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸...无论进程处于何种状态，alarm都计时。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107150252531.png" data-fancybox="group" data-caption="image-20210107150252531" class="fancybox"><img alt="image-20210107150252531" title="image-20210107150252531" data-src="image-20210107150252531.png" class="lazyload"></a></p><p><a href="03_%E9%97%B9%E9%92%9F.png" data-fancybox="group" data-caption="03_闹钟" class="fancybox"><img alt="03_闹钟" title="03_闹钟" data-src="03_%E9%97%B9%E9%92%9F.png" class="lazyload"></a></p><p>练习：编写程序，测试你使用的计算机1秒钟能数多少个数。</p><p>【alarm .c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107150806849.png" data-fancybox="group" data-caption="image-20210107150806849" class="fancybox"><img alt="image-20210107150806849" title="image-20210107150806849" data-src="image-20210107150806849.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用time命令查看程序执行的时间。程序运行的瓶颈在于IO，优化程序，首选优化IO。</span><br><span class="line">实际执行时间 &#x3D; 系统时间 + 用户时间 + 等待时间</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107151157727.png" data-fancybox="group" data-caption="image-20210107151157727" class="fancybox"><img alt="image-20210107151157727" title="image-20210107151157727" data-src="image-20210107151157727.png" class="lazyload"></a></p><h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">   int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);成功：0；失败：-1，设置errno</span><br><span class="line">参数：which：指定定时方式</span><br><span class="line">1、自然定时：ITIMER_REAL → 14）SIGLARM 计算自然时间</span><br><span class="line">2、虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM   只计算进程占用cpu的时间</span><br><span class="line">3、运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF 计算占用cpu及执行系统调用的时间</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107152551279.png" data-fancybox="group" data-caption="image-20210107152551279" class="fancybox"><img alt="image-20210107152551279" title="image-20210107152551279" data-src="image-20210107152551279.png" class="lazyload"></a></p><p>new_value：定时时长</p><p>old_value：上次定时剩余时间</p><p><a href="image-20210107152959741.png" data-fancybox="group" data-caption="image-20210107152959741" class="fancybox"><img alt="image-20210107152959741" title="image-20210107152959741" data-src="image-20210107152959741.png" class="lazyload"></a></p><p>it_interval：指定两次定时间隔时长</p><p>it_value：定时时长</p><p>tv_sec：秒级</p><p>tv_usec：微秒级</p><p><strong>练习:</strong> 使用setitimer函数实现alarm函数，重复计算机1秒数数程序。</p><p>【setitimer.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct itimerval  &#123;</span></span><br><span class="line"><span class="comment">        struct timeval&#123;</span></span><br><span class="line"><span class="comment">            it_value.tv_sec;</span></span><br><span class="line"><span class="comment">            it_value.tv_usec;</span></span><br><span class="line"><span class="comment">        &#125; it_interval;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        struct timeval &#123;</span></span><br><span class="line"><span class="comment">            it_value.tv_sec;</span></span><br><span class="line"><span class="comment">            it_value.tv_usec;</span></span><br><span class="line"><span class="comment">        &#125; it_value;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125; it, oldit;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">my_alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">it.it_value.tv_sec = sec;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">it.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setitimer"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> oldit.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">my_alarm(<span class="number">1</span>);  <span class="comment">//alarm(sec);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; ; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107160411851.png" data-fancybox="group" data-caption="image-20210107160411851" class="fancybox"><img alt="image-20210107160411851" title="image-20210107160411851" data-src="image-20210107160411851.png" class="lazyload"></a></p><p><strong>拓展练习</strong>，结合man page编写程序，测试it_interval、it_value这两个参数的作用。 </p><p>提示：   it_interval：用来设定两次定时任务之间间隔的时间。</p><p>​               it_value：定时的时长                </p><p>两个参数都设置为0，即清0操作。</p><p><strong>你需要知道的：</strong></p><p>信号捕捉：</p><p><a href="image-20210107161614717.png" data-fancybox="group" data-caption="image-20210107161614717" class="fancybox"><img alt="image-20210107161614717" title="image-20210107161614717" data-src="image-20210107161614717.png" class="lazyload"></a></p><p>signal中两个参数，第一个为信号编号，第二个为函数指针，该函数指针为一个输入为int类型，输出为void类型的函数指针，捕捉到的信号不去执行默认操作而是执行函数指针所指向的函数。</p><p>【setitimer1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">signal(SIGALRM, myfunc);   <span class="comment">//注册SIGALRM信号的捕捉处理函数。</span></span><br><span class="line"></span><br><span class="line">it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"setitimer error"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107201159265.png" data-fancybox="group" data-caption="image-20210107201159265" class="fancybox"><img alt="image-20210107201159265" title="image-20210107201159265" data-src="image-20210107201159265.png" class="lazyload"></a></p><p>如图，第一次设定的时间为5s，5s后捕捉到了SIGALRM信号进行打印，之后每间隔3s发送一次SIGALRM信号。</p><h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</span><br></pre></td></tr></table></figure></div><h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sigset_t  set;&#x2F;&#x2F; typedef unsigned long sigset_t; </span><br><span class="line">int sigemptyset(sigset_t *set);        将某个信号集清0  成功：0；失败：-1</span><br><span class="line">int sigfillset(sigset_t *set);    将某个信号集置1   成功：0；失败：-1</span><br><span class="line">int sigaddset(sigset_t *set, int signum);将某个信号加入信号集     成功：0；失败：-1</span><br><span class="line">int sigdelset(sigset_t *set, int signum);将某个信号清出信号集      成功：0；失败：-1</span><br><span class="line">int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中返回值：在集合：1；不在：0；出错：-1  </span><br><span class="line">sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</span><br><span class="line">对比认知select 函数。</span><br></pre></td></tr></table></figure></div><p><a href="08_%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png" data-fancybox="group" data-caption="08_信号集操作函数" class="fancybox"><img alt="08_信号集操作函数" title="08_信号集操作函数" data-src="08_%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png" class="lazyload"></a></p><h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</span><br><span class="line">严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。</span><br><span class="line">oldset：传出参数，保存旧的信号屏蔽集。</span><br><span class="line">how参数取值：假设当前的信号屏蔽字为mask</span><br><span class="line">1.SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask &#x3D; mask|set</span><br><span class="line">2.SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask &#x3D; mask &amp; ~set</span><br><span class="line">3.SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask &#x3D; set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</span><br></pre></td></tr></table></figure></div><h3 id="sigpendiing函数"><a href="#sigpendiing函数" class="headerlink" title="sigpendiing函数"></a>sigpendiing函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读取当前进程的未决信号集</span><br><span class="line">int sigpending(sigset_t *set);set传出参数。   返回值：成功：0；失败：-1，设置errno</span><br></pre></td></tr></table></figure></div><p>练习：编写程序。把所有常规信号的未决状态打印至屏幕。</p><p>【sigpending.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(ped,i)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oldset,ped;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;ped);</span><br><span class="line">        printped(&amp;ped);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210107230517107.png" data-fancybox="group" data-caption="image-20210107230517107" class="fancybox"><img alt="image-20210107230517107" title="image-20210107230517107" data-src="image-20210107230517107.png" class="lazyload"></a></p><h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册一个信号捕捉函数：</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</span><br><span class="line">    void (*signal(int signum, void (*sighandler_t)(int))) (int);</span><br><span class="line">    能看出这个函数代表什么意思吗？  注意多在复杂结构中使用typedef。</span><br><span class="line">函数指针sighandler_t</span><br></pre></td></tr></table></figure></div><p>【signal1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I catch you---SIGINT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sighandler_t</span> handler;</span><br><span class="line"></span><br><span class="line">    handler = signal(SIGINT, catchsigint);</span><br><span class="line">    <span class="keyword">if</span> (handler == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">"signal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210108214922129.png" data-fancybox="group" data-caption="image-20210108214922129" class="fancybox"><img alt="image-20210108214922129" title="image-20210108214922129" data-src="image-20210108214922129.png" class="lazyload"></a></p><h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）</span><br><span class="line">    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">act：传入参数，新的处理方式。</span><br><span class="line">oldact：传出参数，旧的处理方式。</span><br></pre></td></tr></table></figure></div><p><a href="05_%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png" data-fancybox="group" data-caption="05_信号捕捉" class="fancybox"><img alt="05_信号捕捉" title="05_信号捕捉" data-src="05_%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png" class="lazyload"></a></p><h4 id="struct-sigaction结构体"><a href="#struct-sigaction结构体" class="headerlink" title="struct sigaction结构体"></a>struct sigaction结构体</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">        void     (*sa_handler)(int);</span><br><span class="line">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">        sigset_t   sa_mask; </span><br><span class="line">        int       sa_flags; </span><br><span class="line">        void     (*sa_restorer)(void);</span><br><span class="line">    &#125;;</span><br><span class="line">sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</span><br><span class="line">sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)  </span><br><span class="line">重点掌握：</span><br><span class="line">1、sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</span><br><span class="line">2、sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</span><br><span class="line">3、sa_flags：通常设置为0，表使用默认属性。</span><br></pre></td></tr></table></figure></div><h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</span><br><span class="line">2.XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。---sa_flag&#x3D;0</span><br><span class="line">3.阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</span><br><span class="line">理由：信号执行与否看的是未决信号集，该集合只能指示该信号是否被处理，没有记录有多少个信号的功能，所以发送多个同一信号只处理其中一个。</span><br></pre></td></tr></table></figure></div><p><strong>练习1</strong>：为某个信号设置捕捉函数</p><p>【sigaction1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  <span class="comment">//默认属性   信号捕捉函数执行期间，自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210109100632318.png" data-fancybox="group" data-caption="image-20210109100632318" class="fancybox"><img alt="image-20210109100632318" title="image-20210109100632318" data-src="image-20210109100632318.png" class="lazyload"></a></p><p>如图，内核对SIGINT信号进行捕捉，每一次发送SIGINT(Ctrl+C)信号，捕捉后执行dicatch函数。</p><p><strong>练习2</strong>： 验证在信号处理函数执行期间，该信号多次递送，那么只在处理函数之行结束后，处理一次。</p><p><strong>练习3</strong>：验证sa_mask在捕捉函数执行期间的屏蔽作用。</p><p>【sigaction2.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>, signo);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----docatch finish------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  <span class="comment">//默认属性   信号捕捉函数执行期间，自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210109102844539.png" data-fancybox="group" data-caption="image-20210109102844539" class="fancybox"><img alt="image-20210109102844539" title="image-20210109102844539" data-src="image-20210109102844539.png" class="lazyload"></a></p><p>在函数中设置sleep(10)模拟捕捉程序执行时间，如图，在捕捉到ctrl+c后，这10 s内向进程发送多个ctrl+c程序没有反应，直到前一个信号处理函数执行完成后仅仅执行了一次捕捉函数的调用；之后在信号处理函数执行期间对进程发送多个ctrl+\，由于在信号处理函数执行期间，根据sa_mask的设置对于SIGQUIT信号是屏蔽的，等处理函数执行完毕后，屏蔽字恢复到原来的状态，由于未对SIGQUIT实行屏蔽故执行SIGQUIT的默认处理动作。</p><h3 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程"></a>内核实现信号捕捉过程</h3><p><a href="image-20210109103007490.png" data-fancybox="group" data-caption="image-20210109103007490" class="fancybox"><img alt="image-20210109103007490" title="image-20210109103007490" data-src="image-20210109103007490.png" class="lazyload"></a></p><p>程序首先在用户空间执行，由于中断等进入内核处理，看未决信号集中信号是否可以递送，若产生并且抵达而且设置的是捕捉，内核会去调用信号处理函数（回调函数），回到用户区去执行函数内容，执行完后用系统调用sigreturn回到内核（回到主调函数），最后返回用户区往中断位置继续执行。</p><p><strong>注意：signal和sigaction都是用于注册信号捕捉函数，执行捕捉是由内核完成的。</strong></p><h2 id="竞态条件（时序竞态）"><a href="#竞态条件（时序竞态）" class="headerlink" title="竞态条件（时序竞态）"></a>竞态条件（时序竞态）</h2><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。</span><br><span class="line">   int pause(void);返回值：-1 并设置errno为EINTR</span><br><span class="line">返回值：</span><br><span class="line">1、如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。</span><br><span class="line">2、如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。</span><br><span class="line">3、如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】</span><br><span class="line">   errno设置为EINTR，表示“被信号中断”。想想我们还有哪个函数只有出错返回值。</span><br><span class="line">4、pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210109111424950.png" data-fancybox="group" data-caption="image-20210109111424950" class="fancybox"><img alt="image-20210109111424950" title="image-20210109111424950" data-src="image-20210109111424950.png" class="lazyload"></a></p><p>注意：返回-1表示成功返回</p><p><strong>练习</strong>：使用pause和alarm来实现sleep函数。  </p><p>注意，unslept = alarm(0)的用法。</p><p>例如：睡觉，alarm(10)闹铃。   </p><p>正常： 10后闹铃将我唤醒，这时额外设置alarm(0)取消闹铃，不会出错。</p><p>异常： 5分钟，被其他事物吵醒，alarm(0)取消闹铃防止打扰。</p><p>【mysleep.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* nothing to do */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    alarm(seconds); </span><br><span class="line">    pause();</span><br><span class="line"></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);<span class="comment">//防止在alarm记时未完成pause收到信号，用于结束闹钟并返回剩余时间</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复捕捉SIGALRM默认处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3 seconds later\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210109114647803.png" data-fancybox="group" data-caption="image-20210109114647803" class="fancybox"><img alt="image-20210109114647803" title="image-20210109114647803" data-src="image-20210109114647803.png" class="lazyload"></a></p><p>模拟sleep函数，提前在pause()即阻塞进程前设置一个alarm，然后注册SIGALRM的捕捉执行信号处理函数，之后进程被唤醒，继续执行接下来的程序，alarm(0)为了防止阻塞提前结束用于结束定时使用。</p><h3 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h3><h4 id="前导例"><a href="#前导例" class="headerlink" title="前导例"></a>前导例</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设想如下场景：</span><br><span class="line">欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。</span><br><span class="line">正常：定时，睡觉，10分钟后被闹钟唤醒。</span><br><span class="line">异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。</span><br></pre></td></tr></table></figure></div><p>在闹钟计时与pause()执行期间失去了cpu，但是闹钟依旧在计时，等计时完成后内核去调用信号处理函数之后再回到用户态去调用pause，但是SIGALRM已经处理完毕，pause就不会再收到信号唤醒了。</p><h4 id="时序问题分析"><a href="#时序问题分析" class="headerlink" title="时序问题分析"></a>时序问题分析</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">回顾，借助pause和alarm实现的mysleep函数。设想如下时序：</span><br><span class="line">1. 注册SIGALRM信号处理函数 （sigaction...)</span><br><span class="line">2. 调用alarm(1) 函数设定闹钟1秒。</span><br><span class="line">3. 函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。</span><br><span class="line">4. 1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</span><br><span class="line">5. 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。</span><br><span class="line">6. 信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒）</span><br><span class="line">7. SIGALRM信号已经处理完毕，pause不会等到。</span><br></pre></td></tr></table></figure></div><h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a>解决时序问题</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个“原子操作”。sigsuspend函数具备这个功能。在对时序要求严格的场合下都应该使用sigsuspend替换pause。 </span><br><span class="line">int sigsuspend(const sigset_t *mask);挂起等待信号。</span><br><span class="line">sigsuspend函数调用期间，进程信号屏蔽字由其参数mask指定。</span><br><span class="line">可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</span><br></pre></td></tr></table></figure></div><p>改进版mysleep</p><p>【sigsuspend.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>,<span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> newmask,oldmask,suspmask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">    </span><br><span class="line">    newact.sa_handler=sig_alrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags=<span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM,&amp;newact,&amp;oldact);</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask,SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);</span><br><span class="line">    </span><br><span class="line">    alarm(nsecs);</span><br><span class="line">    suspmask=oldmask;</span><br><span class="line">    sigdelset(&amp;suspmask,SIGALRM);</span><br><span class="line">    </span><br><span class="line">    sigsuspend(&amp;suspmask);</span><br><span class="line">    unslept=alarm(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oldmask,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3 seconds later\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210109213556136.png" data-fancybox="group" data-caption="image-20210109213556136" class="fancybox"><img alt="image-20210109213556136" title="image-20210109213556136" data-src="image-20210109213556136.png" class="lazyload"></a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</span><br><span class="line">  不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</span><br><span class="line">这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</span><br></pre></td></tr></table></figure></div><h3 id="全局变量异步I-O"><a href="#全局变量异步I-O" class="headerlink" title="全局变量异步I/O"></a>全局变量异步I/O</h3><p>分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因。</p><p>【sync_process.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child  %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am parent %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">"fork"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;     </span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        act.sa_handler = do_sig_parent;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);<span class="comment">//注册自己的信号捕捉函数  父使用SIGUSR2信号</span></span><br><span class="line">        do_sig_parent(<span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* wait for signal */</span>;</span><br><span class="line">           <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;                         <span class="comment">//父进程数数完成</span></span><br><span class="line">                kill(pid, SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;<span class="comment">//标志已经给子进程发送完信号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;       </span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* waiting for a signal */</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                kill(getppid(), SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210110163018339.png" data-fancybox="group" data-caption="image-20210110163018339" class="fancybox"><img alt="image-20210110163018339" title="image-20210110163018339" data-src="image-20210110163018339.png" class="lazyload"></a></p><p>将sleep去掉以后，父可能出现在kill命令后失去了cpu，子进程捕捉到信号后执行信号处理函数，之后子进程的flag=1，继续给父进程发送信号，父进行进行捕捉，如何执行父进程的信号处理函数flag=1，现在父进程抢到了cpu，flag=0，无法继续给子进程发送信号， 子进程给父进程的信号也早已发送完毕，故终止。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。</span><br><span class="line">问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</span><br><span class="line">如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。</span><br><span class="line">现阶段，我们在编程期间如若使用全局变量，应在主观上注意全局变量的异步IO可能造成的问题。</span><br></pre></td></tr></table></figure></div><h3 id="可-不可重入函数"><a href="#可-不可重入函数" class="headerlink" title="可/不可重入函数"></a>可/不可重入函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210110172138721.png" data-fancybox="group" data-caption="image-20210110172138721" class="fancybox"><img alt="image-20210110172138721" title="image-20210110172138721" data-src="image-20210110172138721.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是该函数内部实现使用了全局变量。</span><br></pre></td></tr></table></figure></div><p>由于本来调用两次insert应该新插入了两个节点，但是只有一个，故为不可重入函数，导致insert函数不可重入的原因是，insert还未执行完信号来了又去执行插入操作。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free</span><br><span class="line">2.信号捕捉函数应设计为可重入函数</span><br><span class="line">3.信号处理程序可以调用的可重入函数可参阅man 7 signal </span><br><span class="line">4.没有包含在上述列表中的函数大多是不可重入的，其原因为：</span><br><span class="line">a)使用静态数据结构</span><br><span class="line">b)调用了malloc或free</span><br><span class="line">c)是标准I&#x2F;O函数</span><br></pre></td></tr></table></figure></div><h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><h3 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a>SIGCHLD的产生条件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子进程终止时</span><br><span class="line">子进程接收到SIGSTOP信号停止时</span><br><span class="line">子进程处在停止态，接受到SIGCONT后唤醒时</span><br></pre></td></tr></table></figure></div><p>即在子进程状态发生变化时发出。</p><h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助SIGCHLD信号回收子进程</h3><p>​        子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p><p>【sigchild.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid=waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//非阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"----child %d exit %d\n"</span>,pid,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d cancel siganl %d\n"</span>,pid,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"chils id:%d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_handler=do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags=<span class="number">0</span>;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent ID:%d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210110201638958.png" data-fancybox="group" data-caption="image-20210110201638958" class="fancybox"><img alt="image-20210110201638958" title="image-20210110201638958" data-src="image-20210110201638958.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果每创建一个子进程后不使用sleep可以吗？可不可以将程序中，捕捉函数内部的while替换为if？为什么？ </span><br><span class="line">if ((pid &#x3D; waitpid(0, &amp;status, WNOHANG)) &gt; 0) &#123; ... &#125;</span><br><span class="line">思考：信号不支持排队，当正在执行SIGCHLD捕捉函数时，再过来一个或多个SIGCHLD信号怎么办？</span><br><span class="line">阻塞，只执行其中的一个。</span><br></pre></td></tr></table></figure></div><p>在回收子进程的过程中可能存在回收不完全，原因是：在捕捉到SIGCHLD信号后执行信号处理函数时，可能存在一次性发出好几个SIGCHLD信号，但是未决信号集只能记录有无该信号不能记录次数，所以只能随机回收其中一个子进程而忽略其他一起结束的子进程，可以进行如下修改，每次只触发回调函数一次，就while循环回收，直到没有未回收的僵尸进程为止；</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pid=waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//非阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----child %d exit %d\n"</span>,pid,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child %d cancel siganl %d\n"</span>,pid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中设置为非阻塞是因为，只有当子进程结束才会执行这个回调函数，所以不需要阻塞等待。</p><p>对于在子进程先于父进程设置信号捕捉前死亡，就无法对子进程进行回收从而产生僵尸进程，未捕捉时对SIGCHLD执行的默认处理动作为忽略，所以可以在注册捕捉函数前先将SIGCHLD阻塞，待注册完成后解除对SIGCHLD的阻塞。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sig_set <span class="built_in">set</span>;</span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler=do_sig_child;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags=<span class="number">0</span>;</span><br><span class="line">sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div><h3 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a>子进程结束status处理方式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function">options</span></span><br><span class="line"><span class="function">WNOHANG</span></span><br><span class="line">没有子进程结束，立即返回</span><br><span class="line">WUNTRACED</span><br><span class="line">如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</span><br><span class="line">WCONTINUED</span><br><span class="line">如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</span><br><span class="line">获取status</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">子进程正常<span class="built_in">exit</span>终止，返回真</span><br><span class="line">WEXITSTATUS(status)返回子进程正常退出值</span><br><span class="line">WIFSIGNALED(status)</span><br><span class="line">子进程被信号终止，返回真</span><br><span class="line">WTERMSIG(status)返回终止子进程的信号值</span><br><span class="line">WIFSTOPPED(status)</span><br><span class="line">子进程被停止，返回真</span><br><span class="line">WSTOPSIG(status)返回停止子进程的信号值</span><br><span class="line">WIFCONTINUED(status)</span><br></pre></td></tr></table></figure></div><h3 id="SIGCHLD信号注意问题"><a href="#SIGCHLD信号注意问题" class="headerlink" title="SIGCHLD信号注意问题"></a>SIGCHLD信号注意问题</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。</span><br><span class="line">2.注意注册信号捕捉函数的位置。</span><br><span class="line">3.应该在fork之前，阻塞SIGCHLD信号。注册完捕捉函数后解除阻塞。</span><br></pre></td></tr></table></figure></div><h2 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h2><h3 id="发送信号传参"><a href="#发送信号传参" class="headerlink" title="发送信号传参"></a>发送信号传参</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigqueue函数对应kill函数，但可在向指定进程发送信号的同时携带参数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">        <span class="keyword">union</span> sigval &#123;</span><br><span class="line">        <span class="keyword">int</span>   sival_int;</span><br><span class="line">        <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">        &#125;;</span><br><span class="line">向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义。</span><br></pre></td></tr></table></figure></div><h3 id="捕捉信号传参"><a href="#捕捉信号传参" class="headerlink" title="捕捉信号传参"></a>捕捉信号传参</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">               <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">               <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">               <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">               <span class="keyword">int</span>       sa_flags;</span><br><span class="line">               <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">           &#125;;</span><br><span class="line">当注册信号捕捉函数，希望获取更多信号相关信息，不应使用sa_handler而应该使用sa_sigaction。但此时的sa_flags必须指定为SA_SIGINFO。<span class="keyword">siginfo_t</span>是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。</span><br></pre></td></tr></table></figure></div><h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">系统调用可分为两类：慢速系统调用和其他系统调用。</span><br><span class="line">1.慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait...</span><br><span class="line">2.其他系统调用：getpid、getppid、fork...</span><br><span class="line">结合pause，回顾慢速系统调用：</span><br><span class="line">慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read</span><br><span class="line">1、想中断pause，信号不能被屏蔽。</span><br><span class="line">2、信号的处理方式必须是捕捉 (默认、忽略都不可以)</span><br><span class="line">3、中断后返回-1， 设置errno为EINTR(表“被信号中断”)</span><br><span class="line">可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。 SA_RESTART重启。</span><br><span class="line">扩展了解：</span><br><span class="line">sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</span><br></pre></td></tr></table></figure></div><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl-C表示SIGINT，Ctrl-\表示SIGQUIT。</span><br><span class="line">Alt + Ctrl + F1、F2、F3、F4、F5、F6字符终端   pts (pseudo terminal slave) 指伪终端。</span><br><span class="line">Alt + F7图形终端</span><br><span class="line">SSH、Telnet...网络终端</span><br></pre></td></tr></table></figure></div><p>终端是输入输出设备的统称，shell为虚拟终端，输入和输出都在上面完成。</p><h3 id="终端的启动流程"><a href="#终端的启动流程" class="headerlink" title="终端的启动流程"></a>终端的启动流程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件与I&#x2F;O中讲过，每个进程都可以通过一个特殊的设备文件&#x2F;dev&#x2F;tty访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，&#x2F;dev&#x2F;tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过&#x2F;dev&#x2F;tty也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</span><br><span class="line">简单来说，一个Linux系统启动，大致经历如下的步骤：</span><br><span class="line">init --&gt; fork --&gt; exec --&gt; getty --&gt; 用户输入帐号 --&gt; login --&gt; 输入密码 --&gt; exec --&gt; bash</span><br><span class="line">硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器，线路规程像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下Ctrl-z，对应的字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111092128226.png" data-fancybox="group" data-caption="image-20210111092128226" class="fancybox"><img alt="image-20210111092128226" title="image-20210111092128226" data-src="image-20210111092128226.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line disciline: 线路规程，用来过滤键盘输入的内容。</span><br></pre></td></tr></table></figure></div><p>通过ps ajx寻找控制终端</p><p><a href="image-20210111092546823.png" data-fancybox="group" data-caption="image-20210111092546823" class="fancybox"><img alt="image-20210111092546823" title="image-20210111092546823" data-src="image-20210111092546823.png" class="lazyload"></a></p><p><a href="image-20210111092716182.png" data-fancybox="group" data-caption="image-20210111092716182" class="fancybox"><img alt="image-20210111092716182" title="image-20210111092716182" data-src="image-20210111092716182.png" class="lazyload"></a></p><p><a href="image-20210111092751031.png" data-fancybox="group" data-caption="image-20210111092751031" class="fancybox"><img alt="image-20210111092751031" title="image-20210111092751031" data-src="image-20210111092751031.png" class="lazyload"></a></p><p><a href="image-20210111092845993.png" data-fancybox="group" data-caption="image-20210111092845993" class="fancybox"><img alt="image-20210111092845993" title="image-20210111092845993" data-src="image-20210111092845993.png" class="lazyload"></a></p><h3 id="ttyname函数"><a href="#ttyname函数" class="headerlink" title="ttyname函数"></a>ttyname函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">由文件描述符查出对应的文件名</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;成功：终端名；失败：<span class="literal">NULL</span>，设置errno</span><br><span class="line">下面我们借助ttyname函数，通过实验看一下各种不同的终端所对应的设备文件名。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 0: %s\n"</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 1: %s\n"</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 2: %s\n"</span>, ttyname(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="网络终端"><a href="#网络终端" class="headerlink" title="网络终端"></a>网络终端</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟终端或串口终端的数目是有限的，虚拟终端(字符控制终端)一般就是&#x2F;dev&#x2F;tty1∼&#x2F;dev&#x2F;tty6六个，串口终端的数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，这是通过伪终端（Pseudo TTY）实现的。一套伪终端由一个主设备（PTY Master）和一个从设备（PTY Slave）组成。主设备在概念上相当于键盘和显示器，只不过它不是真正的硬件而是一个内核模块，操作它的也不是用户而是另外一个进程。从设备和上面介绍的&#x2F;dev&#x2F;tty1这样的终端设备模块类似，只不过它的底层驱动程序不是访问硬件而是访问主设备。网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认为自己的控制终端是伪终端从设备，例如&#x2F;dev&#x2F;pts&#x2F;0、&#x2F;dev&#x2F;pts&#x2F;1等。下面以telnet为例说明网络登录和使用伪终端的过程。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111094714499.png" data-fancybox="group" data-caption="image-20210111094714499" class="fancybox"><img alt="image-20210111094714499" title="image-20210111094714499" data-src="image-20210111094714499.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP&#x2F;IP协议栈：在数据包上添加报头。</span><br><span class="line">如果telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒钟才能回显到屏幕上。这说明我们每按一个键telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet客户端，显示给用户看。也许你会觉得吃惊，但真的是这样：每按一个键都要在网络上走个来回！</span><br></pre></td></tr></table></figure></div><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><h3 id="概念和特性"><a href="#概念和特性" class="headerlink" title="概念和特性"></a>概念和特性</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</span><br><span class="line">当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID&#x3D;&#x3D;第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID&#x3D;&#x3D;其进程ID</span><br></pre></td></tr></table></figure></div><p>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。</p><p>【kill_multprocess.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out numchild\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">            sys_err(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;        <span class="comment">/* in child */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child pid = %d, groupid = %d\n"</span>, getpid(), getpgrp());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;      <span class="comment">/* in parent */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">pid_t</span> cpid;</span><br><span class="line">        <span class="keyword">while</span> ((cpid = wait(<span class="literal">NULL</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d is over\n"</span>, cpid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111100634874.png" data-fancybox="group" data-caption="image-20210111100634874" class="fancybox"><img alt="image-20210111100634874" title="image-20210111100634874" data-src="image-20210111100634874.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111100807080.png" data-fancybox="group" data-caption="image-20210111100807080" class="fancybox"><img alt="image-20210111100807080" title="image-20210111100807080" data-src="image-20210111100807080.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111100917198.png" data-fancybox="group" data-caption="image-20210111100917198" class="fancybox"><img alt="image-20210111100917198" title="image-20210111100917198" data-src="image-20210111100917198.png" class="lazyload"></a></p><p><a href="image-20210111100951543.png" data-fancybox="group" data-caption="image-20210111100951543" class="fancybox"><img alt="image-20210111100951543" title="image-20210111100951543" data-src="image-20210111100951543.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</span><br><span class="line">进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</span><br><span class="line">一个进程可以为自己或子进程设置进程组ID</span><br></pre></td></tr></table></figure></div><h3 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a>进程组操作函数</h3><h4 id="getpgrp函数"><a href="#getpgrp函数" class="headerlink" title="getpgrp函数"></a>getpgrp函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取当前进程的进程组ID</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>; 总是返回调用者的进程组ID</span><br></pre></td></tr></table></figure></div><h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a>getpgid函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取指定进程的进程组ID</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>; 成功：<span class="number">0</span>；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">如果pid = <span class="number">0</span>，那么该函数作用和getpgrp一样。</span><br><span class="line">    </span><br><span class="line">当设置pid=<span class="number">0</span>时，该函数作用与getpgrp相同</span><br></pre></td></tr></table></figure></div><h4 id="setpgid函数"><a href="#setpgid函数" class="headerlink" title="setpgid函数"></a>setpgid函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>; 成功：<span class="number">0</span>；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">将参<span class="number">1</span>对应的进程，加入参<span class="number">2</span>对应的进程组中。</span><br><span class="line">注意： </span><br><span class="line"><span class="number">1.</span> 如改变子进程为新的组，应fork后，exec前。 (因为exec后就不会再回来了)</span><br><span class="line"><span class="number">2.</span> 权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程</span><br></pre></td></tr></table></figure></div><p>setpgid()可以给自己设置进程组id。</p><p><strong>练习</strong>：修改子进程的进程组ID </p><p>【setpgid.c】</p><p>在子进程睡眠期间父进程修改子进程的进程组ID</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child PID=%d,child group ID=%d\n"</span>,getpid(),getpgid(<span class="number">0</span>));</span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----Group ID of child is changed to %d\n"</span>,getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        setpgid(pid,pid);<span class="comment">//子进程的组id为子进程id</span></span><br><span class="line">        sleep(<span class="number">13</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent PID = %d\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent's parentd process PID=%d\n"</span>,getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent Group ID=%d\n"</span>,getpgid(<span class="number">0</span>));</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//改变父进程所属进程组ID为其父进程ID</span></span><br><span class="line">        setpgid(getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n-----Group ID of parent id changed to %d\n"</span>,getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111104026447.png" data-fancybox="group" data-caption="image-20210111104026447" class="fancybox"><img alt="image-20210111104026447" title="image-20210111104026447" data-src="image-20210111104026447.png" class="lazyload"></a></p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建一个会话需要注意以下6点注意事项：</span><br><span class="line">1.调用进程不能是进程组组长，该进程变成新会话首进程(session header)</span><br><span class="line">2.该进程成为一个新进程组的组长进程。</span><br><span class="line">3.需有root权限(ubuntu不需要)</span><br><span class="line">4.新会话丢弃原有的控制终端，该会话没有控制终端</span><br><span class="line">5.该调用进程是组长进程，则出错返回</span><br><span class="line">6.建立新会话时，先调用fork, 父进程终止，子进程调用setsid</span><br></pre></td></tr></table></figure></div><h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取进程所属的会话ID</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>; 成功：返回调用进程的会话ID；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">pid为<span class="number">0</span>表示察看当前进程session ID</span><br><span class="line">ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</span><br><span class="line">组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</span><br></pre></td></tr></table></figure></div><h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  成功：返回调用进程的会话ID；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br></pre></td></tr></table></figure></div><p>练习：fork一个子进程，并使其创建一个新会话。查看进程组ID、会话ID前后变化 </p><p>【session.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process PID is %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Group ID of child is %d\n"</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Session ID of child is %d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        setsid();       <span class="comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Changed:\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process PID is %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Group ID of child is %d\n"</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Session ID of child is %d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111110355518.png" data-fancybox="group" data-caption="image-20210111110355518" class="fancybox"><img alt="image-20210111110355518" title="image-20210111110355518" data-src="image-20210111110355518.png" class="lazyload"></a></p><p>将非组长进程设置新会话，子进程既是组长又是会长。之前进程的组长并不是bash，当创建出来后就自立门户改变了自己的进程组id。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</span><br><span class="line">Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</span><br><span class="line">   创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</span><br></pre></td></tr></table></figure></div><h3 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.创建子进程，父进程退出</span><br><span class="line">所有工作在子进程中进行形式上脱离了控制终端</span><br><span class="line">2.在子进程中创建新会话</span><br><span class="line">　　setsid()函数</span><br><span class="line">　　使子进程完全独立出来，脱离控制</span><br><span class="line">3.改变当前目录为根目录</span><br><span class="line">　　chdir()函数</span><br><span class="line">　　防止占用可卸载的文件系统</span><br><span class="line">　　也可以换成其它路径</span><br><span class="line">4.重设文件权限掩码</span><br><span class="line">　　umask()函数</span><br><span class="line">　　防止继承的文件创建屏蔽字拒绝某些权限</span><br><span class="line">　　增加守护进程灵活性</span><br><span class="line">5.关闭文件描述符</span><br><span class="line">　　 继承的打开文件不会用到，浪费系统资源，无法卸载</span><br><span class="line">6.开始执行守护进程核心工作</span><br><span class="line">7.守护进程退出处理程序模型</span><br></pre></td></tr></table></figure></div><p>【mydaemond.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mydaemond</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pit_t</span> pid,sid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sid=setsid();<span class="comment">//创建新会话,脱离控制终端</span></span><br><span class="line">        <span class="keyword">int</span> ret=chdir(<span class="string">"/home/yujiao"</span>);<span class="comment">//设置当前目录</span></span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"chdir() err"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        umask(<span class="number">0022</span>);</span><br><span class="line">        <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">        <span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">        dup2(<span class="number">0</span>,STDOUT_FILENO);</span><br><span class="line">        dup2(<span class="number">0</span>,STDERR_FILENO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mydaemond();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111115941066.png" data-fancybox="group" data-caption="image-20210111115941066" class="fancybox"><img alt="image-20210111115941066" title="image-20210111115941066" data-src="image-20210111115941066.png" class="lazyload"></a></p><p>后续学习进程需安装</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装线程man page，命令：sudo apt-get install manpages-posix-dev</span><br><span class="line">安装完成，使用man -k pthread如能看到线程函数列表则表明安装成功。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210111114739244.png" data-fancybox="group" data-caption="image-20210111114739244" class="fancybox"><img alt="image-20210111114739244" title="image-20210111114739244" data-src="image-20210111114739244.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信号的概念&quot;&gt;&lt;a href=&quot;#信号的概念&quot; class=&quot;headerlink&quot; title=&quot;信号的概念&quot;&gt;&lt;/a&gt;信号的概念&lt;/h2&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发二-系统编程/Day2/Day2</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day2/Day2/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day2/Day2/</id>
    <published>2021-01-30T07:20:26.027Z</published>
    <updated>2021-01-05T14:02:28.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IPC方法"><a href="#IPC方法" class="headerlink" title="IPC方法"></a>IPC方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230161241791.png" data-fancybox="group" data-caption="image-20201230161241791" class="fancybox"><img alt="image-20201230161241791" title="image-20201230161241791" data-src="image-20201230161241791.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：</span><br><span class="line">1、管道 (使用最简单)</span><br><span class="line">2、信号 (开销最小)</span><br><span class="line">   3、共享映射区 (无血缘关系)</span><br><span class="line">4、本地套接字 (最稳定)</span><br></pre></td></tr></table></figure></div><p>为什么要进程间通信？</p><p><a href="image-20201230162308789.png" data-fancybox="group" data-caption="image-20201230162308789" class="fancybox"><img alt="image-20201230162308789" title="image-20201230162308789" data-src="image-20201230162308789.png" class="lazyload"></a></p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</span><br><span class="line">1. 其本质是一个伪文件(实为内核缓冲区) </span><br><span class="line">2. 由两个文件描述符引用，一个表示读端，一个表示写端。</span><br><span class="line">3. 规定数据从管道的写端流入管道，从读端流出。</span><br><span class="line">管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</span><br><span class="line">管道的局限性：</span><br><span class="line">   1、数据自己读不能自己写。</span><br><span class="line">   2、数据一旦被读走，便不在管道中存在，不可反复读取。</span><br><span class="line">   3、由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。</span><br><span class="line">   4、只能在有公共祖先的进程间使用管道。</span><br><span class="line">常见的通信方式有，单工通信、半双工通信、全双工通信。</span><br></pre></td></tr></table></figure></div><p><strong>原理</strong>：内核缓冲区和环形队列</p><h3 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建管道</span><br><span class="line">    int pipe(int pipefd[2]);成功：0；失败：-1，设置errno</span><br><span class="line">函数调用成功返回r&#x2F;w两个文件描述符。无需open，但需手动close。规定：fd[0] → r； fd[1] → w，就像0对应标准输入，1对应标准输出一样。向管道文件读写数据其实是在读写内核缓冲区。</span><br><span class="line">管道创建成功以后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。如何实现父子进程间通信呢？通常可以采用如下步骤：</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230223336844.png" data-fancybox="group" data-caption="image-20201230223336844" class="fancybox"><img alt="image-20201230223336844" title="image-20201230223336844" data-src="image-20201230223336844.png" class="lazyload"></a></p><p><a href="image-20201230224237341.png" data-fancybox="group" data-caption="image-20201230224237341" class="fancybox"><img alt="image-20201230224237341" title="image-20201230224237341" data-src="image-20201230224237341.png" class="lazyload"></a></p><p>a.out和子进程都控制着管道的两端，即可读又可写，为了保证管道的单向流动性，假如子进程读，则关闭子进程的写端，关闭父进程的读端即可。</p><p><a href="image-20201230223057645.png" data-fancybox="group" data-caption="image-20201230223057645" class="fancybox"><img alt="image-20201230223057645" title="image-20201230223057645" data-src="image-20201230223057645.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]指向管道的读端和写端。</span><br><span class="line">2. 父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。</span><br><span class="line">3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。</span><br></pre></td></tr></table></figure></div><p><strong>练习</strong>：父子进程使用管道通信，父写入字符串，子进程读出并，打印到屏幕。                        </p><p>【pipe.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> ret=pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//子进程读数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        ret=<span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-----\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO,buf,ret);<span class="comment">//打印输出到屏幕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello child\n"</span>,<span class="keyword">sizeof</span>(<span class="string">"hello child\n"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210103172226521.png" data-fancybox="group" data-caption="image-20210103172226521" class="fancybox"><img alt="image-20210103172226521" title="image-20210103172226521" data-src="image-20210103172226521.png" class="lazyload"></a></p><p><strong>思考</strong>：为甚么，程序中没有使用sleep函数，但依然能保证子进程运行时一定会读到数据呢？</p><p>不是应该让子进程等一下再读保证父进程写了吗？当管道中没有数据，但是写端被父进程占用没有关闭，故阻塞等待；详细解释如下管道读写行为所示。</p><h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用管道需要注意以下4种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：</span><br><span class="line">1. 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。</span><br><span class="line">2. 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。</span><br><span class="line">3. 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。</span><br><span class="line">4. 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</span><br></pre></td></tr></table></figure></div><p><strong>总结</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、读管道：1. 管道中有数据，read返回实际读到的字节数。</span><br><span class="line">   2. 管道中无数据：</span><br><span class="line">(1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)</span><br><span class="line">(2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</span><br><span class="line">2、写管道：1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)</span><br><span class="line">   2. 管道读端没有全部关闭： </span><br><span class="line">(1) 管道已满，write阻塞。</span><br><span class="line">(2) 管道未满，write将数据写入，并返回实际写入的字节数。</span><br></pre></td></tr></table></figure></div><p><strong>练习</strong>：使用管道实现父子进程间通信，完成：ls | wc –l。假定父进程实现ls，子进程实现wc。</p><p>（ls命令正常会将结果集写出到stdout，但现在会写入管道的写端；wc –l 正常应该从stdin读取数据，但此时会从管道的读端读。）</p><p>【pipe1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(fd);</span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">//child</span></span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">1</span>]);                <span class="comment">//子进程从管道中读数据，关闭写端</span></span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO);<span class="comment">//让wc从管道中读取数据</span></span><br><span class="line">execlp(<span class="string">"wc"</span>, <span class="string">"wc"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);<span class="comment">//wc命令默认从标准读入取数据</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//父进程向管道中写数据，关闭读端</span></span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO);<span class="comment">//将ls的结果写入管道中</span></span><br><span class="line">execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);<span class="comment">//ls输出结果默认对应屏幕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  程序不时的会出现先打印$提示符，再出程序运行结果的现象。</span></span><br><span class="line"><span class="comment"> *  这是因为：父进程执行ls命令，将输出结果给通过管道传递给</span></span><br><span class="line"><span class="comment"> *  子进程去执行wc命令，这时父进程若先于子进程打印wc运行结果</span></span><br><span class="line"><span class="comment"> *  之前被shell使用wait函数成功回收，shell就会先于子进程打印</span></span><br><span class="line"><span class="comment"> *  wc运行结果之前打印$提示符。</span></span><br><span class="line"><span class="comment"> *  解决方法：让子进程执行ls,父进程执行wc命令。或者在兄弟进程间完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div><p><a href="image-20210104101236784.png" data-fancybox="group" data-caption="image-20210104101236784" class="fancybox"><img alt="image-20210104101236784" title="image-20210104101236784" data-src="image-20210104101236784.png" class="lazyload"></a></p><p>如图，程序执行结果与命令执行结果一致，首先父进程执行ls不把结果输出到屏幕而是输出到管道的写端fd[1]，之后子进程也不在输入读取数据，而是在管道的读端读取数据即fd[0]，这两处需要借助dup2进行重定向，可见结果中bash抢占的终端，是因为子进程要等父进程写了才读，所以父进程结束了bash就来抢占终端，解决方法可以调换父子进程的读写顺序，让子进程写，父进程读即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序执行，发现程序执行结束，shell还在阻塞等待用户输入。这是因为，shell → fork → .&#x2F;pipe1， 程序pipe1的子进程将stdin重定向给管道，父进程执行的ls会将结果集通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符。</span><br></pre></td></tr></table></figure></div><p><strong>练习</strong>：使用管道实现兄弟进程间通信。 兄：ls 弟： wc -l 父：等待回收子进程。</p><p>要求，使用“循环创建N个子进程”模型创建兄弟进程，使用循环因子i标示。注意管道读写行为。</p><p>【pipe2.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>], i;</span><br><span class="line"></span><br><span class="line">pipe(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;<span class="comment">//兄</span></span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">0</span>]);<span class="comment">//写,关闭读端</span></span><br><span class="line">dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">execlp(<span class="string">"ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;<span class="comment">//弟</span></span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">1</span>]);<span class="comment">//读，关闭写端</span></span><br><span class="line">dup2(fd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">execlp(<span class="string">"wc"</span>, <span class="string">"wc"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)<span class="comment">//两个儿子wait两次</span></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104104008520.png" data-fancybox="group" data-caption="image-20210104104008520" class="fancybox"><img alt="image-20210104104008520" title="image-20210104104008520" data-src="image-20210104104008520.png" class="lazyload"></a></p><p><a href="image-20210104103837258.png" data-fancybox="group" data-caption="image-20210104103837258" class="fancybox"><img alt="image-20210104103837258" title="image-20210104103837258" data-src="image-20210104103837258.png" class="lazyload"></a></p><p>注意：要记得关闭父进行的读端和写端否则管道无法单向流动。</p><p><strong>测试</strong>：是否允许，一个pipe有一个写端，多个读端呢？是否允许有一个读端多个写端呢？</p><p>【pipe3_1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>], i, n;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">"pipe error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">write</span>(fd[<span class="number">1</span>], <span class="string">"1.hello\n"</span>, <span class="built_in">strlen</span>(<span class="string">"1.hello\n"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">write</span>(fd[<span class="number">1</span>], <span class="string">"2.world\n"</span>, <span class="built_in">strlen</span>(<span class="string">"2.world\n"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(fd[<span class="number">1</span>]);       <span class="comment">//父进程关闭写端,留读端读取数据    </span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="number">1024</span>);     <span class="comment">//从管道中读数据</span></span><br><span class="line"><span class="built_in">write</span>(STDOUT_FILENO, buf, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)<span class="comment">//两个儿子wait两次</span></span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104105549463.png" data-fancybox="group" data-caption="image-20210104105549463" class="fancybox"><img alt="image-20210104105549463" title="image-20210104105549463" data-src="image-20210104105549463.png" class="lazyload"></a></p><p>如图，两个兄弟进程进行写操作，父进程进行读操作，父进程sleep的目的是为了等两个子进程写完后再读，所以可以存在多个写端一个读端。</p><h3 id="管道缓冲区大小"><a href="#管道缓冲区大小" class="headerlink" title="管道缓冲区大小"></a>管道缓冲区大小</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">也可以使用fpathconf函数，借助参数选项来查看。使用该宏应引入头文件&lt;unistd.h&gt;</span><br><span class="line">long fpathconf(int fd, int name);成功：返回管道的大小失败：-1，设置errno</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104113703924.png" data-fancybox="group" data-caption="image-20210104113703924" class="fancybox"><img alt="image-20210104113703924" title="image-20210104113703924" data-src="image-20210104113703924.png" class="lazyload"></a></p><h3 id="管道的优劣"><a href="#管道的优劣" class="headerlink" title="管道的优劣"></a>管道的优劣</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：简单，相比信号，套接字实现进程间通信，简单很多。</span><br><span class="line">缺点：1. 只能单向通信，双向通信需建立两个管道。</span><br><span class="line"> 2. 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。</span><br></pre></td></tr></table></figure></div><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。</span><br><span class="line">FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核通道，这样就实现了进程间通信。</span><br><span class="line">创建方式：</span><br><span class="line">1. 命令：mkfifo 管道名</span><br><span class="line">2. 库函数：int mkfifo(const char *pathname,  mode_t mode);  成功：0； 失败：-1</span><br><span class="line">一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。</span><br></pre></td></tr></table></figure></div><p>1、命令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令行方式创建一个fifo：</span><br><span class="line">mkfifo myfifo</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104145230574.png" data-fancybox="group" data-caption="image-20210104145230574" class="fancybox"><img alt="image-20210104145230574" title="image-20210104145230574" data-src="image-20210104145230574.png" class="lazyload"></a></p><p>2、库函数</p><p><a href="image-20210104145847773.png" data-fancybox="group" data-caption="image-20210104145847773" class="fancybox"><img alt="image-20210104145847773" title="image-20210104145847773" data-src="image-20210104145847773.png" class="lazyload"></a></p><p>【用函数创建一个fifo】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=mkfifo(<span class="string">"mytestfifo"</span>,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mkfifo() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104160420007.png" data-fancybox="group" data-caption="image-20210104160420007" class="fancybox"><img alt="image-20210104160420007" title="image-20210104160420007" data-src="image-20210104160420007.png" class="lazyload"></a></p><p>fifo如何进行进程间通信？</p><p><a href="image-20210104160850694.png" data-fancybox="group" data-caption="image-20210104160850694" class="fancybox"><img alt="image-20210104160850694" title="image-20210104160850694" data-src="image-20210104160850694.png" class="lazyload"></a></p><p>靠的是文件进行读写操作，一个以读方式打开，另一个就以写的方式打开。</p><p>【fifo_w.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter like this: ./a.out fifoname\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"hello itcast %d\n"</span>, i++);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>【fifo_r.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out fifoname\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line">        sleep(<span class="number">1</span>);           <span class="comment">//多個读端时应增加睡眠秒数,放大效果.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104172649582.png" data-fancybox="group" data-caption="image-20210104172649582" class="fancybox"><img alt="image-20210104172649582" title="image-20210104172649582" data-src="image-20210104172649582.png" class="lazyload"></a></p><p>如图，同时打开两个bash，同时执行fifo_r和fifo_w，一个写，一个从fifo中读并打印到屏幕上。</p><p><strong>测试1</strong>：实现多输入单输出。</p><p>执行两个fifo_w.c以及一个fifo_r.c</p><p><a href="image-20210104185719273.png" data-fancybox="group" data-caption="image-20210104185719273" class="fancybox"><img alt="image-20210104185719273" title="image-20210104185719273" data-src="image-20210104185719273.png" class="lazyload"></a></p><p>如图可知，每次读出两句话，分别是第一个写进程和第二个写进程的。</p><p><strong>测试2</strong>：实现多输出单输入。</p><p>执行两个fifo_r.c以及一个fifo_w.c</p><p><a href="image-20210104191251220.png" data-fancybox="group" data-caption="image-20210104191251220" class="fancybox"><img alt="image-20210104191251220" title="image-20210104191251220" data-src="image-20210104191251220.png" class="lazyload"></a></p><h2 id="共享映射存储"><a href="#共享映射存储" class="headerlink" title="共享映射存储"></a>共享映射存储</h2><h3 id="文件进程间通信"><a href="#文件进程间通信" class="headerlink" title="文件进程间通信"></a>文件进程间通信</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用文件也可以完成IPC，理论依据是，fork后，父子进程共享文件描述符。也就共享打开的文件。</span><br></pre></td></tr></table></figure></div><p><strong>练习</strong>：编程测试，父子进程共享打开的文件。借助文件进行进程间通信。</p><p>1、在有血缘关系的文件进程间通信</p><p>【fork_shared_fd.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1,fd2;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *str=<span class="string">"-------test for shared fd in parent child process----\n"</span>;</span><br><span class="line">    </span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd1=<span class="built_in">open</span>(<span class="string">"test.txt"</span>,O_RDWR);</span><br><span class="line">        <span class="keyword">if</span>(fd1==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">write</span>(fd1,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child wrote over..\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fd2=<span class="built_in">open</span>(<span class="string">"test.txt"</span>,O_RDWR);</span><br><span class="line">        <span class="keyword">if</span>(fd2&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"open() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">read</span>(fd2,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------parent read len = %d\n"</span>,len);</span><br><span class="line">        len=<span class="built_in">write</span>(STDOUT_FILENO,buf,len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"--------parent write len = %d\n"</span>,len);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104223144525.png" data-fancybox="group" data-caption="image-20210104223144525" class="fancybox"><img alt="image-20210104223144525" title="image-20210104223144525" data-src="image-20210104223144525.png" class="lazyload"></a></p><p><strong>思考</strong>：无血缘关系的进程可以打开同一个文件进行通信吗？为什么？</p><p>yes</p><p>2、在无血缘关系的进程间通信</p><p>【test1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *str=<span class="string">"-------success----\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd= <span class="built_in">open</span>(<span class="string">"test.txt"</span>,O_RDWR|O_TRUNC|O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">write</span>(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test1 write into test.txt finish..\n"</span>);</span><br><span class="line">    sleep(N);</span><br><span class="line">    </span><br><span class="line">    lseek(fd,<span class="number">0</span>,SEEK_SET);<span class="comment">//将文件指针移动到起始位置</span></span><br><span class="line">    ret=<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    ret=<span class="built_in">write</span>(STDOUT_FILENO,buf,ret);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"wrie second error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>【test2.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> *str=<span class="string">"-------test2 write success----\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    sleep(<span class="number">2</span>);<span class="comment">//保证test1写入完成</span></span><br><span class="line">    <span class="keyword">int</span> fd=<span class="built_in">open</span>(<span class="string">"test.txt"</span>,O_RDWR);</span><br><span class="line">    ret=<span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">write</span>(fd,str,<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test2 read/write finish\n"</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104224658463.png" data-fancybox="group" data-caption="image-20210104224658463" class="fancybox"><img alt="image-20210104224658463" title="image-20210104224658463" data-src="image-20210104224658463.png" class="lazyload"></a></p><h3 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储映射I&#x2F;O (Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不适用read和write函数的情况下，使用地址（指针）完成I&#x2F;O操作。</span><br><span class="line">使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210104225320720.png" data-fancybox="group" data-caption="image-20210104225320720" class="fancybox"><img alt="image-20210104225320720" title="image-20210104225320720" data-src="image-20210104225320720.png" class="lazyload"></a></p><h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset); </span><br><span class="line">返回：成功：返回创建的映射区首地址；失败：MAP_FAILED宏</span><br><span class="line">参数：</span><br><span class="line">addr: 建立映射区的首地址，由Linux内核指定。使用时，直接传递NULL</span><br><span class="line">length： 欲创建映射区的大小</span><br><span class="line">prot：映射区权限PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE</span><br><span class="line">flags：标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)</span><br><span class="line">   MAP_SHARED:  会将映射区所做的操作反映到物理设备（磁盘）上。</span><br><span class="line">   MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。</span><br><span class="line">fd： 用来建立映射区的文件描述符</span><br><span class="line">offset： 映射文件的偏移(4k的整数倍)</span><br></pre></td></tr></table></figure></div><h4 id="munmap函数"><a href="#munmap函数" class="headerlink" title="munmap函数"></a>munmap函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同malloc函数申请内存空间类似的，mmap建立的映射区在使用结束后也应调用类似free的函数来释放。</span><br><span class="line">int munmap(void *addr, size_t length);成功：0； 失败：-1</span><br></pre></td></tr></table></figure></div><p>【mmap_test.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len,ret;</span><br><span class="line">    <span class="keyword">int</span> fd=<span class="built_in">open</span>(<span class="string">"mytest.txt,O_CREAT|O_RDWR"</span>,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    len=ftruncate(fd,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftruncate"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p=mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_WRITE|PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"abc\n"</span>);</span><br><span class="line">    ret=munmap(p,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"munmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105114138678.png" data-fancybox="group" data-caption="image-20210105114138678" class="fancybox"><img alt="image-20210105114138678" title="image-20210105114138678" data-src="image-20210105114138678.png" class="lazyload"></a></p><p>如图，程序成功通过指针的方式往映射区输入，反应到磁盘文件上显示。</p><h4 id="mmap注意事项"><a href="#mmap注意事项" class="headerlink" title="mmap注意事项"></a>mmap注意事项</h4><p><strong>思考</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0. 可以open的时候O_CREAT一个新文件来创建映射区吗?</span><br><span class="line">不能，如下图可见执行报错，映射区大小不能为0，必须要有实际的大小，但是malloc可以创建大小为0的内存。</span><br></pre></td></tr></table></figure></div><p>【test1.c】</p><p>将ftruncate去除，使得文件大小为0</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len,ret;</span><br><span class="line">    <span class="keyword">int</span> fd=<span class="built_in">open</span>(<span class="string">"mytest.txt,O_CREAT|O_RDWR"</span>,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p=mmap(<span class="literal">NULL</span>,<span class="number">0</span>,PROT_WRITE|PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"mmap()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"abc\n"</span>);</span><br><span class="line">    ret=munmap(p,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"munmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105114820245.png" data-fancybox="group" data-caption="image-20210105114820245" class="fancybox"><img alt="image-20210105114820245" title="image-20210105114820245" data-src="image-20210105114820245.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果mem++，munmap可否成功？</span><br><span class="line">不能，munmap中传递的为映射区的首地址以及大小，进行++后就不是首地址了。</span><br><span class="line">创建映射区的地址和释放映射区的地址要一致</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2. 如果open时O_RDONLY, mmap时PROT参数指定PROT_READ|PROT_WRITE会怎样？</span><br><span class="line">不能，文件以只读方式打开，无法对映射区又执行读又执行写操作，提示错误信息：权限不足。</span><br><span class="line">结论：</span><br><span class="line">1、映射区的权限应该小于等于打开文件的权限</span><br><span class="line">2、创建映射区的过程中隐含着对文件的读操作</span><br><span class="line"></span><br><span class="line">段错误检查：gbd时直接run就会停留在发生段错误的语句上</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3. 文件描述符先关闭，对mmap映射有没有影响？</span><br><span class="line">没有影响</span><br><span class="line">文件描述符也就是操作文件的句柄，mmap映射区对于文件的操作本质发生了改变并不需要句柄，所以可以关闭；</span><br><span class="line">fd仅在创建映射区时有用，后续没意义，可以关闭</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. 如果文件偏移量为1000会怎样？</span><br><span class="line">执行报错，invalid，偏移量必须是4096的整数倍</span><br><span class="line">映射区由mmu创建，单位就是4k</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5. 对mem越界操作会怎样？</span><br><span class="line">不能</span><br><span class="line">创建映射区的地址和释放映射区的地址要一致</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6. mmap什么情况下会调用失败？</span><br><span class="line">空间为0，映射区大小&gt;&#x3D;文件大小，指针的越界(mmet++)，</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7. 如果不检测mmap的返回值，会怎样？</span><br><span class="line">会发生很多错误</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">总结：使用mmap时务必注意以下事项：</span><br><span class="line">1.创建映射区的过程中，隐含着一次对映射文件的读操作。</span><br><span class="line">2.当MAP_SHARED时，要求：映射区的权限应 &lt;&#x3D;文件打开的权限(出于对映射区的保护)。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</span><br><span class="line">3.映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。</span><br><span class="line">4.特别注意，当映射文件大小为0时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！mmap使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。</span><br><span class="line">5.munmap传入的地址一定是mmap的返回地址。坚决杜绝指针++操作。</span><br><span class="line">6.如果文件偏移量必须为4K的整数倍</span><br><span class="line">7.mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</span><br></pre></td></tr></table></figure></div><h3 id="mmap父子进程通信"><a href="#mmap父子进程通信" class="headerlink" title="mmap父子进程通信"></a>mmap父子进程通信</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：</span><br><span class="line">MAP_PRIVATE:  (私有映射)  父子进程各自独占映射区；</span><br><span class="line">MAP_SHARED:  (共享映射)  父子进程共享映射区；</span><br></pre></td></tr></table></figure></div><p><strong>练习</strong>：父进程创建映射区，然后fork子进程，子进程修改映射区内容，而后，父进程读取映射区内容，查验是否共享。                                                                                            </p><p>【fork_mmap.c】–shared</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"temp"</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unlink(<span class="string">"temp"</span>);<span class="comment">//删除临时文件目录项,使之具备被释放条件.</span></span><br><span class="line">    ftruncate(fd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">//映射区建立完毕,即可关闭文件</span></span><br><span class="line"></span><br><span class="line">    pid = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        *p = <span class="number">2000</span>;</span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>, *p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105174418020.png" data-fancybox="group" data-caption="image-20210105174418020" class="fancybox"><img alt="image-20210105174418020" title="image-20210105174418020" data-src="image-20210105174418020.png" class="lazyload"></a></p><p>如图，子进程在执行期间往映射区写了一个2000，之后父进程对*p进行打印输出，然而var这个全局变量，父进程与子进程不共享，故在子进程中对var进行修改不影响父进程中的var，故还是100。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105174428852.png" data-fancybox="group" data-caption="image-20210105174428852" class="fancybox"><img alt="image-20210105174428852" title="image-20210105174428852" data-src="image-20210105174428852.png" class="lazyload"></a></p><p>由于是private，映射区各自独占，所以parent获取*p是值随机。</p><p>结论：<strong>父子进程共享：</strong>1. 打开的文件 2. mmap建立的映射区(但必须要使用MAP_SHARED)</p><p>几个知识点：</p><p><a href="09_%E7%9B%AE%E5%BD%95%E9%A1%B9.png" data-fancybox="group" data-caption="09_目录项" class="fancybox"><img alt="09_目录项" title="09_目录项" data-src="09_%E7%9B%AE%E5%BD%95%E9%A1%B9.png" class="lazyload"></a></p><p>每个denty项（创建硬链接时就增加一个denty项）中包含文件名和inode编号，通过inode号可以找到inode属性，其中包含文件大小权限等信息，其中的存储指针地址指向磁盘空间。</p><h3 id="匿名映射"><a href="#匿名映射" class="headerlink" title="匿名映射"></a>匿名映射</h3><p>通过之前的程序发现，对于temp这个文件仅仅在创建映射区时有用，其余没有存在意义，故考虑是否有其他方式能创建映射区。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程间通信也较容易。但缺陷是，每次创建映射区一定要依赖一个文件才能实现。通常为了建立映射区要open一个temp文件，创建好了再unlink、close掉，比较麻烦。 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。</span><br><span class="line">使用MAP_ANONYMOUS (或MAP_ANON)， 如: </span><br><span class="line">int *p &#x3D; mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); </span><br><span class="line">    &quot;4&quot;随意举例，该位置表大小，可依实际需要填写。</span><br><span class="line">需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。</span><br><span class="line">1、fd &#x3D; open(&quot;&#x2F;dev&#x2F;zero&quot;, O_RDWR);</span><br><span class="line">2、p &#x3D; mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</span><br></pre></td></tr></table></figure></div><p>【anon_linux.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        *p = <span class="number">2000</span>;</span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>, *p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105183245271.png" data-fancybox="group" data-caption="image-20210105183245271" class="fancybox"><img alt="image-20210105183245271" title="image-20210105183245271" data-src="image-20210105183245271.png" class="lazyload"></a></p><p><strong>unix一些相关历史</strong></p><p><a href="03_unix%E7%AE%80%E8%BF%B0.png" data-fancybox="group" data-caption="03_unix简述" class="fancybox"><img alt="03_unix简述" title="03_unix简述" data-src="03_unix%E7%AE%80%E8%BF%B0.png" class="lazyload"></a></p><p>注意：unix由肯汤姆森创建，c语言由丹尼斯里奇创建，商用和Linux都被称为类unix，MAP_ANON这个宏只在Linux中有，其他系统没有，通用的匿名映射创建方式如下：</p><p>利用在dev/zero进行映射的创建，映射区大小可以随意创建</p><p>【anon.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd=<span class="built_in">open</span>(<span class="string">"/dev/zero"</span>,O_RDWR);</span><br><span class="line">    p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">400</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">"mmap error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        *p = <span class="number">2000</span>;</span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, *p = %d, var = %d\n"</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, *p = %d, var = %d\n"</span>, *p, var);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"munmap error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105193756044.png" data-fancybox="group" data-caption="image-20210105193756044" class="fancybox"><img alt="image-20210105193756044" title="image-20210105193756044" data-src="image-20210105193756044.png" class="lazyload"></a></p><p>如图结果与用MAP_ANON效果一样。</p><h3 id="mmap无血缘关系进程间通信"><a href="#mmap无血缘关系进程间通信" class="headerlink" title="mmap无血缘关系进程间通信"></a>mmap无血缘关系进程间通信</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实质上mmap是内核借助文件帮我们创建了一个映射区，多个进程之间利用该映射区完成数据传递。由于内核空间多进程共享，因此无血缘关系的进程间也可以使用mmap来完成通信。只要设置相应的标志位参数flags即可。若想实现共享，当然应该使用MAP_SHARED了。</span><br></pre></td></tr></table></figure></div><p>【mmp_w.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span> = &#123;</span><span class="number">10</span>, <span class="string">"xiaoming"</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    ftruncate(fd, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">        sys_err(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(mm, &amp;student, <span class="keyword">sizeof</span>(student));</span><br><span class="line">        student.id++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>【mmp_r.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STU</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">STU</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out file_shared\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">    mm = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(student), PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mm == MAP_FAILED)</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"id=%d\tname=%s\t%c\n"</span>, mm-&gt;id, mm-&gt;name, mm-&gt;sex);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(mm, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105203505331.png" data-fancybox="group" data-caption="image-20210105203505331" class="fancybox"><img alt="image-20210105203505331" title="image-20210105203505331" data-src="image-20210105203505331.png" class="lazyload"></a></p><h2 id="Linux系统编程-简单shell大练习"><a href="#Linux系统编程-简单shell大练习" class="headerlink" title="Linux系统编程-简单shell大练习"></a>Linux系统编程-简单shell大练习</h2><h3 id="阶段综合练习一"><a href="#阶段综合练习一" class="headerlink" title="阶段综合练习一"></a>阶段综合练习一</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现文件多进程拷贝。</span><br><span class="line">假设有一个超大文件，需对其完成拷贝工作。为提高效率，可采用多进程并行拷贝的方法来实现。假设文件大小为len，共有n个进程对该文件进行拷贝。那每个进程拷贝的字节数应为len&#x2F;n。但未必一定能整除，我们可以选择让最后一个进程负责剩余部分拷贝工作。可使用len % (len&#x2F;n)将剩余部分大小求出。</span><br><span class="line">为降低实现复杂度，可选用mmap来实现源、目标文件的映射，通过指针操作内存地址，设置每个进程拷贝的起始、结束位置。借助MAP_SHARED选项将内存中所做的修改反映到物理磁盘上。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105205123749.png" data-fancybox="group" data-caption="image-20210105205123749" class="fancybox"><img alt="image-20210105205123749" title="image-20210105205123749" data-src="image-20210105205123749.png" class="lazyload"></a></p><h3 id="阶段综合练习二"><a href="#阶段综合练习二" class="headerlink" title="阶段综合练习二"></a>阶段综合练习二</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">实现简单的交互式shell。</span><br><span class="line">使用已学习的各种C函数实现一个简单的交互式Shell，要求：</span><br><span class="line">1、给出提示符，让用户输入一行命令，识别程序名和参数并调用适当的exec函数执行程序，待执行完成后再次给出提示符。</span><br><span class="line">2、该程序可识别和处理以下符号：</span><br><span class="line">1) 简单的标准输入输出重定向：仿照例 “父子进程ls | wc -l”，先dup2然后exec。</span><br><span class="line">2) 管道（|）：Shell进程先调用pipe创建管道，然后fork出两个子进程。一个子进程关闭读端，调       用dup2将写端赋给标准输出，另一个子进程关闭写端，调用dup2把读端赋给标准输入，两个子进程分别         调用exec执行程序，而Shell进程把管道的两端都关闭，调用wait等待两个子进程终止。类似于“兄弟进       程间ls | wc –l”练习的实现。</span><br><span class="line"></span><br><span class="line">你的程序应该可以处理以下命令：</span><br><span class="line">    ○ls△-l△-R○&gt;○file1○</span><br><span class="line">    ○cat○&lt;○file1○|○wc△-c○&gt;○file1○</span><br><span class="line">    注：○表示零个或多个空格，△表示一个或多个空格</span><br><span class="line"></span><br><span class="line">实现步骤： </span><br><span class="line">1. 接收用户输入命令字符串，拆分命令及参数存储。（自行设计数据存储结构）</span><br><span class="line">2. 实现普通命令加载功能 </span><br><span class="line">3. 实现输入、输出重定向的功能 </span><br><span class="line">4. 实现管道 </span><br><span class="line">5. 支持多重管道</span><br></pre></td></tr></table></figure></div><p>几个知识点：</p><p>1、输出重定向：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; out</span><br><span class="line">本来ls -l的结果要出书到屏幕，现在把输出重定向到out里面</span><br><span class="line">打印out即为ls的结果：cat out</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105211353902.png" data-fancybox="group" data-caption="image-20210105211353902" class="fancybox"><img alt="image-20210105211353902" title="image-20210105211353902" data-src="image-20210105211353902.png" class="lazyload"></a></p><p>2、输入重定向</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; a.txt</span><br><span class="line">cat命令的作用是从屏幕获取输入，然后输出到屏幕</span><br><span class="line">现在cat从a.txt获取输入，如何打印到屏幕上</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105211456661.png" data-fancybox="group" data-caption="image-20210105211456661" class="fancybox"><img alt="image-20210105211456661" title="image-20210105211456661" data-src="image-20210105211456661.png" class="lazyload"></a></p><h3 id="阶段综合练习三"><a href="#阶段综合练习三" class="headerlink" title="阶段综合练习三"></a>阶段综合练习三</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简易本地聊天室</span><br><span class="line">借助IPC完成一个简易的本地聊天功能。设有服务器端和客户端两方。服务启动监听客户端请求，并负责记录处理客户端登录、聊天、退出等相关数据。客户端完成登录、发起聊天等操作。可以借助服务器转发向某个指定客户端完成数据包发送(聊天)。</span><br><span class="line">客户端向服务发送数据包，可采用如下协议格式来存储客户端数据，使用“协议号”区分客户端请求的各种状况。服务器依据包号处理客户端对应请求。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210105205405825.png" data-fancybox="group" data-caption="image-20210105205405825" class="fancybox"><img alt="image-20210105205405825" title="image-20210105205405825" data-src="image-20210105205405825.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IPC方法&quot;&gt;&lt;a href=&quot;#IPC方法&quot; class=&quot;headerlink&quot; title=&quot;IPC方法&quot;&gt;&lt;/a&gt;IPC方法&lt;/h2&gt;&lt;div class=&quot;code-area-wrap&quot;&gt;&lt;div class=&quot;highlight-tools&quot;&gt;&lt;i c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发二-系统编程/Day1/Day1</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day1/Day1/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day1/Day1/</id>
    <published>2021-01-30T07:20:25.776Z</published>
    <updated>2021-01-02T14:28:21.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h2><h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">程序：是指编译好的二进制文件，在磁盘上，不占用系统资源（cpu、内存、打开的文件、设备、锁）</span><br><span class="line">进程：是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。（程序运行起来，产生一个进程）</span><br><span class="line">example：</span><br><span class="line">程序--》剧本（纸）   进程--》戏（舞台、灯光、演员、道具）</span><br><span class="line">同一个程序可以加载为不同的进程，彼此之间互不影响（类比：同一剧本可以在多个舞台同时上演）</span><br><span class="line">例如：同时打开两个终端，各自有一个bash但彼此ID不同</span><br></pre></td></tr></table></figure></div><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发，在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但，任一个时刻点上仍只有一个进程在运行。</span><br><span class="line">例如，当下，我们使用计算机时可以边听音乐边聊天边上网。 若笼统的将他们均看做一个进程的话，为什么可以同时运行呢，因为并发。</span><br></pre></td></tr></table></figure></div><h3 id="单道程序设计-amp-多道程序设计"><a href="#单道程序设计-amp-多道程序设计" class="headerlink" title="单道程序设计&amp;多道程序设计"></a>单道程序设计&amp;多道程序设计</h3><p>1、单道程序设计模型（DOS）：所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU在同一时刻只能处理一个任务，ABC任务只能排队执行，由于太浪费系统资源，进而产生了多道程序设计模式</span><br></pre></td></tr></table></figure></div><p>2、多道程序设计模型：</p><p>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时钟中断：</span><br><span class="line">即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</span><br><span class="line">在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</span><br><span class="line">1s &#x3D; 1000ms, 1ms &#x3D; 1000us, 1us &#x3D; 1000ns    1000000000 </span><br><span class="line">实质上，并发是宏观并行，微观串行！</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC三个程序看似同时运行（并行运行），实际是每个任务被划分为多个片段，CPU也被划分为多个时间轮片，将每个轮片分配给每个小的任务片段执行，在A执行后，CPU收回时间轮片，即使用硬件手段实现时间中断收回时间轮片再分配给B的小任务片段，以此类推。</span><br></pre></td></tr></table></figure></div><p><a href="%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.png" data-fancybox="group" data-caption="单道程序设计" class="fancybox"><img alt="单道程序设计" title="单道程序设计" data-src="%E5%8D%95%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.png" class="lazyload"></a></p><h3 id="CPU-amp-MMU"><a href="#CPU-amp-MMU" class="headerlink" title="CPU&amp;MMU"></a>CPU&amp;MMU</h3><p>1、中央处理器（CPU）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">金字塔由下到上，速度逐渐变快，但是存储容量逐渐变小</span><br><span class="line">举例：现在有一个可执行程序a.out</span><br><span class="line">1、首先从网络上download到硬盘，当程序运行后产生进程，a.out中的一些数据就被缓存到内存上，再缓存到cache</span><br><span class="line">2、预取器从cache中取指令（CPU处理的实际是一条条的二进制（由预处理、编译、汇编、链接产生）表示的指令）</span><br><span class="line">3、再交由译码器译码进行指令译码，看需要哪种类型的寄存器，再将数据分别放到对应的寄存器堆（eax、ebx等）</span><br><span class="line">例如：int sum&#x3D;1+2,译码发现需要add，eax存1，ebx存2，add后将结果会写到exa中</span><br><span class="line">4、译码后发现为add，找到对应的算数逻辑单元进行运算，运算完后又回写到寄存器中</span><br><span class="line">5、最后从寄存器堆中再写入到缓存cache中</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216113615431.png" data-fancybox="group" data-caption="image-20201216113615431" class="fancybox"><img alt="image-20201216113615431" title="image-20201216113615431" data-src="image-20201216113615431.png" class="lazyload"></a></p><p>2、内存管理单元MMU</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">位于CPU内部（作为硬件存在）</span><br><span class="line">作用：</span><br><span class="line">1、完成虚拟内存与物理内存的映射</span><br><span class="line">每次运行一段程序的时候产生进程的同时也会产生一个虚拟的内存空间，该空间的地址范围为0~4G，并不是实际的物理地址，故需要MMU完成虚拟地址到物理地址的一个映射，但是写程序时访问的都是虚拟地址，不会使用到MMU</span><br><span class="line">2、设置修改内存的访问级别</span><br><span class="line">由于在0~4G的虚拟地址中0~3G为用户区，而3G~4G为内核区，内核区可以访问整个0~4G整个内存空间，而用户区无法访问内核区数据，由于内存条硬件本身不存在访问的优先级，所以需要通过MMU来给CPU对不同的内存区域设置不同的访问级别，访问级别有0~3四级，但是Linux只使用了0和3级，内核为0级，用户为3级，在使用print函数打印输出时，由于要向下调用系统调用，MMU帮助CPU从3级提升到0级再去访问内核区调用函数完成打印。</span><br><span class="line">注意：两个进程的内核区对应同一块物理空间，两个进程的PCB不一样，但是位于同一块内存空间</span><br><span class="line"></span><br><span class="line">与CPU其他单元配合的地方：</span><br><span class="line">1、预取器读的是虚拟地址，需通过MMU完成到物理空间的映射才能读到真正的数据</span><br><span class="line">2、寄存器往内存中写数据时需要MMU完成配合</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216113710719.png" data-fancybox="group" data-caption="image-20201216113710719" class="fancybox"><img alt="image-20201216113710719" title="image-20201216113710719" data-src="image-20201216113710719.png" class="lazyload"></a></p><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块task_struct结构体。</span><br><span class="line">&#x2F;usr&#x2F;src&#x2F;linux-headers-3.16.0-30&#x2F;include&#x2F;linux&#x2F;sched.h文件中可以查看struct task_struct 结构体定义。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216160632723.png" data-fancybox="group" data-caption="image-20201216160632723" class="fancybox"><img alt="image-20201216160632723" title="image-20201216160632723" data-src="image-20201216160632723.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">重点掌握以下部分：</span><br><span class="line">* 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</span><br><span class="line">--》pid_t被重新typedef了，原来应该是个unsigned int类型</span><br><span class="line"></span><br><span class="line">* 进程的状态，有就绪、运行、挂起、停止等状态。</span><br><span class="line">--》就绪：进程准备好了等待CPU运行，等待cpu分配时间片</span><br><span class="line">    运行：就绪态得到cpu后</span><br><span class="line">    停止：运行结束</span><br><span class="line">    挂起：等待除cpu外的其他资源，主动放弃cpu</span><br><span class="line">    </span><br><span class="line">* 进程切换时需要保存和恢复的一些CPU寄存器。</span><br><span class="line">--》由于cpu中有寄存器，若A任务执行完后需要把cpu让出来给B用，这时候B就会把A原来使用cpu时寄存器的数据给覆盖，故需要将A用寄存器阶段这部分数据进行保存，以保障A再次获取cpu时，cpu能够恢复前一次失去时的状态</span><br><span class="line"></span><br><span class="line">* 描述虚拟地址空间的信息。</span><br><span class="line">--》虚拟地址和物理地址的对应关系，一张表（MMU维护）</span><br><span class="line"></span><br><span class="line">* 描述控制终端的信息。</span><br><span class="line">--》ps命令可以查看终端信息，需要记录该信息</span><br><span class="line"></span><br><span class="line">* 当前工作目录（Current Working Directory）。</span><br><span class="line">--》例如在shell中键入命令ls，会返回对应的工作目录，这个信息就是shell进程的工作目录，返回该进程对应PCB里面的工作目录信息</span><br><span class="line"></span><br><span class="line">* umask掩码。</span><br><span class="line">--》保护文件创建，修改文件权限</span><br><span class="line"></span><br><span class="line">* 文件描述符表，包含很多指向file结构体的指针。</span><br><span class="line">--》数组</span><br><span class="line"></span><br><span class="line">* 和信号相关的信息。</span><br><span class="line">* 用户id和组id。</span><br><span class="line">* 会话（Session）和进程组。</span><br><span class="line">--》功能相近相似的进程放到一起组成进程组，方便管理</span><br><span class="line"></span><br><span class="line">* 进程可以使用的资源上限（Resource Limit）。</span><br><span class="line">--》使用ulimit命令查看各资源上限</span><br><span class="line">使用方法：ulimit -可执行文件名</span><br></pre></td></tr></table></figure></div><p><strong>进程状态</strong>：</p><p><a href="image-20201216165140610.png" data-fancybox="group" data-caption="image-20201216165140610" class="fancybox"><img alt="image-20201216165140610" title="image-20201216165140610" data-src="image-20201216165140610.png" class="lazyload"></a></p><p>对于文件描述符的解释：</p><p><a href="image-20201228214000108.png" data-fancybox="group" data-caption="image-20201228214000108" class="fancybox"><img alt="image-20201228214000108" title="image-20201228214000108" data-src="image-20201228214000108.png" class="lazyload"></a></p><p>在进行的3G-4G位置维护了一个PCB进程控制块，里面有一个指针指向一个文件描述符表，表中每一个位置对应着一个file类型的指针，指向文件结构体，文件结构体中存放文件指针、文件大小、缓冲区等内容，程序就是由此找到对应文件的。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">环境变量，是指在操作系统中用来指定操作系统运行环境的一些参数。</span><br><span class="line">通常具备以下特征：</span><br><span class="line">1、字符串(本质)    2、有统一的格式：名&#x3D;值[:值]   3、值用来描述进程环境信息。</span><br><span class="line">存储形式：与命令行参数类似。char *[]数组，数组名environ，内部存储字符串，NULL作为哨兵结尾。</span><br><span class="line">使用形式：与命令行参数类似。</span><br><span class="line">加载位置：与命令行参数类似。位于用户区，高于stack的起始位置。</span><br><span class="line">引入环境变量表：须声明环境变量。extern char ** environ;</span><br></pre></td></tr></table></figure></div><h3 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h3><p>​    按照惯例，环境变量字符串都是name=value这样的形式，大多数name由大写字母加下划线组成，一般把name的部分叫做环境变量，value的部分则是环境变量的值。环境变量定义了进程的运行环境，一些比较重要的环境变量的含义如下：</p><h4 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名&#x2F;bin&#x2F;ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名.&#x2F;a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录&#x2F;bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值：</span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216191325085.png" data-fancybox="group" data-caption="image-20201216191325085" class="fancybox"><img alt="image-20201216191325085" title="image-20201216191325085" data-src="image-20201216191325085.png" class="lazyload"></a></p><p>练习：打印当前进程的所有环境变量。                                                           </p><p>environ.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;environ[i]!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216194525877.png" data-fancybox="group" data-caption="image-20201216194525877" class="fancybox"><img alt="image-20201216194525877" title="image-20201216194525877" data-src="image-20201216194525877.png" class="lazyload"></a></p><p>注意：这个表中的环境变量和echo打印的不同，echo打印的是bash这个进程的环境变量，而该程序打印的是environ这个程序执行得到的进程的环境变量。</p><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前Shell（命令解析器），它的值通常是&#x2F;bin&#x2F;bash。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216191505590.png" data-fancybox="group" data-caption="image-20201216191505590" class="fancybox"><img alt="image-20201216191505590" title="image-20201216191505590" data-src="image-20201216191505590.png" class="lazyload"></a></p><h4 id="TEAM"><a href="#TEAM" class="headerlink" title="TEAM"></a>TEAM</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216194739682.png" data-fancybox="group" data-caption="image-20201216194739682" class="fancybox"><img alt="image-20201216194739682" title="image-20201216194739682" data-src="image-20201216194739682.png" class="lazyload"></a></p><h4 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a>LANG</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语言和locale，决定了字符编码以及时间、货币等信息的显示格式。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216191713702.png" data-fancybox="group" data-caption="image-20201216191713702" class="fancybox"><img alt="image-20201216191713702" title="image-20201216191713702" data-src="image-20201216191713702.png" class="lazyload"></a></p><h4 id="HOME"><a href="#HOME" class="headerlink" title="HOME"></a>HOME</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216191746391.png" data-fancybox="group" data-caption="image-20201216191746391" class="fancybox"><img alt="image-20201216191746391" title="image-20201216191746391" data-src="image-20201216191746391.png" class="lazyload"></a></p><h3 id="getenv"><a href="#getenv" class="headerlink" title="getenv"></a>getenv</h3><p>(获取环境变量值)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 getenv</span><br></pre></td></tr></table></figure></div><p>传入键，返回值，没有的话返回NULL</p><p><a href="image-20201216195138387.png" data-fancybox="group" data-caption="image-20201216195138387" class="fancybox"><img alt="image-20201216195138387" title="image-20201216195138387" data-src="image-20201216195138387.png" class="lazyload"></a></p><h3 id="setenv"><a href="#setenv" class="headerlink" title="setenv"></a>setenv</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量</span><br><span class="line">参数3:1--覆盖原值   0--不覆盖</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 setenv</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216195313604.png" data-fancybox="group" data-caption="image-20201216195313604" class="fancybox"><img alt="image-20201216195313604" title="image-20201216195313604" data-src="image-20201216195313604.png" class="lazyload"></a></p><h3 id="unsetenv"><a href="#unsetenv" class="headerlink" title="unsetenv"></a>unsetenv</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">功能：删除环境变量值</span><br><span class="line">返回值：0--成功   1--失败</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216195920276.png" data-fancybox="group" data-caption="image-20201216195920276" class="fancybox"><img alt="image-20201216195920276" title="image-20201216195920276" data-src="image-20201216195920276.png" class="lazyload"></a></p><p>setenv.c</p><p>程序目的：</p><p>1、首先设置环境变量名name，第一次获取名为name的环境变量值，没有ABD这个环境变量故返回NULL；</p><p>2、第二次将name环境变量设置为”Day Day up”，故第二次再获取name的值的时候返回谷歌设置的环境变量；</p><p>3、将名为”ABCDEF”环境变量删除，由于不存在删除成功，但不影响name的环境变量值；</p><p>（将name设置为”ABD=”则返回-1）</p><p>4、将名为”ABD”的环境变量删除，删除成功，后面获取名为name的环境变量，由于不存在，返回NULL。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">"ABD"</span>;</span><br><span class="line"></span><br><span class="line">val = getenv(name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1, %s = %s\n"</span>, name, val);</span><br><span class="line"></span><br><span class="line">setenv(name, <span class="string">"haha-day-and-night"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">val = getenv(name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2, %s = %s\n"</span>, name, val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = unsetenv(<span class="string">"ABCDEF"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">val = getenv(name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3, %s = %s\n"</span>, name, val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = unsetenv(<span class="string">"ABD"</span>);  <span class="comment">//name=value:value</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, ret);</span><br><span class="line"></span><br><span class="line">val = getenv(name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3, %s = %s\n"</span>, name, val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216203007406.png" data-fancybox="group" data-caption="image-20201216203007406" class="fancybox"><img alt="image-20201216203007406" title="image-20201216203007406" data-src="image-20201216203007406.png" class="lazyload"></a></p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>1、创建一个子进程</p><p>fork.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">34</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span> ) </span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        var = <span class="number">55</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent pid = %d, parentID = %d, var = %d\n"</span>, getpid(), getppid(), var);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        var = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child  pid = %d, parentID=%d, var = %d\n"</span>, getpid(), getppid(), var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"var = %d\n"</span>, var);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216215201230.png" data-fancybox="group" data-caption="image-20201216215201230" class="fancybox"><img alt="image-20201216215201230" title="image-20201216215201230" data-src="image-20201216215201230.png" class="lazyload"></a></p><p>如图，将子进程延迟1s，所以父进程先执行，pid=3582恰好为子进程的ppid，那么父进程是谁的子进程？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep 2874</span><br></pre></td></tr></table></figure></div><p><a href="image-20201216215631941.png" data-fancybox="group" data-caption="image-20201216215631941" class="fancybox"><img alt="image-20201216215631941" title="image-20201216215631941" data-src="image-20201216215631941.png" class="lazyload"></a></p><p>如图，2874这个进程对应的是bash，说明程序执行的进程是由bash产生的子进程，产生方法也会fork。</p><p>2、循环创建n个子进程</p><p>nfork.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"————--------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'am %d child , pid = %u , ppid = %u\n"</span>, i+<span class="number">1</span>, getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'am %d parent , pid = %u , ppid = %u\n"</span>, i+<span class="number">1</span>, getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201217221948747.png" data-fancybox="group" data-caption="image-20201217221948747" class="fancybox"><img alt="image-20201217221948747" title="image-20201217221948747" data-src="image-20201217221948747.png" class="lazyload"></a></p><p><a href="image-20201217222333765.png" data-fancybox="group" data-caption="image-20201217222333765" class="fancybox"><img alt="image-20201217222333765" title="image-20201217222333765" data-src="image-20201217222333765.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从上图我们可以很清晰的看到，当n为3时候，循环创建了(2^n)-1个子进程，而不是N的子进程。需要在循环的过程，保证子进程不再执行fork ，因此当(fork() &#x3D;&#x3D; 0)时，子进程应该立即break;才正确。</span><br></pre></td></tr></table></figure></div><p>练习：通过命令行参数指定创建进程的个数，每个进程休眠1S打印自己是第几个被创建的进程。如：第1个子进程休眠0秒打印：“我是第1个子进程”；第2个进程休眠1秒打印：“我是第2个子进程”；第3个进程休眠2秒打印：“我是第3个子进程”。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"xxxxxxxxxxx\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line"></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'am %d child , pid = %u\n"</span>, i+<span class="number">1</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201217224647707.png" data-fancybox="group" data-caption="image-20201217224647707" class="fancybox"><img alt="image-20201217224647707" title="image-20201217224647707" data-src="image-20201217224647707.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在fork完后，子进程和父进程谁抢到cpu谁就执行，如果子抢到，此时子的i&#x3D;0，break跳出，打印pid后return结束进程，而父进程拿到cpu继续执行，i++，此时i&#x3D;1，又fork这时候诞生出子2，如果子进程又抢到cpu，则这是执行i&#x3D;1的打印输出然后结束进程。。。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201217230512340.png" data-fancybox="group" data-caption="image-20201217230512340" class="fancybox"><img alt="image-20201217230512340" title="image-20201217230512340" data-src="image-20201217230512340.png" class="lazyload"></a></p><p><strong>解释</strong>：由于每次运行可执行程序时，shell自动切换到后台，把前台让给可执行程序执行，shell通过判断是否到到达return 0后就会多会cpu，但是shell不知道程序也诞生了子进程，所以在父进程到return 0的时候shell跑到了前台，处于阻塞状态，等待用户输入，此时子进程进行了打印就会出现如上情况。</p><p><strong>解决办法</strong>：保障shell的子进程是最后结束的。</p><p>由于for循环按照逻辑，父进程应该一直占用cpu，但是实际程序翻译成二进制后，5个子进程+1个父进程几乎是同时产生的，一起去抢cpu，谁抢到是随机的，在不加控制语句的时候父进程98%的概率抢到cpu。</p><h3 id="getpid"><a href="#getpid" class="headerlink" title="getpid"></a>getpid</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取当前进程ID</span><br><span class="line">    pid_t getpid(void);</span><br></pre></td></tr></table></figure></div><h3 id="getppid"><a href="#getppid" class="headerlink" title="getppid"></a>getppid</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取当前进程的父进程ID</span><br><span class="line">pid_t getppid(void);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">区分一个函数是“系统函数”还是“库函数”依据：</span><br><span class="line">1、是否访问内核数据结构</span><br><span class="line">2、是否访问外部硬件资源二者有任一 → 系统函数；二者均无 → 库函数</span><br></pre></td></tr></table></figure></div><h3 id="getuid"><a href="#getuid" class="headerlink" title="getuid"></a>getuid</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取当前进程实际用户ID</span><br><span class="line">uid_t getuid(void);</span><br><span class="line">获取当前进程有效用户ID</span><br><span class="line">uid_t geteuid(void);</span><br></pre></td></tr></table></figure></div><p>实际用户和有效用户id是一样的，但是有特殊情况，例如在执行<code>sudo apt-get install ***</code>的时候有效用户id为sudo，而实际用户仍然为实际用户。</p><h3 id="getgid"><a href="#getgid" class="headerlink" title="getgid"></a>getgid</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取当前进程使用用户组ID</span><br><span class="line">gid_t getgid(void);</span><br><span class="line">获取当前进程有效用户组ID</span><br><span class="line">gid_t getegid(void);</span><br></pre></td></tr></table></figure></div><h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父子进程之间在fork后。有哪些相同，那些相异之处呢？</span><br><span class="line">刚fork之后：</span><br><span class="line">父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式...</span><br><span class="line">父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集</span><br><span class="line">似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB，但pid不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？</span><br><span class="line">当然不是!父子进程间遵循读时共享写时复制的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。</span><br></pre></td></tr></table></figure></div><p>练习：编写程序测试，父子进程是否共享全局变。                                    </p><p>【fork_shared.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pi=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child,a=%d\n"</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent,a=%d\n"</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201228205825472.png" data-fancybox="group" data-caption="image-20201228205825472" class="fancybox"><img alt="image-20201228205825472" title="image-20201228205825472" data-src="image-20201228205825472.png" class="lazyload"></a></p><p>如图可知，父进程打印的全局变量与子进程的不同，故不共享全局变量。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">重点注意！躲避父子进程共享全局变量的知识误区！</span><br><span class="line">【重点】：父子进程共享：1. 文件描述符(打开文件的结构体)  2. mmap建立的映射区 (进程间通信详解)</span><br><span class="line"></span><br><span class="line">特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。</span><br></pre></td></tr></table></figure></div><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</span><br><span class="line">set follow-fork-mode child 命令设置gdb在fork之后跟踪子进程。</span><br><span class="line">set follow-fork-mode parent 设置跟踪父进程。</span><br><span class="line">注意，一定要在fork函数调用之前设置才有效。</span><br></pre></td></tr></table></figure></div><p>【follow_fork.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pi=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child, pid =%d , ppid = %d  ,a=%d\n"</span>,getpid(),getppid(),a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent,pid =%d ppid = %d,a=%d\n"</span>,getpid(),getppid(),a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201228211853585.png" data-fancybox="group" data-caption="image-20201228211853585" class="fancybox"><img alt="image-20201228211853585" title="image-20201228211853585" data-src="image-20201228211853585.png" class="lazyload"></a></p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</span><br><span class="line">将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。</span><br><span class="line">其实有六种以exec开头的函数，统称exec函数：</span><br><span class="line">int execl(const char *path, const char *arg, ...);</span><br><span class="line">int execlp(const char *file, const char *arg, ...);</span><br><span class="line">int execle(const char *path, const char *arg, ..., char *const envp[]);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[]);</span><br></pre></td></tr></table></figure></div><h3 id="execl函数-amp-execlp函数"><a href="#execl函数-amp-execlp函数" class="headerlink" title="execl函数&amp;execlp函数"></a>execl函数&amp;execlp函数</h3><p><strong>execlp</strong>:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加载一个进程，借助PATH环境变量     </span><br><span class="line">int execlp(const char *file, const char *arg, ...);成功：无返回；失败：-1</span><br><span class="line">    参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。</span><br><span class="line">    该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。</span><br></pre></td></tr></table></figure></div><p>【execlp_ls.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        execlp(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229174328912.png" data-fancybox="group" data-caption="image-20201229174328912" class="fancybox"><img alt="image-20201229174328912" title="image-20201229174328912" data-src="image-20201229174328912.png" class="lazyload"></a></p><p><a href="image-20201229174414554.png" data-fancybox="group" data-caption="image-20201229174414554" class="fancybox"><img alt="image-20201229174414554" title="image-20201229174414554" data-src="image-20201229174414554.png" class="lazyload"></a></p><p>如图可知，子进程执行了ls -a程序，其中第二个参数为argv[0]是传入ls的参数，ls没参数，使用可以随意传入。</p><p><strong>execl</strong>:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加载一个进程， 通过 路径+程序名 来加载。 </span><br><span class="line">    int execl(const char *path, const char *arg, ...);成功：无返回；失败：-1</span><br><span class="line">对比execlp，如加载&quot;ls&quot;命令带有-l，-F参数</span><br><span class="line">execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);     使用程序名在PATH中搜索。</span><br><span class="line">execl(&quot;&#x2F;bin&#x2F;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-F&quot;, NULL);    使用参数1给出的绝对路径搜索。</span><br></pre></td></tr></table></figure></div><p>【execl_ls.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-a"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229175129866.png" data-fancybox="group" data-caption="image-20201229175129866" class="fancybox"><img alt="image-20201229175129866" title="image-20201229175129866" data-src="image-20201229175129866.png" class="lazyload"></a></p><p>如图，程序达到了和ls -al一样的效果。</p><p><strong>练习</strong>：执行自定义程序</p><p>【while.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dabai\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>【execl_while.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">"./while"</span>,<span class="string">"while"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229190218422.png" data-fancybox="group" data-caption="image-20201229190218422" class="fancybox"><img alt="image-20201229190218422" title="image-20201229190218422" data-src="image-20201229190218422.png" class="lazyload"></a></p><p>如图所示，子进程不断往屏幕打印dabai字符串，由于父进行结束的早，所以shell进行了一次插入。</p><p>此处退出不了需要重新打开一个shell将while进程杀死</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">找到while的进程，4165</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229190755200.png" data-fancybox="group" data-caption="image-20201229190755200" class="fancybox"><img alt="image-20201229190755200" title="image-20201229190755200" data-src="image-20201229190755200.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 4165</span><br></pre></td></tr></table></figure></div><h3 id="execle函数"><a href="#execle函数" class="headerlink" title="execle函数"></a>execle函数</h3><p>e:environment</p><h3 id="execv函数-amp-execvp函数"><a href="#execv函数-amp-execvp函数" class="headerlink" title="execv函数&amp;execvp函数"></a>execv函数&amp;execvp函数</h3><p>execv:</p><p>v：argv[]</p><p>【execv.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[]=&#123;<span class="string">"ls"</span>,<span class="string">"-1"</span>,<span class="string">"-a"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">        execv(<span class="string">"/bin/ls"</span>,argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229192022383.png" data-fancybox="group" data-caption="image-20201229192022383" class="fancybox"><img alt="image-20201229192022383" title="image-20201229192022383" data-src="image-20201229192022383.png" class="lazyload"></a></p><p>execvp：借助环境变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加载一个进程，使用自定义环境变量env</span><br><span class="line">int execvp(const char *file, const char *argv[]);</span><br><span class="line">变参形式： ①... ② argv[]  (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, ...)) </span><br><span class="line">变参终止条件：① NULL结尾 ② 固参指定</span><br><span class="line">execvp与execlp参数形式不同，原理一致。</span><br></pre></td></tr></table></figure></div><p><strong>练习</strong>：将当前系统中的进程信息，打印到文件中</p><p>【exec_ps.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcbtl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd=<span class="built_in">open</span>(<span class="string">"ps.out"</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="comment">//以只写方式打开，不存在就创建，存在就截断为0</span></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"ax"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//close(fd);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于执行ps进程，并且execlp只在函数出错时有返回值，运行成功没有返回值，不会回到原程序直接去执行另一个程序去了，并不会执行execlp后面的语句，只能依靠隐式回收关闭文件。</p><p><a href="image-20201229210353829.png" data-fancybox="group" data-caption="image-20201229210353829" class="fancybox"><img alt="image-20201229210353829" title="image-20201229210353829" data-src="image-20201229210353829.png" class="lazyload"></a></p><p>如图所示，ps ax执行后的内容被输出到ps.out文件中。</p><h3 id="exec函数族一般规律"><a href="#exec函数族一般规律" class="headerlink" title="exec函数族一般规律"></a>exec函数族一般规律</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exec函数一旦调用成功即执行新的程序，不返回。**只有失败才返回，错误值****-1**。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。</span><br><span class="line"></span><br><span class="line">l (list)              命令行参数列表</span><br><span class="line"></span><br><span class="line">p (path)            搜素file时使用path变量</span><br><span class="line"></span><br><span class="line">v (vector)          使用命令行参数数组</span><br><span class="line"></span><br><span class="line">e (environment)    使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量</span><br><span class="line"></span><br><span class="line">事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229210916715.png" data-fancybox="group" data-caption="image-20201229210916715" class="fancybox"><img alt="image-20201229210916715" title="image-20201229210916715" data-src="image-20201229210916715.png" class="lazyload"></a></p><p>那么如何写exec函数出错判断呢？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"ax"</span>,<span class="literal">NULL</span>);</span><br><span class="line">perror(<span class="string">"exec error"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</span><br></pre></td></tr></table></figure></div><p>【orphan.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"————--------------\n"</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'am child , pid = %u , ppid = %u\n"</span>, getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'am child , pid = %u , ppid = %u\n"</span>, getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'am parent , pid = %u , ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229212253328.png" data-fancybox="group" data-caption="image-20201229212253328" class="fancybox"><img alt="image-20201229212253328" title="image-20201229212253328" data-src="image-20201229212253328.png" class="lazyload"></a></p><p><a href="image-20201229212646513.png" data-fancybox="group" data-caption="image-20201229212646513" class="fancybox"><img alt="image-20201229212646513" title="image-20201229212646513" data-src="image-20201229212646513.png" class="lazyload"></a></p><p>如图，1874为init进程，称为孤儿院进程。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。  </span><br><span class="line">特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。思考！用什么办法可清除掉僵尸进程呢？</span><br><span class="line"></span><br><span class="line">答：杀死其父进程，之后该僵尸进程编程孤儿进程被init(孤儿院)进程领养，之后进行回收</span><br></pre></td></tr></table></figure></div><p>【zoom.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'am  child , pid = %u , ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am parent, pid = %d, ppid = %d\n"</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229214913134.png" data-fancybox="group" data-caption="image-20201229214913134" class="fancybox"><img alt="image-20201229214913134" title="image-20201229214913134" data-src="image-20201229214913134.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重新打开一个shell，查看进程</span><br><span class="line">ps aux</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229215031550.png" data-fancybox="group" data-caption="image-20201229215031550" class="fancybox"><img alt="image-20201229215031550" title="image-20201229215031550" data-src="image-20201229215031550.png" class="lazyload"></a></p><p>如图，子进程结束父进程继续执行，标识[zoom]&lt;defunc表示僵尸进程，Z+代表僵尸进程。</p><p>如何避免僵尸进程出现？继续看吧！</p><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</span><br><span class="line">父进程调用wait函数可以回收子进程终止信息。该函数有三个功能：</span><br><span class="line">① 阻塞等待子进程退出 </span><br><span class="line">② 回收子进程残留资源 </span><br><span class="line">③ 获取子进程结束状态(退出原因)。</span><br><span class="line">    pid_t wait(int *status); 成功：清理掉的子进程ID；失败：-1 (没有子进程)</span><br><span class="line">当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229220001745.png" data-fancybox="group" data-caption="image-20201229220001745" class="fancybox"><img alt="image-20201229220001745" title="image-20201229220001745" data-src="image-20201229220001745.png" class="lazyload"></a></p><p>【wait1.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, wpid;</span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'am  child , pid = %u , ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">            sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wpid=wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"wait() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am parent, pid = %d, ppid = %d\n"</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201229220402972.png" data-fancybox="group" data-caption="image-20201229220402972" class="fancybox"><img alt="image-20201229220402972" title="image-20201229220402972" data-src="image-20201229220402972.png" class="lazyload"></a></p><p><a href="image-20201229220456718.png" data-fancybox="group" data-caption="image-20201229220456718" class="fancybox"><img alt="image-20201229220456718" title="image-20201229220456718" data-src="image-20201229220456718.png" class="lazyload"></a></p><p>如图所示，等到子进程结束父进程才开始打印，此前父进程处于阻塞状态，图二所示，未产生僵尸进程。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组：</span><br><span class="line"> 1.  WIFEXITED(status) 为非0→ 进程正常结束</span><br><span class="line">WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数)</span><br><span class="line"> 2. WIFSIGNALED(status) 为非0 → 进程异常终止</span><br><span class="line">WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。</span><br><span class="line">*3. WIFSTOPPED(status) 为非0 → 进程处于暂停状态</span><br><span class="line">WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。</span><br><span class="line">WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行</span><br></pre></td></tr></table></figure></div><p><strong>获取退出状态</strong></p><p>1、正常退出</p><p>【wait2.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="keyword">int</span> status;<span class="comment">//状态记录,传出参数</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'am  child , pid = %u , ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;<span class="comment">//exit(11);数字任意,不超过128即可</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wpid=wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"wait() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am parent, pid = %d, ppid = %d\n"</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230103151118.png" data-fancybox="group" data-caption="image-20201230103151118" class="fancybox"><img alt="image-20201230103151118" title="image-20201230103151118" data-src="image-20201230103151118.png" class="lazyload"></a></p><p>注意：退出状态别超过128</p><p>2、异常退出</p><p>2.1、被另一个终端kill了子进程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">kill -9 + 进程id</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230103527260.png" data-fancybox="group" data-caption="image-20201230103527260" class="fancybox"><img alt="image-20201230103527260" title="image-20201230103527260" data-src="image-20201230103527260.png" class="lazyload"></a></p><p>注意：在另一个shell将子进程杀死，将睡眠时间设计长一些，以免未操作子进程已经正常结束。</p><p>2.2、被另一个程序异常中断</p><p>【wait.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="keyword">int</span> status;<span class="comment">//状态记录,传出参数</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        execl(<span class="string">"abnor"</span>,<span class="string">"abnor"</span>,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'am  child , pid = %u , ppid = %u\n"</span>,getpid(),getppid());</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child die\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;<span class="comment">//exit(11);数字任意,不超过128即可</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        wpid=wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"wait() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I am parent, pid = %d, ppid = %d\n"</span>, getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>2.2.1、给常量赋值</p><p>【abnor.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p=<span class="string">"test of wait abnormally\n"</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="string">'h'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">56</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230104103295.png" data-fancybox="group" data-caption="image-20201230104103295" class="fancybox"><img alt="image-20201230104103295" title="image-20201230104103295" data-src="image-20201230104103295.png" class="lazyload"></a></p><p>如图可知，给常量赋值为段错误。</p><p><a href="image-20201230104508059.png" data-fancybox="group" data-caption="image-20201230104508059" class="fancybox"><img alt="image-20201230104508059" title="image-20201230104508059" data-src="image-20201230104508059.png" class="lazyload"></a></p><p>子进程被信号11杀死。</p><p>2.2.2、除0操作</p><p>【abnor.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* p=<span class="string">"test of wait abnormally\n"</span>;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="string">'h'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">56</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230104633689.png" data-fancybox="group" data-caption="image-20201230104633689" class="fancybox"><img alt="image-20201230104633689" title="image-20201230104633689" data-src="image-20201230104633689.png" class="lazyload"></a></p><p>如图，错误为浮点数例外。</p><p><a href="image-20201230104649194.png" data-fancybox="group" data-caption="image-20201230104649194" class="fancybox"><img alt="image-20201230104649194" title="image-20201230104649194" data-src="image-20201230104649194.png" class="lazyload"></a></p><p>子进程被信号8杀死。</p><p><strong>注意：如果有多个子进程，父进程只回收其中的一个，哪个先结束就回收谁。</strong></p><p>【测试任意回收一个子进程】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> p,q;</span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=fork();</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent,pid=%d\n"</span>,getpid());</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d child,pid=%d,ppid=%d\n"</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230113247119.png" data-fancybox="group" data-caption="image-20201230113247119" class="fancybox"><img alt="image-20201230113247119" title="image-20201230113247119" data-src="image-20201230113247119.png" class="lazyload"></a></p><p>如图，使用ps aux命令查看可知，只产生了4个僵尸进程，父进程任意回收了一个。</p><p><strong>如何实现回收5个子进程？</strong></p><p>只需要将wait循环，由于wait回收完成后返回一个大于0的数，故将该函数放入while中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n==i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent,pid=%d\n"</span>,getpid());</span><br><span class="line">        <span class="keyword">while</span>(wait(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230113804246.png" data-fancybox="group" data-caption="image-20201230113804246" class="fancybox"><img alt="image-20201230113804246" title="image-20201230113804246" data-src="image-20201230113804246.png" class="lazyload"></a></p><h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">作用同wait，但可指定pid进程清理，可以不阻塞。</span><br><span class="line">    pid_t waitpid(pid_t pid, int *status, in options);成功：返回清理掉的子进程ID；失败：-1(无子进程)</span><br><span class="line">特殊参数和返回情况：</span><br><span class="line">参数pid： </span><br><span class="line">&gt; 0 回收指定ID的子进程</span><br><span class="line">-1 回收任意子进程（相当于wait）</span><br><span class="line">0 回收和当前调用waitpid一个组的所有子进程</span><br><span class="line">&lt; -1 回收指定进程组内的任意子进程</span><br><span class="line">返回0：参3为WNOHANG，且子进程正在运行。</span><br><span class="line"></span><br><span class="line">注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</span><br></pre></td></tr></table></figure></div><p>1、阻塞指定进程进行回收</p><p>【waitpid.c】</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> p,q;</span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=fork();</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存第i+1=4个儿子的进程id</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent,pid=%d\n"</span>,getpid());</span><br><span class="line">        waitpid(q,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d child,pid=%d,ppid=%d\n"</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230114500388.png" data-fancybox="group" data-caption="image-20201230114500388" class="fancybox"><img alt="image-20201230114500388" title="image-20201230114500388" data-src="image-20201230114500388.png" class="lazyload"></a></p><p>2、用waitpid回收所有的子进程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span> 回收任意子进程（相当于wait）</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>));</span><br></pre></td></tr></table></figure></div><p>3、非阻塞方式进行轮询回收</p><p>非阻塞时，结束了才回收不结束不回收</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> p,q;</span><br><span class="line">    <span class="keyword">if</span>(argc==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n=atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=fork();</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存第i+1=4个儿子的进程id</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==i)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent,pid=%d\n"</span>,getpid());</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            wpid=waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG);</span><br><span class="line">            <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)<span class="comment">//说明回收成功，剩余子进程数-1</span></span><br><span class="line">            &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>);<span class="comment">//n=0时回收结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"wait finish\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d child,pid=%d,ppid=%d\n"</span>,i+<span class="number">1</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>4、回收一个组内的子进程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">产生同组进程：</span><br><span class="line">cat | cat | cat | cat</span><br><span class="line">查看进行所属组：</span><br><span class="line">ps ajx | grep cat</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230154219020.png" data-fancybox="group" data-caption="image-20201230154219020" class="fancybox"><img alt="image-20201230154219020" title="image-20201230154219020" data-src="image-20201230154219020.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将同组进程杀死，取组进行id的相反数即可：</span><br><span class="line">kill -9 5784</span><br></pre></td></tr></table></figure></div><p><a href="image-20201230154341449.png" data-fancybox="group" data-caption="image-20201230154341449" class="fancybox"><img alt="image-20201230154341449" title="image-20201230154341449" data-src="image-20201230154341449.png" class="lazyload"></a></p><p><strong>作业</strong>：父进程fork 3 个子进程，三个子进程一个调用ps命令， 一个调用自定义程序1(正常)，一个调用自定义程序2(会出段错误)。父进程使用waitpid对其子进程进行回收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程相关概念&quot;&gt;&lt;a href=&quot;#进程相关概念&quot; class=&quot;headerlink&quot; title=&quot;进程相关概念&quot;&gt;&lt;/a&gt;进程相关概念&lt;/h2&gt;&lt;h3 id=&quot;程序和进程&quot;&gt;&lt;a href=&quot;#程序和进程&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发三-网络编程/Day1/Day1</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%89-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Day1/Day1/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%89-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Day1/Day1/</id>
    <published>2021-01-30T07:20:25.716Z</published>
    <updated>2021-01-20T07:52:03.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议的概念"><a href="#协议的概念" class="headerlink" title="协议的概念"></a>协议的概念</h2><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</span><br><span class="line">假设，A、B双方欲传输文件。规定：</span><br><span class="line">第一次，传输文件名，接收方接收到文件名，应答OK给传输方；</span><br><span class="line">第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；</span><br><span class="line">第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。</span><br><span class="line">由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。</span><br><span class="line">这种仅在A、B之间被遵守的协议称之为原始协议。当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个标准协议。最早的ftp协议就是由此衍生而来。</span><br><span class="line">TCP协议注重数据的传输。http协议着重于数据的解释。</span><br></pre></td></tr></table></figure></div><h3 id="典型协议"><a href="#典型协议" class="headerlink" title="典型协议"></a>典型协议</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">传输层 常见协议有TCP&#x2F;UDP协议。</span><br><span class="line">应用层 常见的协议有HTTP协议，FTP协议。</span><br><span class="line">网络层 常见协议有IP协议、ICMP协议、IGMP协议。</span><br><span class="line">网络接口层 常见协议有ARP协议、RARP协议。</span><br><span class="line">TCP传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br><span class="line">UDP用户数据报协议（User Datagram Protocol）是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</span><br><span class="line">HTTP超文本传输协议（Hyper Text Transfer Protocol）是互联网上应用最为广泛的一种网络协议。</span><br><span class="line">FTP文件传输协议（File Transfer Protocol）</span><br><span class="line">IP协议是因特网互联协议（Internet Protocol）</span><br><span class="line">ICMP协议是Internet控制报文协议（Internet Control Message Protocol）它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</span><br><span class="line">IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。</span><br><span class="line">ARP协议是正向地址解析协议（Address Resolution Protocol），通过已知的IP，寻找对应主机的MAC地址。</span><br><span class="line">RARP是反向地址转换协议，通过MAC地址确定IP地址。</span><br></pre></td></tr></table></figure></div><h2 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h2><h3 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传统的网络应用设计模式，客户机(client)&#x2F;服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</span><br></pre></td></tr></table></figure></div><h3 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器()&#x2F;服务器(server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</span><br></pre></td></tr></table></figure></div><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于C&#x2F;S模式来说，其优点明显。客户端位于目标主机上可以保证性能，将数据缓存至客户端本地，从而提高数据传输效率。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯公司所采用的通信协议，即为ftp协议的修改剪裁版。</span><br><span class="line">因此，传统的网络应用程序及较大型的网络应用程序都首选C&#x2F;S模式进行开发。如，知名的网络游戏魔兽世界。3D画面，数据量庞大，使用C&#x2F;S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。</span><br><span class="line">C&#x2F;S模式的缺点也较突出。由于客户端和服务器都需要有一个开发团队来完成开发。工作量将成倍提升，开发周期较长。另外，从用户角度出发，需要将客户端安插至用户主机上，对用户主机的安全性构成威胁。这也是很多用户不愿使用C&#x2F;S模式应用程序的重要原因。</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B&#x2F;S模式相比C&#x2F;S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此移植性非常好，不受平台限制。如早期的偷菜游戏，在各个平台上都可以完美运行。</span><br><span class="line">B&#x2F;S模式的缺点也较明显。由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活。</span><br></pre></td></tr></table></figure></div><p>因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p><h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><a href="image-20210114164912969.png" data-fancybox="group" data-caption="image-20210114164912969" class="fancybox"><img alt="image-20210114164912969" title="image-20210114164912969" data-src="image-20210114164912969.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</span><br><span class="line">2.数据链路层：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1</span><br><span class="line">3.网络层：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</span><br><span class="line">4.传输层：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</span><br><span class="line">5.会话层：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</span><br><span class="line">6.表示层：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</span><br><span class="line">7.应用层：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</span><br></pre></td></tr></table></figure></div><h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP&#x2F;IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：</span><br><span class="line">一般在应用开发过程中，讨论最多的是TCP&#x2F;IP模型。</span><br></pre></td></tr></table></figure></div><p><a href="image-20210115092856351.png" data-fancybox="group" data-caption="image-20210115092856351" class="fancybox"><img alt="image-20210115092856351" title="image-20210115092856351" data-src="image-20210115092856351.png" class="lazyload"></a></p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两台计算机通过TCP&#x2F;IP协议通讯的过程如下所示：</span><br></pre></td></tr></table></figure></div><p><a href="image-20210115093506367.png" data-fancybox="group" data-caption="image-20210115093506367" class="fancybox"><img alt="image-20210115093506367" title="image-20210115093506367" data-src="image-20210115093506367.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：</span><br></pre></td></tr></table></figure></div><p><a href="image-20210115093527951.png" data-fancybox="group" data-caption="image-20210115093527951" class="fancybox"><img alt="image-20210115093527951" title="image-20210115093527951" data-src="image-20210115093527951.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">链路层有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。</span><br><span class="line">网络层的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。</span><br><span class="line">网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。</span><br><span class="line">TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。</span><br><span class="line">UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。</span><br></pre></td></tr></table></figure></div><p>​    目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：</p><p><a href="image-20210115094148094.png" data-fancybox="group" data-caption="image-20210115094148094" class="fancybox"><img alt="image-20210115094148094" title="image-20210115094148094" data-src="image-20210115094148094.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。</span><br><span class="line">虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。</span><br></pre></td></tr></table></figure></div><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><h3 id="数据包封装"><a href="#数据包封装" class="headerlink" title="数据包封装"></a>数据包封装</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：</span><br></pre></td></tr></table></figure></div><p><a href="image-20210115094629953.png" data-fancybox="group" data-caption="image-20210115094629953" class="fancybox"><img alt="image-20210115094629953" title="image-20210115094629953" data-src="image-20210115094629953.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。</span><br></pre></td></tr></table></figure></div><h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>​    以太网的帧格式如下所示：</p><p><a href="image-20210115094945905.png" data-fancybox="group" data-caption="image-20210115094945905" class="fancybox"><img alt="image-20210115094945905" title="image-20210115094945905" data-src="image-20210115094945905.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。</span><br><span class="line">以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。</span><br></pre></td></tr></table></figure></div><h3 id="ARP数据报格式"><a href="#ARP数据报格式" class="headerlink" title="ARP数据报格式"></a>ARP数据报格式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</span><br><span class="line">每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？</span><br></pre></td></tr></table></figure></div><p>​    ARP数据报的格式如下所示：</p><p><a href="image-20210115095531887.png" data-fancybox="group" data-caption="image-20210115095531887" class="fancybox"><img alt="image-20210115095531887" title="image-20210115095531887" data-src="image-20210115095531887.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。</span><br><span class="line">   看一个具体的例子。</span><br><span class="line">   请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）：</span><br><span class="line">   以太网首部（14字节）</span><br><span class="line">   0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06</span><br><span class="line">   ARP帧（28字节）</span><br><span class="line">   0000: 00 01</span><br><span class="line">   0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37</span><br><span class="line">   0020: 00 00 00 00 00 00 c0 a8 00 02</span><br><span class="line">   填充位（18字节）</span><br><span class="line">   0020: 00 77 31 d2 50 10</span><br><span class="line">   0030: fd 78 41 d3 00 00 00 00 00 00 00 00</span><br><span class="line">   以太网首部：目的主机采用广播地址，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。</span><br><span class="line">ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55），目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。</span><br><span class="line">由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。</span><br><span class="line">应答帧如下：</span><br><span class="line">   以太网首部</span><br><span class="line">   0000: 00 05 5d 61 58 a8 00 05 5d a1 b8 40 08 06</span><br><span class="line">   ARP帧</span><br><span class="line">   0000: 00 01</span><br><span class="line">   0010: 08 00 06 04 00 02 00 05 5d a1 b8 40 c0 a8 00 02</span><br><span class="line">   0020: 00 05 5d 61 58 a8 c0 a8 00 37</span><br><span class="line">   填充位</span><br><span class="line">   0020: 00 77 31 d2 50 10</span><br><span class="line">   0030: fd 78 41 d3 00 00 00 00 00 00 00 00</span><br><span class="line">   以太网首部：目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，上层协议类型0x0806表示ARP。</span><br><span class="line">ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。</span><br></pre></td></tr></table></figure></div><p>​    思考题：如果源主机和目的主机不在同一网段，ARP请求的广播帧无法穿过路由器，源主机如何与目的主机通信？</p><h3 id="IP段格式"><a href="#IP段格式" class="headerlink" title="IP段格式"></a>IP段格式</h3><p><a href="image-20210115095820928.png" data-fancybox="group" data-caption="image-20210115095820928" class="fancybox"><img alt="image-20210115095820928" title="image-20210115095820928" data-src="image-20210115095820928.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。对于IPv4，4位版本字段是4。4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5&#x3D;20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP首部和IP层payload）的字节数。每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。3位标志和13位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。</span><br><span class="line">想一想，前面讲了以太网帧中的最小数据长度为46字节，不足46字节的要用填充字节补上，那么如何界定这46字节里前多少个字节是IP、ARP或RARP数据报而后面是填充字节？</span><br></pre></td></tr></table></figure></div><h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><p><a href="image-20210115095848575.png" data-fancybox="group" data-caption="image-20210115095848575" class="fancybox"><img alt="image-20210115095848575" title="image-20210115095848575" data-src="image-20210115095848575.png" class="lazyload"></a></p><h3 id="TCP数据报格式"><a href="#TCP数据报格式" class="headerlink" title="TCP数据报格式"></a>TCP数据报格式</h3><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP通信时序"><a href="#TCP通信时序" class="headerlink" title="TCP通信时序"></a>TCP通信时序</h3><h3 id="滑动窗口-TCP流量控制"><a href="#滑动窗口-TCP流量控制" class="headerlink" title="滑动窗口 (TCP流量控制)"></a>滑动窗口 (TCP流量控制)</h3><h3 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h3><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><h3 id="2MSL"><a href="#2MSL" class="headerlink" title="2MSL"></a>2MSL</h3><h4 id="程序设计中的问题"><a href="#程序设计中的问题" class="headerlink" title="程序设计中的问题"></a>程序设计中的问题</h4><h4 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h4><h3 id="TCP异常断开"><a href="#TCP异常断开" class="headerlink" title="TCP异常断开"></a>TCP异常断开</h3><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><h4 id="设置TCP属性"><a href="#设置TCP属性" class="headerlink" title="设置TCP属性"></a>设置TCP属性</h4><h2 id="网络名词术语解析"><a href="#网络名词术语解析" class="headerlink" title="网络名词术语解析"></a>网络名词术语解析</h2><h3 id="路由-route"><a href="#路由-route" class="headerlink" title="路由(route)"></a>路由(route)</h3><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a>路由表(Routing Table)</h3><h3 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h3><h3 id="缺省路由条目"><a href="#缺省路由条目" class="headerlink" title="缺省路由条目"></a>缺省路由条目</h3><h3 id="路由节点"><a href="#路由节点" class="headerlink" title="路由节点"></a>路由节点</h3><h3 id="以太网交换机工作原理"><a href="#以太网交换机工作原理" class="headerlink" title="以太网交换机工作原理"></a>以太网交换机工作原理</h3><h3 id="hub工作原理"><a href="#hub工作原理" class="headerlink" title="hub工作原理"></a>hub工作原理</h3><h3 id="半双工-全双工"><a href="#半双工-全双工" class="headerlink" title="半双工/全双工"></a>半双工/全双工</h3><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><h3 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h3><h3 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h3><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><h2 id="常见网络知识面试题"><a href="#常见网络知识面试题" class="headerlink" title="常见网络知识面试题"></a>常见网络知识面试题</h2><p>如果先终止server端，其实6666端口仍然被占用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -apn | grep <span class="number">6666</span></span><br></pre></td></tr></table></figure></div><p><a href="image-20210118163226947.png" data-fancybox="group" data-caption="image-20210118163226947" class="fancybox"><img alt="image-20210118163226947" title="image-20210118163226947" data-src="image-20210118163226947.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;协议的概念&quot;&gt;&lt;a href=&quot;#协议的概念&quot; class=&quot;headerlink&quot; title=&quot;协议的概念&quot;&gt;&lt;/a&gt;协议的概念&lt;/h2&gt;&lt;h3 id=&quot;什么是协议&quot;&gt;&lt;a href=&quot;#什么是协议&quot; class=&quot;headerlink&quot; title=&quot;什么是
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发一-基础/Day5/Day5</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day5/Day5/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day5/Day5/</id>
    <published>2021-01-30T07:20:25.636Z</published>
    <updated>2020-12-16T03:06:11.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux文件操作相关函数"><a href="#Linux文件操作相关函数" class="headerlink" title="Linux文件操作相关函数"></a>Linux文件操作相关函数</h2><p>（这些函数都有对应的命令）</p><h3 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h3><p>功能：获取文件属性信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用Linux命令stat进行查看完成了一个什么样的功能：</span><br><span class="line">stat + 文件名（与ls -l功能类似）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212161917167.png" data-fancybox="group" data-caption="image-20201212161917167" class="fancybox"><img alt="image-20201212161917167" title="image-20201212161917167" data-src="image-20201212161917167.png" class="lazyload"></a></p><p>1、stat函数的用法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 stat</span><br></pre></td></tr></table></figure></div><p>****<a href="image-20201212162241592.png" data-fancybox="group" data-caption="image-20201212162241592" class="fancybox"><img alt="image-20201212162241592" title="image-20201212162241592" data-src="image-20201212162241592.png" class="lazyload"></a></p><p>注意：stat的第二个形参是一个结构体指针，这种以指针方式传入的一般为传出参数，即需要在函数内完成对该结构体的修改，相当于外面准备了一块内存空间，在函数体内完成对该块内存空间的写入操作。</p><p>2、<strong>对于struct stat的解释</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct stat &#123;</span><br><span class="line">    dev_t         st_dev;       &#x2F;&#x2F;文件的设备编号</span><br><span class="line">    ino_t         st_ino;       &#x2F;&#x2F;节点</span><br><span class="line">    mode_t        st_mode;      &#x2F;&#x2F;文件的类型和存取的权限</span><br><span class="line">    nlink_t       st_nlink;     &#x2F;&#x2F;连到该文件的硬连接数目，刚建立的文件值为1</span><br><span class="line">    uid_t         st_uid;       &#x2F;&#x2F;用户ID</span><br><span class="line">    gid_t         st_gid;       &#x2F;&#x2F;组ID</span><br><span class="line">    dev_t         st_rdev;      &#x2F;&#x2F;(设备类型)若此文件为设备文件，则为其设备编号</span><br><span class="line">    off_t         st_size;      &#x2F;&#x2F;文件字节数(文件大小)</span><br><span class="line">    blksize_t     st_blksize;   &#x2F;&#x2F;块大小(文件系统的I&#x2F;O 缓冲区大小)</span><br><span class="line">    blkcnt_t      st_blocks;    &#x2F;&#x2F;块数</span><br><span class="line">    time_t        st_atime;     &#x2F;&#x2F;最后一次访问时间</span><br><span class="line">    time_t        st_mtime;     &#x2F;&#x2F;最后一次修改时间</span><br><span class="line">    time_t        st_ctime;     &#x2F;&#x2F;最后一次改变时间(指属性)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>3、<strong>对于st_mode的解释</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如图可知，st_mode是一个16位的数，存储文件类型及访问权限。包含其他人的rwx分别占一位，所属组的rwx分别占一位，用户的rwx分别占一位，特殊权限位（暂时用不到）以及文件类型（一共7种）。</span><br></pre></td></tr></table></figure></div><p><a href="3_st_mode-1607760460706.png" data-fancybox="group" data-caption="3_st_mode" class="fancybox"><img alt="3_st_mode" title="3_st_mode" data-src="3_st_mode-1607760460706.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需要获取某种（其他人）权限的操作：</span><br><span class="line">获取其他人的读权限--&gt;用st_mode&amp;S_IWOTH</span><br><span class="line">获取其他人的rwx权限--&gt;用st_modes&amp;S_IRWXO</span><br><span class="line"></span><br><span class="line">其他操作同理</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212163201754.png" data-fancybox="group" data-caption="image-20201212163201754" class="fancybox"><img alt="image-20201212163201754" title="image-20201212163201754" data-src="image-20201212163201754.png" class="lazyload"></a></p><p>4、粘着位的作用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于以前电脑的系统内存比较小，当某个程序a.out正在执行时，第二个程序b.out也需执行，这时系统就会将两个程序的优先级进行比较，如果b.out的优先级高于a.out，则将a.out放入硬盘-交互分区，先执行b.out，b.out执行完毕后再将a.out从交换分区取出执行，若给a.out加上粘着位，则a.out就不会被放入交互分区。</span><br></pre></td></tr></table></figure></div><p><a href="4_%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4.png" data-fancybox="group" data-caption="4_交换空间" class="fancybox"><img alt="4_交换空间" title="4_交换空间" data-src="4_%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4.png" class="lazyload"></a></p><p>5、实现对文件大小的获取</p><p>stat.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out filename\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">//argv[0]指./stat这个可执行文件</span></span><br><span class="line">    <span class="comment">//argv[1]指传入的english.txt</span></span><br><span class="line">    <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"file size = %d\n"</span>, (<span class="keyword">int</span>)st.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc stat.c -o stat</span><br><span class="line">.&#x2F;stat english.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212171538197.png" data-fancybox="group" data-caption="image-20201212171538197" class="fancybox"><img alt="image-20201212171538197" title="image-20201212171538197" data-src="image-20201212171538197.png" class="lazyload"></a></p><p>6、对于软链接文件的读取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stat函数为穿透（追踪）函数---软链接</span><br><span class="line">即软链接对应于一个文件，stat读的是软链接指向的实际的文件而非软链接文件本身</span><br><span class="line"></span><br><span class="line">lstat函数为不穿透（不追踪）</span><br><span class="line">也就是读就是读的文件本身，不进行追踪</span><br><span class="line">（后续很多命令前加了l的对应的都是对一些软链接文件的操作）</span><br></pre></td></tr></table></figure></div><p><a href="5_%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%BD%E8%B8%AA.png" data-fancybox="group" data-caption="5_链接的追踪" class="fancybox"><img alt="5_链接的追踪" title="5_链接的追踪" data-src="5_%E9%93%BE%E6%8E%A5%E7%9A%84%E8%BF%BD%E8%B8%AA.png" class="lazyload"></a></p><h3 id="lstat函数"><a href="#lstat函数" class="headerlink" title="lstat函数"></a>lstat函数</h3><p>（不进行追踪）</p><p><strong>stat VS lstat</strong></p><p>修改之前的stat.c为lstat.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ret &#x3D; lstat(argv[1], &amp;st);</span><br></pre></td></tr></table></figure></div><p>相关命令：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建软链接：</span><br><span class="line">ln -s ~&#x2F;test&#x2F;Day5&#x2F;english.txt english.soft</span><br><span class="line">编译lstat.c:</span><br><span class="line">gcc lstat.c -o lstat</span><br><span class="line">执行stat:</span><br><span class="line">.&#x2F;stat english.soft</span><br><span class="line">执行lstat：</span><br><span class="line">.&#x2F;lstat english.soft</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212173406854.png" data-fancybox="group" data-caption="image-20201212173406854" class="fancybox"><img alt="image-20201212173406854" title="image-20201212173406854" data-src="image-20201212173406854.png" class="lazyload"></a></p><p>如图所示，可知stat具有穿透功能，而lstat不具有。</p><h3 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">作用：测试指定文件是否拥有某种权限</span><br><span class="line">原型：int access(const char *pathname, int mode);</span><br><span class="line">参数：</span><br><span class="line">pathname --&gt; 文件名</span><br><span class="line">mode --&gt; 权限类别</span><br><span class="line">R_OK 是否有读权限</span><br><span class="line">W_OK 是否有写权限</span><br><span class="line">X_OK 是否有执行权限</span><br><span class="line">F_OK 测试一个文件是否存在</span><br><span class="line">返回值：</span><br><span class="line">0 --&gt; 所有欲查核的权限都通过了检查</span><br><span class="line">-1 --&gt; 有权限被禁止</span><br></pre></td></tr></table></figure></div><p>access.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out filename\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = access(argv[<span class="number">1</span>],W_OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"access"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"you can write file\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc access.c -o access</span><br><span class="line">.&#x2F;access english.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212201911125.png" data-fancybox="group" data-caption="image-20201212201911125" class="fancybox"><img alt="image-20201212201911125" title="image-20201212201911125" data-src="image-20201212201911125.png" class="lazyload"></a></p><h3 id="chmod函数"><a href="#chmod函数" class="headerlink" title="chmod函数"></a>chmod函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">作用：改变文件的权限</span><br><span class="line">原型：int chmod( const char *filename, int pmode );</span><br><span class="line">参数：</span><br><span class="line">filename --&gt; 文件名</span><br><span class="line">pmode --&gt; 权限（必须是一个8进制数）</span><br><span class="line">返回值：</span><br><span class="line">0 --&gt; 改变成功</span><br><span class="line">-1 --&gt; 失败</span><br></pre></td></tr></table></figure></div><p>chmod.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out filename\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = chmod(argv[<span class="number">1</span>],<span class="number">0775</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"chmod"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>如何将字符串转换为8进制？</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 strtol</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212203100753.png" data-fancybox="group" data-caption="image-20201212203100753" class="fancybox"><img alt="image-20201212203100753" title="image-20201212203100753" data-src="image-20201212203100753.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>]=<span class="string">"12345"</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> a = strtol(buf,<span class="literal">NULL</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure></div><h3 id="chown函数"><a href="#chown函数" class="headerlink" title="chown函数"></a>chown函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：改变文件的所有者</span><br><span class="line">原型：int chown(const char *path, uid_t owner, gid_t group);</span><br><span class="line">返回值：</span><br><span class="line">0 --&gt; 成功</span><br><span class="line">-1 --&gt; 失败</span><br></pre></td></tr></table></figure></div><p>chown.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out filename\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = chown(argv[<span class="number">1</span>],<span class="number">116</span>,<span class="number">125</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"chown"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>如何获取uid和gid？</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;passwd</span><br><span class="line">前面的数字为uid，后面的为gid</span><br><span class="line">若要知道该文件的含义，在man的第五卷查找，命令为：man 5 passwd</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212203347918.png" data-fancybox="group" data-caption="image-20201212203347918" class="fancybox"><img alt="image-20201212203347918" title="image-20201212203347918" data-src="image-20201212203347918.png" class="lazyload"></a></p><h3 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作用：将参数path 指定的文件大小改为参数length 指定的大小。如果原来的文件大小比参数length大，则超过的部分会被删去。</span><br><span class="line">原型：int truncate(const char *path, off_t length);</span><br><span class="line">path --&gt; 文件路径</span><br><span class="line">length --&gt; 指定的文件大小</span><br><span class="line">   假设文件大小为100</span><br><span class="line">   第二个参数设置为20---》文件截断为20</span><br><span class="line">   第二个参数设置为300---》文件被拓展（多出来的以空洞方式展现）</span><br><span class="line">返回值：</span><br><span class="line">0 --&gt; 执行成功</span><br><span class="line">-1 --&gt; 执行失败</span><br></pre></td></tr></table></figure></div><p>truncate.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out filename 111\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> len = strtol(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">10</span>); </span><br><span class="line">    <span class="keyword">int</span>  aa = truncate(argv[<span class="number">1</span>], len);</span><br><span class="line">    <span class="keyword">if</span>(aa == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"truncate"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链接函数"><a href="#链接函数" class="headerlink" title="链接函数"></a>链接函数</h3><h4 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：创建一个硬链接</span><br><span class="line">原型：int link(const char *oldpath, const char *newpath);</span><br></pre></td></tr></table></figure></div><p>link.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out oldpath newpath\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = link(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"link"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：创建一个软连接</span><br><span class="line">原型：int symlink(const char *oldpath, const char *newpath);</span><br></pre></td></tr></table></figure></div><p>symlink.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out oldpath newpath\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = symlink(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"symlink"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：读软连接对应的文件名，不是读内容</span><br><span class="line">原型：ssize_t readlink(const char *path, char *buf, size_t bufsize);</span><br><span class="line">buf：存放软链接名</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out softlink\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = readlink(argv[<span class="number">1</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"readlink"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[ret] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="unlink函数"><a href="#unlink函数" class="headerlink" title="unlink函数"></a>unlink函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">删除一个文件的目录项并减少它的链接数，若成功则返回0，否则返回-1，错误原因存于errno。</span><br><span class="line">如果想通过调用这个函数来成功删除文件，你就必须拥有这个文件的所属目录的写和执行权限。</span><br><span class="line">原型：int symlink(const char *oldpath, const char *newpath);</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"tempfile"</span>, O_CREAT | O_RDWR, <span class="number">0755</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = unlink(<span class="string">"tempfile"</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"unlink"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"abc"</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//由于此时文件指针在末尾，读不出数据，故需要移动文件指针</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212212555131.png" data-fancybox="group" data-caption="image-20201212212555131" class="fancybox"><img alt="image-20201212212555131" title="image-20201212212555131" data-src="image-20201212212555131.png" class="lazyload"></a></p><p>由于在打开文件是无法将其删除，在文件关闭时又会立刻执行unlink将文件删除，所以为了证明临时文件tempfile存在过，往该文件中写入数据后打印到屏幕再将其关闭删除。</p><h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：文件重命名</span><br><span class="line">头文件：stdio.h</span><br><span class="line">函数原型：int rename(const char *oldpath, const char *newpath);</span><br></pre></td></tr></table></figure></div><h2 id="Linux目录操作相关函数"><a href="#Linux目录操作相关函数" class="headerlink" title="Linux目录操作相关函数"></a>Linux目录操作相关函数</h2><h3 id="chdir-amp-getcwd"><a href="#chdir-amp-getcwd" class="headerlink" title="chdir &amp; getcwd"></a>chdir &amp; getcwd</h3><p>（属于man 2）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chdir</span><br><span class="line">作用：修改当前进程路径</span><br><span class="line">函数原型：int chdir(const char *path);</span><br><span class="line"></span><br><span class="line">getcwd</span><br><span class="line">作用：获取当前进程工作目录</span><br><span class="line">函数原型：char *getcwd(char *buf, size_t size);</span><br></pre></td></tr></table></figure></div><p>chdir.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a.out dir\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变进程路径</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"chdir"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"chdir.txt"</span>, O_CREAT | O_RDWR, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//获取当前进程工作目录</span></span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current dir: %s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212215439883.png" data-fancybox="group" data-caption="image-20201212215439883" class="fancybox"><img alt="image-20201212215439883" title="image-20201212215439883" data-src="image-20201212215439883.png" class="lazyload"></a></p><h3 id="mkdir-amp-rmdir"><a href="#mkdir-amp-rmdir" class="headerlink" title="mkdir&amp;rmdir"></a>mkdir&amp;rmdir</h3><p>（属于man 2）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir</span><br><span class="line">作用：创建目录</span><br><span class="line">注意：创建的目录需要有执行权限，否则无法进入目录</span><br><span class="line">函数原型：int mkdir(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">rmdir</span><br><span class="line">作用：删除一个空目录</span><br><span class="line">函数原型：int rmdir(const char *pathname);</span><br></pre></td></tr></table></figure></div><h3 id="opendir-amp-readdir-amp-closedir"><a href="#opendir-amp-readdir-amp-closedir" class="headerlink" title="opendir&amp;readdir&amp;closedir"></a>opendir&amp;readdir&amp;closedir</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">opendir</span><br><span class="line">作用：打开一个目录</span><br><span class="line">函数原型：DIR *opendir(const char *name);</span><br><span class="line">返回值：</span><br><span class="line">  DIR结构指针，该结构是一个内部结构，保存所打开的目录信息，作用类似于FILE结构</span><br><span class="line">  函数出错返回 NULL</span><br><span class="line"></span><br><span class="line">readdir</span><br><span class="line">作用：读目录</span><br><span class="line">函数原型：struct dirent *readdir(DIR *dirp);</span><br><span class="line">返回值：</span><br><span class="line">  返回一条记录项</span><br><span class="line">        struct dirent</span><br><span class="line">        &#123;</span><br><span class="line">            ino_t d_ino;               &#x2F;&#x2F; 此目录进入点的inode</span><br><span class="line">            ff_t d_off;                &#x2F;&#x2F; 目录文件开头至此目录进入点的位移</span><br><span class="line">            signed short int d_reclen; &#x2F;&#x2F; d_name 的长度, 不包含NULL 字符</span><br><span class="line">            unsigned char d_type;      &#x2F;&#x2F; d_name 所指的文件类型 </span><br><span class="line">            har d_name[256];       &#x2F;&#x2F; 文件名</span><br><span class="line">        &#125;;</span><br><span class="line">        d_type：</span><br><span class="line">               DT_BLK - 块设备</span><br><span class="line">               DT_CHR - 字符设备</span><br><span class="line">               DT_DIR - 目录</span><br><span class="line">               DT_LNK - 软连接</span><br><span class="line">               DT_FIFO - 管道</span><br><span class="line">               DT_REG - 普通文件</span><br><span class="line">               DT_SOCK - 套接字</span><br><span class="line">               DT_UNKNOWN - 未知</span><br><span class="line">        -D_BSD_SOURCE 编译时添加宏定义</span><br><span class="line"></span><br><span class="line">closedir</span><br><span class="line">作用：关闭目录</span><br></pre></td></tr></table></figure></div><p>fileNum.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">char</span>* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR* dir = opendir(root);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"opendir"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读目录</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">ptr</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 跳过 . 和 ..</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">"."</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(ptr-&gt;d_name, <span class="string">".."</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是不是文件</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG)</span><br><span class="line">        &#123;</span><br><span class="line">            total ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 递归读目录</span></span><br><span class="line">            <span class="built_in">sprintf</span>(path, <span class="string">"%s/%s"</span>, root, ptr-&gt;d_name);</span><br><span class="line">            total += getFileNum(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读目录， 统计文件个数</span></span><br><span class="line">    <span class="keyword">int</span> total = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s has file number: %d\n"</span>, argv[<span class="number">1</span>], total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201212223807972.png" data-fancybox="group" data-caption="image-20201212223807972" class="fancybox"><img alt="image-20201212223807972" title="image-20201212223807972" data-src="image-20201212223807972.png" class="lazyload"></a></p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">作用：改变已经打开的文件的属性</span><br><span class="line">根据文件描述符来操作文件的状态 -- #include &lt;fcntl.h&gt;</span><br><span class="line">函数原型：</span><br><span class="line">int fcntl(int fd, int cmd);</span><br><span class="line">int fcntl(int fd, int cmd, long arg);</span><br><span class="line">int fcntl(int fd, int cmd, struct flock *lock);</span><br><span class="line">功能：</span><br><span class="line">复制一个现有的描述符 -- cmd：F_DUPFD</span><br><span class="line">获得／设置文件描述符标记 -- cmd：</span><br><span class="line">F_GETFD</span><br><span class="line">F_SETFD</span><br><span class="line">获得／设置文件状态标记 -- cmd：</span><br><span class="line">  F_GETFL：</span><br><span class="line">     只读打开 O_RDONLY</span><br><span class="line">     只写打开 O_WRONLY</span><br><span class="line">     读写打开 O_RDWR</span><br><span class="line">     执行打开 O_EXEC</span><br><span class="line">     搜索打开目录 O_SEARCH</span><br><span class="line">     追加写 O_APPEND</span><br><span class="line">     非阻塞模式 O_NONBLOCK</span><br><span class="line">  F_SETFL：可更改的几个标识：</span><br><span class="line">   O_APPEND</span><br><span class="line">   O_NONBLOCK</span><br><span class="line">获得／设置异步I&#x2F;O所有权 -- cmd：</span><br><span class="line">F_GETOWN</span><br><span class="line">F_SETOWN</span><br><span class="line">获得／设置记录锁 -- cmd：</span><br><span class="line">F_GETLK</span><br><span class="line">F_SETLK</span><br><span class="line">F_SETLKW</span><br></pre></td></tr></table></figure></div><p>fcntl.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试字符串</span></span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"I am a student of uestc\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> *q = <span class="string">"My name id lucky\n"</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只写的方式打开文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入新的内容，该部分会覆盖原来旧的内容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(fd, p, <span class="built_in">strlen</span>(p)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 F_GETFL 命令得到文件状态标志</span></span><br><span class="line">    flag = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fcntl"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件状态标志添加 ”追加写“ 选项</span></span><br><span class="line">    flag |= O_APPEND;</span><br><span class="line">    <span class="comment">// 将文件状态修改为追加写</span></span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, flag) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fcntl -- append write"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次输入新内容，该内容会追加到旧内容的后面</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(fd, q, <span class="built_in">strlen</span>(q)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"write again"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201213185915947.png" data-fancybox="group" data-caption="image-20201213185915947" class="fancybox"><img alt="image-20201213185915947" title="image-20201213185915947" data-src="image-20201213185915947.png" class="lazyload"></a></p><p><a href="image-20201213190312232.png" data-fancybox="group" data-caption="image-20201213190312232" class="fancybox"><img alt="image-20201213190312232" title="image-20201213190312232" data-src="image-20201213190312232.png" class="lazyload"></a></p><p>如图所示，第一次write为覆盖原文件进行写入，第二次由于改变了文件的状态故以追加的方式进行写入，不会对原内容进行覆盖。</p><h2 id="dup，dup2函数"><a href="#dup，dup2函数" class="headerlink" title="dup，dup2函数"></a>dup，dup2函数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：文件描述符的复制</span><br><span class="line"></span><br><span class="line">dup</span><br><span class="line">函数原型：int dup(int oldfd);</span><br><span class="line">注意：返回值和oldfd指的是同一个文件，返回值为未被占用的最小的索引</span><br><span class="line"></span><br><span class="line">dup2</span><br><span class="line">函数原型：int dup2(int oldfd, int newfd);</span><br><span class="line">注意：先将newfd关闭后，把文件描述符更新为newfd</span><br></pre></td></tr></table></figure></div><p>dup.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"a.txt"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"oldfd = %d\n"</span>, fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到进程文件描述表中 ==第一个== 可用的文件描述符</span></span><br><span class="line">    <span class="comment">// 将参数指定的文件复制到该描述符后，返回这个描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = dup(fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"dup"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"newfd = %d\n"</span>, ret);</span><br><span class="line">    <span class="keyword">char</span>* buf1 = <span class="string">"buf1\n"</span>;</span><br><span class="line">    <span class="keyword">char</span>* buf2 = <span class="string">"buf2\n"</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, buf1, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">write</span>(ret, buf2, <span class="built_in">strlen</span>(buf1));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201213164711468.png" data-fancybox="group" data-caption="image-20201213164711468" class="fancybox"><img alt="image-20201213164711468" title="image-20201213164711468" data-src="image-20201213164711468.png" class="lazyload"></a></p><p>如图所示，可以证明文件指针只有一个，第一次写操作完成后，文件指针后移，之后接着将第二个文件描述符作为参数传入，继续进行写操作，并且证明两个文件描述符都指向同一个文件。</p><p>dup2.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="built_in">open</span>(<span class="string">"a.txt"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2 = <span class="built_in">open</span>(<span class="string">"b.txt"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd1 = %d\n"</span>, fd1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd2 = %d\n"</span>, fd2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = dup2(fd1, fd2);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"dup2"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(fd1, <span class="string">"Hello "</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">write</span>(fd2, <span class="string">"World!\n"</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201213165857478.png" data-fancybox="group" data-caption="image-20201213165857478" class="fancybox"><img alt="image-20201213165857478" title="image-20201213165857478" data-src="image-20201213165857478.png" class="lazyload"></a></p><p>如图所示，fd1指的是a.txt，fd2指的是b.txt，执行dup2后，fd2被关闭也就是b.txt被关闭，fd1和fd2都指向a.txt，所以两次write操作其实都是对a.txt的操作。(注意：写操作是在原来文件上覆盖，而不是先清空)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux文件操作相关函数&quot;&gt;&lt;a href=&quot;#Linux文件操作相关函数&quot; class=&quot;headerlink&quot; title=&quot;Linux文件操作相关函数&quot;&gt;&lt;/a&gt;Linux文件操作相关函数&lt;/h2&gt;&lt;p&gt;（这些函数都有对应的命令）&lt;/p&gt;
&lt;h3 id=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发一-基础/Day4/Day4</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day4/Day4/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day4/Day4/</id>
    <published>2021-01-30T07:20:25.261Z</published>
    <updated>2020-12-12T08:02:10.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GDB（GNU Debugger）是GCC的调试工具。其功能强大，现描述如下：</span><br><span class="line">GDB主要帮忙你完成下面四个方面的功能：</span><br><span class="line">1.启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</span><br><span class="line">2.可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</span><br><span class="line">3.当程序被停住时，可以检查此时你的程序中所发生的事。</span><br><span class="line">4.动态的改变你程序的执行环境。</span><br></pre></td></tr></table></figure></div><h3 id="生成调试信息"><a href="#生成调试信息" class="headerlink" title="生成调试信息"></a>生成调试信息</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般来说GDB主要调试的是C&#x2F;C++的程序。要调试C&#x2F;C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc&#x2F;gcc&#x2F;g++）的 -g 参数可以做到这一点。如：</span><br><span class="line">    gcc -g hello.c -o hello</span><br><span class="line">    g++ -g hello.cpp -o hello</span><br><span class="line">    如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。</span><br></pre></td></tr></table></figure></div><h3 id="启动GDB"><a href="#启动GDB" class="headerlink" title="启动GDB"></a>启动GDB</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb app （app为执行文件）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206221235300.png" data-fancybox="group" data-caption="image-20201206221235300" class="fancybox"><img alt="image-20201206221235300" title="image-20201206221235300" data-src="image-20201206221235300.png" class="lazyload"></a></p><p>对比没加-g和加了-g的执行文件的大小，加了-g的包含的调试信息</p><p><a href="image-20201206222208258.png" data-fancybox="group" data-caption="image-20201206222208258" class="fancybox"><img alt="image-20201206222208258" title="image-20201206222208258" data-src="image-20201206222208258.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start：只执行一行代码</span><br><span class="line">run&#x2F;r：直接执行停在断点处</span><br><span class="line">运行前记得打断点，否则直接运行完毕</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next&#x2F;n---&gt;单步执行</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206224359816.png" data-fancybox="group" data-caption="image-20201206224359816" class="fancybox"><img alt="image-20201206224359816" title="image-20201206224359816" data-src="image-20201206224359816.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue&#x2F;c---&gt;继续运行程序，停在下一个断点</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">step&#x2F;s---&gt;单步跟踪，函数调进入被调用函数体内</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206224744734.png" data-fancybox="group" data-caption="image-20201206224744734" class="fancybox"><img alt="image-20201206224744734" title="image-20201206224744734" data-src="image-20201206224744734.png" class="lazyload"></a></p><h3 id="查看程序源代码"><a href="#查看程序源代码" class="headerlink" title="查看程序源代码"></a>查看程序源代码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l----&gt;默认显示包含main函数的文件（默认每次10行）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206222455337.png" data-fancybox="group" data-caption="image-20201206222455337" class="fancybox"><img alt="image-20201206222455337" title="image-20201206222455337" data-src="image-20201206222455337.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l + 查看文件名 ：行号</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206222743817.png" data-fancybox="group" data-caption="image-20201206222743817" class="fancybox"><img alt="image-20201206222743817" title="image-20201206222743817" data-src="image-20201206222743817.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l + 文件名 ： 函数名</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206222840519.png" data-fancybox="group" data-caption="image-20201206222840519" class="fancybox"><img alt="image-20201206222840519" title="image-20201206222840519" data-src="image-20201206222840519.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1、继续按l就是查看后续代码内容</span><br><span class="line">2、直接回车代表执行上一条操作</span><br></pre></td></tr></table></figure></div><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b---break  设置断点，可以简写为b</span><br><span class="line">b 10   设置断点，在源程序第10行</span><br><span class="line">b func 设置断点，在func函数入口处</span><br><span class="line">b fileName：行号（函数名）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206223238791.png" data-fancybox="group" data-caption="image-20201206223238791" class="fancybox"><img alt="image-20201206223238791" title="image-20201206223238791" data-src="image-20201206223238791.png" class="lazyload"></a></p><p>设置条件断点：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b 5 if i&#x3D;&#x3D;5</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206224228360.png" data-fancybox="group" data-caption="image-20201206224228360" class="fancybox"><img alt="image-20201206224228360" title="image-20201206224228360" data-src="image-20201206224228360.png" class="lazyload"></a></p><p>删除断点：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete---del---d</span><br><span class="line">d 断点编号</span><br></pre></td></tr></table></figure></div><p>获取断点编号：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info&#x2F;i b查看断点信息</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206224256216.png" data-fancybox="group" data-caption="image-20201206224256216" class="fancybox"><img alt="image-20201206224256216" title="image-20201206224256216" data-src="image-20201206224256216.png" class="lazyload"></a></p><h3 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h3><p>进入函数体内部：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s</span><br></pre></td></tr></table></figure></div><p>从函数体内部跳出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">finish</span><br><span class="line">注意：查看是否在循环体内打了断点，去掉才能跳出函数体</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207150155688.png" data-fancybox="group" data-caption="image-20201207150155688" class="fancybox"><img alt="image-20201207150155688" title="image-20201207150155688" data-src="image-20201207150155688.png" class="lazyload"></a></p><p>不进入函数体内部：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n</span><br></pre></td></tr></table></figure></div><p>退出当前循环：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207145651414.png" data-fancybox="group" data-caption="image-20201207145651414" class="fancybox"><img alt="image-20201207145651414" title="image-20201207145651414" data-src="image-20201207145651414.png" class="lazyload"></a></p><h3 id="查看变量的值"><a href="#查看变量的值" class="headerlink" title="查看变量的值"></a>查看变量的值</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print 打印变量、字符串、表达式等的值，可简写为p</span><br><span class="line">p count 打印count的值</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206225156486.png" data-fancybox="group" data-caption="image-20201206225156486" class="fancybox"><img alt="image-20201206225156486" title="image-20201206225156486" data-src="image-20201206225156486.png" class="lazyload"></a></p><h3 id="查看变量的类型"><a href="#查看变量的类型" class="headerlink" title="查看变量的类型"></a>查看变量的类型</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptype 查看变量类型</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206225240149.png" data-fancybox="group" data-caption="image-20201206225240149" class="fancybox"><img alt="image-20201206225240149" title="image-20201206225240149" data-src="image-20201206225240149.png" class="lazyload"></a></p><h3 id="设置变量的值"><a href="#设置变量的值" class="headerlink" title="设置变量的值"></a>设置变量的值</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set var i&#x3D;10</span><br><span class="line">相当于for循环已经循环了10次</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207150421494.png" data-fancybox="group" data-caption="image-20201207150421494" class="fancybox"><img alt="image-20201207150421494" title="image-20201207150421494" data-src="image-20201207150421494.png" class="lazyload"></a></p><h3 id="设置追踪变量"><a href="#设置追踪变量" class="headerlink" title="设置追踪变量"></a>设置追踪变量</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display i</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206225440760.png" data-fancybox="group" data-caption="image-20201206225440760" class="fancybox"><img alt="image-20201206225440760" title="image-20201206225440760" data-src="image-20201206225440760.png" class="lazyload"></a></p><p>取消追踪变量：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undisplay i（编号）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207145533852.png" data-fancybox="group" data-caption="image-20201207145533852" class="fancybox"><img alt="image-20201207145533852" title="image-20201207145533852" data-src="image-20201207145533852.png" class="lazyload"></a></p><p>获取编号：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info display  查看追踪变量信息</span><br></pre></td></tr></table></figure></div><p><a href="image-20201206225707558.png" data-fancybox="group" data-caption="image-20201206225707558" class="fancybox"><img alt="image-20201206225707558" title="image-20201206225707558" data-src="image-20201206225707558.png" class="lazyload"></a></p><h3 id="退出GDB调试"><a href="#退出GDB调试" class="headerlink" title="退出GDB调试"></a>退出GDB调试</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit&#x2F;q</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207150521207.png" data-fancybox="group" data-caption="image-20201207150521207" class="fancybox"><img alt="image-20201207150521207" title="image-20201207150521207" data-src="image-20201207150521207.png" class="lazyload"></a></p><h2 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h2><h3 id="makefile的命名"><a href="#makefile的命名" class="headerlink" title="makefile的命名"></a>makefile的命名</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Makefile&#x2F;makefile</span><br></pre></td></tr></table></figure></div><h3 id="makefile的规则"><a href="#makefile的规则" class="headerlink" title="makefile的规则"></a>makefile的规则</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">规则中的三要素: 目标，依赖，命令</span><br><span class="line">目标：依赖条件</span><br><span class="line">命令</span><br><span class="line">1、第一条规则是用来生成终极目标的规则</span><br><span class="line">1&gt;、如果规则中的依赖不存在，向下寻找其他规则</span><br><span class="line">2&gt;、更新机制：比较的是目标文件和依赖文件的时间</span><br><span class="line"></span><br><span class="line">子目标和终极目标的关系:</span><br><span class="line">更新目标的原则:</span><br></pre></td></tr></table></figure></div><p>makefile基本原则：</p><p><a href="1_makefile%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99.png" data-fancybox="group" data-caption="1_makefile基本原则" class="fancybox"><img alt="1_makefile基本原则" title="1_makefile基本原则" data-src="1_makefile%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99.png" class="lazyload"></a></p><h4 id="makefile01"><a href="#makefile01" class="headerlink" title="makefile01"></a><strong>makefile01</strong></h4><p>（其中的.c、.h文件在上一篇Day3中给出自取）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app:main.c add.c sub.c mul.c div.c</span><br><span class="line">gcc main.c add.c sub.c mul.c div.c -o app</span><br><span class="line"></span><br><span class="line">app---目标</span><br><span class="line">*.c---依赖</span><br><span class="line">gcc main.c add.c sub.c mul.c div.c -o app---命令</span><br></pre></td></tr></table></figure></div><p>执行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207221500577.png" data-fancybox="group" data-caption="image-20201207221500577" class="fancybox"><img alt="image-20201207221500577" title="image-20201207221500577" data-src="image-20201207221500577.png" class="lazyload"></a></p><p>缺点：每执行一次就把所有的文件重新编译，浪费时间</p><h4 id="makefile02"><a href="#makefile02" class="headerlink" title="makefile02"></a><strong>makefile02</strong></h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app:main.o add.o sub.o mul.o div.o</span><br><span class="line">gcc main.o add.o sub.o mul.o div.o -o app</span><br><span class="line">main.o:main.c</span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line">add.o:add.c</span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">sub.o:sub.c</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">mul.o:mul.c</span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line">div.o:div.c</span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app---终极目标</span><br><span class="line">*.o---子目标（与依赖有关，为生成依赖而服务的）</span><br><span class="line">执行过程：发现没有main.o等依赖时就向下寻找生成依赖的规则</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207222607769.png" data-fancybox="group" data-caption="image-20201207222607769" class="fancybox"><img alt="image-20201207222607769" title="image-20201207222607769" data-src="image-20201207222607769.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看*.o对应的生成时间：ls -l *.o</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207222738071.png" data-fancybox="group" data-caption="image-20201207222738071" class="fancybox"><img alt="image-20201207222738071" title="image-20201207222738071" data-src="image-20201207222738071.png" class="lazyload"></a></p><p>证明该改进版的makefile不会重复编译：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、将其中一个函数修改，比如add.c</span><br><span class="line">2、make执行看对应的执行命令</span><br><span class="line">（如图可知，</span><br></pre></td></tr></table></figure></div><p><a href="image-20201207223032603.png" data-fancybox="group" data-caption="image-20201207223032603" class="fancybox"><img alt="image-20201207223032603" title="image-20201207223032603" data-src="image-20201207223032603.png" class="lazyload"></a></p><p>makefile工作原理：</p><p><a href="2_makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1.png" data-fancybox="group" data-caption="2_makefile工作原理-1" class="fancybox"><img alt="2_makefile工作原理-1" title="2_makefile工作原理-1" data-src="2_makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1.png" class="lazyload"></a></p><p><a href="3_makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2.png" data-fancybox="group" data-caption="3_makefile工作原理-2" class="fancybox"><img alt="3_makefile工作原理-2" title="3_makefile工作原理-2" data-src="3_makefile%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2.png" class="lazyload"></a></p><p>解释：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">若想生成目标，检查规则中的依赖条件是否存在，如果不存在，寻找是否有规则用来生成该依赖文件</span><br><span class="line"></span><br><span class="line">检查规则中的目标是否需要更新，必须检查它的所有依赖，依赖中有任意一个被更新，则目标必须更新</span><br><span class="line">(依赖文件比目标文件时间晚，则需要更新)</span><br></pre></td></tr></table></figure></div><p>由于代码中存在大量的冗余，故将其设置为变量的形式</p><h4 id="makefile03"><a href="#makefile03" class="headerlink" title="makefile03"></a><strong>makefile03</strong></h4><p>普通变量：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">变量定义及赋值：obj &#x3D; a.o b.o c.o</span><br><span class="line">变量取值：foo &#x3D; $(obj)</span><br><span class="line">由 Makefile 维护的一些变量（通常格式都是大写）：</span><br><span class="line">1、有默认值变量</span><br><span class="line">CC：默认值 cc</span><br><span class="line">2、无默认值变量</span><br><span class="line">CPPFLAGS : 预处理器需要的选项 如：-I</span><br><span class="line">CFLAGS：编译的时候使用的参数 –Wall –g -c</span><br><span class="line">LDFLAGS ：链接库使用的选项 –L -l</span><br><span class="line">注：用户可以修改这些变量的默认值，例如：CC &#x3D; gcc</span><br></pre></td></tr></table></figure></div><p>自动变量：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">变量：</span><br><span class="line">（只能用于命令中）</span><br><span class="line">$@ --&gt; 规则中的目标</span><br><span class="line">$&lt; --&gt; 规则中的第一个依赖条件</span><br><span class="line">$^ --&gt; 规则中的所有依赖条件</span><br><span class="line">模式规则：</span><br><span class="line">在规则的目标定义中使用 %（%表示一个或多个）</span><br><span class="line">在规则的依赖条件中使用 %</span><br><span class="line">示例：</span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) –c  $&lt; -o $@</span><br><span class="line">（$&lt; --&gt; 表示依次取出依赖条件、$@ --&gt; 表示依次取出目标值）</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj&#x3D;main.o add.o sub.o mul.o div.o</span><br><span class="line">target&#x3D;app</span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CPPFLAGS&#x3D;-I</span><br><span class="line">$(target):$(obj)</span><br><span class="line">$(CC) $(obj) -o $(target)</span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) -c $&lt; -o $@</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208200904781.png" data-fancybox="group" data-caption="image-20201208200904781" class="fancybox"><img alt="image-20201208200904781" title="image-20201208200904781" data-src="image-20201208200904781.png" class="lazyload"></a></p><h4 id="makefile04"><a href="#makefile04" class="headerlink" title="makefile04"></a><strong>makefile04</strong></h4><p>makefile中的函数：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wildcard：查找指定目录下指定类型的文件并返回</span><br><span class="line">src&#x3D;$(wildcard ~&#x2F;aa&#x2F;*.c)</span><br><span class="line">例如：返回main.c add.c sub.c mul.c div.c</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patsubst：匹配替换函数</span><br><span class="line">obj&#x3D;$(patsubst %.c,%.o,$(src))</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">target&#x3D;app</span><br><span class="line">#函数</span><br><span class="line">src&#x3D;$(wildcard .&#x2F;*.c)</span><br><span class="line">obj&#x3D;$(patsubst .&#x2F;%.c,.&#x2F;%.o,$(src))</span><br><span class="line">CC&#x3D;gcc</span><br><span class="line">CPPFLAGS&#x3D;-I</span><br><span class="line">$(target):$(obj)</span><br><span class="line">$(CC) $(obj) -o $(target)</span><br><span class="line">%.o:%.c</span><br><span class="line">$(CC) -c $&lt; -o $@</span><br><span class="line">clean:</span><br><span class="line">rm $(obj) $(target)</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208210402311.png" data-fancybox="group" data-caption="image-20201208210402311" class="fancybox"><img alt="image-20201208210402311" title="image-20201208210402311" data-src="image-20201208210402311.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208210700335.png" data-fancybox="group" data-caption="image-20201208210700335" class="fancybox"><img alt="image-20201208210700335" title="image-20201208210700335" data-src="image-20201208210700335.png" class="lazyload"></a></p><p>注意：要执行最后一句clean（伪目标），则在命令行输入make clean，之前的命令不会被执行，若只是执行make则依次从上到下执行，不会生成clean</p><p>解决无待删除文件时，执行make clean执行错误：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm $(obj) $(target) -f</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208211109249.png" data-fancybox="group" data-caption="image-20201208211109249" class="fancybox"><img alt="image-20201208211109249" title="image-20201208211109249" data-src="image-20201208211109249.png" class="lazyload"></a></p><p>解决在clean目标存在时，无法执行make clean情况：</p><p><a href="image-20201208211318771.png" data-fancybox="group" data-caption="image-20201208211318771" class="fancybox"><img alt="image-20201208211318771" title="image-20201208211318771" data-src="image-20201208211318771.png" class="lazyload"></a></p><p>将clean设置为伪目标，使得目录下的clean与makefile中的clean没有关系</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">rm $(obj) $(target) -f</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208211550016.png" data-fancybox="group" data-caption="image-20201208211550016" class="fancybox"><img alt="image-20201208211550016" title="image-20201208211550016" data-src="image-20201208211550016.png" class="lazyload"></a></p><p>解决命令执行失败后续命令无法执行的情况：</p><p><a href="image-20201208211923086.png" data-fancybox="group" data-caption="image-20201208211923086" class="fancybox"><img alt="image-20201208211923086" title="image-20201208211923086" data-src="image-20201208211923086.png" class="lazyload"></a></p><p><a href="image-20201208212138415.png" data-fancybox="group" data-caption="image-20201208212138415" class="fancybox"><img alt="image-20201208212138415" title="image-20201208212138415" data-src="image-20201208212138415.png" class="lazyload"></a></p><p>在rm命令上添加命令，该命令会出错，由于普通用户无权限在根目录下创建目录，后续命令也无法执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">-mkdir &#x2F;aa   ----&gt;加“-”表示执行错误忽略该命令继续执行</span><br><span class="line">rm $(obj) $(target) -f</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208212244175.png" data-fancybox="group" data-caption="image-20201208212244175" class="fancybox"><img alt="image-20201208212244175" title="image-20201208212244175" data-src="image-20201208212244175.png" class="lazyload"></a></p><p>执行成功，app和*.o被成功删除</p><h2 id="系统IO函数"><a href="#系统IO函数" class="headerlink" title="系统IO函数"></a>系统IO函数</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><h4 id="C库函的IO缓冲区"><a href="#C库函的IO缓冲区" class="headerlink" title="C库函的IO缓冲区"></a>C库函的IO缓冲区</h4><p>在图中，除了fopen以外的C库函数的形参中都有一个FILE*类型的指针，该指针对应一个结构体，里面有文件描述符（对应磁盘上的文件）、文件读写指针位置（若不关闭文件，继续读文件，默认在文件末尾故读不到，所有时刻注意指针位置）以及I/O缓冲区（提高读写速度，以免每次都需要进行对硬盘的读写操作，一次性将缓冲区数据刷到硬盘上）。 </p><p>C库I/O函数工作流程</p><p><a href="4_C%E5%BA%93IO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" data-fancybox="group" data-caption="4_C库IO函数工作流程" class="fancybox"><img alt="4_C库IO函数工作流程" title="4_C库IO函数工作流程" data-src="4_C%E5%BA%93IO%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="lazyload"></a></p><h4 id="PCB和文件描述符"><a href="#PCB和文件描述符" class="headerlink" title="PCB和文件描述符"></a>PCB和文件描述符</h4><p>Linux每运行一个进程就分配一个地址空间，0-3G为用户区，3G-4G为内核区（用户不能操作），在内核区有一个PCB进程控制块，里面有一个1024大小的数组，每打开一个新文件就在文件描述符表中占用一个位置，前三个已经被占用，例如：3、4、5被占用，关闭上，再打开一个文件则占用关闭的位置3。</p><p><a href="5_pcb%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" data-fancybox="group" data-caption="5_pcb和文件描述符" class="fancybox"><img alt="5_pcb和文件描述符" title="5_pcb和文件描述符" data-src="5_pcb%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" class="lazyload"></a></p><p><a href="6_%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" data-fancybox="group" data-caption="6_虚拟地址空间" class="fancybox"><img alt="6_虚拟地址空间" title="6_虚拟地址空间" data-src="6_%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看文件类型：</span><br><span class="line">file app</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208220529641.png" data-fancybox="group" data-caption="image-20201208220529641" class="fancybox"><img alt="image-20201208220529641" title="image-20201208220529641" data-src="image-20201208220529641.png" class="lazyload"></a></p><p>可知，可执行文件是一个ELF类型的文件，全局变量如果被初始化一定不为0，如果赋值为0也被认为是未初始化全局变量（局部变量未初始化值不一定）。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cpu 为什么要使用虚拟地址空间与物理地址空间映射？解决了什么样的问题？</span><br><span class="line"></span><br><span class="line">1.方便编译器和操作系统安排程序的地址分布。</span><br><span class="line">程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。（解决不连续缓冲区的问题）</span><br><span class="line"></span><br><span class="line">2.方便进程之间隔离</span><br><span class="line">不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存。</span><br><span class="line"></span><br><span class="line">3.方便OS使用你那可怜的内存。</span><br><span class="line">程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</span><br></pre></td></tr></table></figure></div><p>注意：虚拟出来的4G空间并不意味着内存少4G，而是程序运行实际需要占用多少才会少多少，只是说至多少4G。</p><h4 id="库函数与系统函数的关系"><a href="#库函数与系统函数的关系" class="headerlink" title="库函数与系统函数的关系"></a>库函数与系统函数的关系</h4><p><a href="7_%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB.png" data-fancybox="group" data-caption="7_库函数与系统函数的关系" class="fancybox"><img alt="7_库函数与系统函数的关系" title="7_库函数与系统函数的关系" data-src="7_%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q：printf是如何将字符串显示到屏幕上的？</span><br><span class="line">A：printf是一个库函数，不可能直接调用硬件，而是一层一层往下调用，首先C函数会维护一个FILE*，其中包含文件描述符、文件读写指针和缓冲区，缓冲区存放着要打印输出的内容；之后向下调用Linux系统API，包含三层，应用层、系统调用和内核层，应用层的函数操作的是虚拟地址空间的用户区（0-3G），应用层的write函数拿到了文件描述符、字符串以及字符长度；sys_write()再去调用显示器的驱动，显示字符串。</span><br></pre></td></tr></table></figure></div><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>查看系统函数的man文档</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 open</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208223641321.png" data-fancybox="group" data-caption="image-20201208223641321" class="fancybox"><img alt="image-20201208223641321" title="image-20201208223641321" data-src="image-20201208223641321.png" class="lazyload"></a></p><p><strong>函数参数</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用open函数所需的头文件，以及函数的参数设置</span><br><span class="line">如果文件已经存在，则用第一种两个参数的函数；</span><br><span class="line">如果文件不存在，则用第二种三个参数的函数；</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208224115287.png" data-fancybox="group" data-caption="image-20201208224115287" class="fancybox"><img alt="image-20201208224115287" title="image-20201208224115287" data-src="image-20201208224115287.png" class="lazyload"></a></p><p><strong>打开方式</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中flag必须有O_RDONLY、O_WRONLY、O_RDWR，且这三个互斥，也可以追加如O_CREAT、O_DIRECTORY等，例如文件不存在时需要追加O_CREAT</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208224325511.png" data-fancybox="group" data-caption="image-20201208224325511" class="fancybox"><img alt="image-20201208224325511" title="image-20201208224325511" data-src="image-20201208224325511.png" class="lazyload"></a></p><p><strong>函数返回值</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于函数的返回值，函数返回其对应的文件描述符，若出错则返回-1</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208224601149.png" data-fancybox="group" data-caption="image-20201208224601149" class="fancybox"><img alt="image-20201208224601149" title="image-20201208224601149" data-src="image-20201208224601149.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并且有一个errno（全局变量）也被设置，是记录系统的最后一次错误代码。代码是一个int型的值。</span><br><span class="line">每个errno值对应着以字符串表示的错误类型</span><br><span class="line">当调用&quot;某些&quot;函数出错时，该函数会重新设置 errno 的值</span><br></pre></td></tr></table></figure></div><p>如何使用errno？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若需使用errno的值，需包含errno.h这个头文件（位于&#x2F;usr&#x2F;include&#x2F;errno.h)，extern声明证明该int型变量是一个全局变量。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201208225412038.png" data-fancybox="group" data-caption="image-20201208225412038" class="fancybox"><img alt="image-20201208225412038" title="image-20201208225412038" data-src="image-20201208225412038.png" class="lazyload"></a></p><h4 id="open函数的使用01"><a href="#open函数的使用01" class="headerlink" title="open函数的使用01"></a>open函数的使用01</h4><p>1、打开一个不存在的文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//打开不存在文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"not exit"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201209102148487.png" data-fancybox="group" data-caption="image-20201209102148487" class="fancybox"><img alt="image-20201209102148487" title="image-20201209102148487" data-src="image-20201209102148487.png" class="lazyload"></a></p><p>2、打开已存在文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touch hello.c</span><br><span class="line"></span><br><span class="line">修改myopen.c</span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"hello.c"</span>,O_RDWR);</span><br></pre></td></tr></table></figure></div><p><a href="image-20201209102552340.png" data-fancybox="group" data-caption="image-20201209102552340" class="fancybox"><img alt="image-20201209102552340" title="image-20201209102552340" data-src="image-20201209102552340.png" class="lazyload"></a></p><p>3、创建一个不存在文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//打开不存在文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>,O_RDWR | O_CREAT,<span class="number">0777</span>);</span><br><span class="line">    <span class="comment">//权限全开</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>创建文件成功！</p><p>代码中设置文件权限全开，查看文件实际权限</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l text.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201209105228786.png" data-fancybox="group" data-caption="image-20201209105228786" class="fancybox"><img alt="image-20201209105228786" title="image-20201209105228786" data-src="image-20201209105228786.png" class="lazyload"></a></p><p>解释：如图文件权限并不是777，是因为文件本身有一个权限，文件实际权限是给定权限与本地掩码（取反）相与的结果。</p><p>打开方式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">必选项:</span><br><span class="line">O_RDONLY</span><br><span class="line">O_WRONLY</span><br><span class="line">O_RDWR</span><br><span class="line">可选项:</span><br><span class="line">O_CREAT</span><br><span class="line">            文件权限: 本地有一个掩码</span><br><span class="line">            文件的实际权限:</span><br><span class="line">            给定的权限</span><br><span class="line">            本地掩码(取反)</span><br><span class="line">           &amp;</span><br><span class="line">            实际的文件权限</span><br><span class="line">            777</span><br><span class="line">            111111111</span><br><span class="line">            111111101</span><br><span class="line">            111111101</span><br><span class="line">            775</span><br><span class="line"></span><br><span class="line">O_TRUNC</span><br><span class="line">O_EXCL</span><br><span class="line">O_APPEND</span><br></pre></td></tr></table></figure></div><h4 id="open函数的使用02"><a href="#open函数的使用02" class="headerlink" title="open函数的使用02"></a>open函数的使用02</h4><p>1、判断文件是否存在</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O_CREAT | O_EXCL必须一同使用才能进行判断</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incude<span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">//打开不存在文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test.txt"</span>,O_RDWR | O_CREAT | O_EXCL,<span class="number">0777</span>);</span><br><span class="line">    <span class="comment">//权限全开</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//关闭当前进程</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ret=%d\n"</span>,ret);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open file"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201209110218326.png" data-fancybox="group" data-caption="image-20201209110218326" class="fancybox"><img alt="image-20201209110218326" title="image-20201209110218326" data-src="image-20201209110218326.png" class="lazyload"></a></p><p>如图，第二次执行./app时，由于text.txt已经存在，故给出已存在提示。</p><p>读写大文件两种方式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read write --- 每次读1byte</span><br><span class="line">getc putc ---- 每次读一个byte -- 效率高</span><br><span class="line">（因为标准C库函数，内部有一个缓冲区）</span><br><span class="line"></span><br><span class="line">解释：调用c库函数时，每次先将数据缓冲在用户区，写满时，再一次性将缓冲区数据放入内核区，然后内核区再调用硬件设备写到磁盘；</span><br><span class="line">调用系统函数时，是写一个bit就进行一次用户区到内核区的切换，转换的速度很慢，故效率低。</span><br><span class="line">内核区也维护了一个缓冲区，将缓冲区一次性刷到磁盘，时间适当节省。</span><br></pre></td></tr></table></figure></div><p><a href="image-20201211092653480.png" data-fancybox="group" data-caption="image-20201211092653480" class="fancybox"><img alt="image-20201211092653480" title="image-20201211092653480" data-src="image-20201211092653480.png" class="lazyload"></a></p><h3 id="read-amp-write"><a href="#read-amp-write" class="headerlink" title="read&amp;write"></a>read&amp;write</h3><p>1、查看read的man文档</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 read</span><br></pre></td></tr></table></figure></div><p><a href="image-20201209110520228.png" data-fancybox="group" data-caption="image-20201209110520228" class="fancybox"><img alt="image-20201209110520228" title="image-20201209110520228" data-src="image-20201209110520228.png" class="lazyload"></a></p><p>2、read函数返回值</p><p><a href="image-20201209110555570.png" data-fancybox="group" data-caption="image-20201209110555570" class="fancybox"><img alt="image-20201209110555570" title="image-20201209110555570" data-src="image-20201209110555570.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. -1 读文件失败（同时设置errno）</span><br><span class="line">2. 0 文件读完了</span><br><span class="line">3. &gt;0 读取的字节数</span><br></pre></td></tr></table></figure></div><p>3、查看write的man文档</p><p><a href="image-20201209110910083.png" data-fancybox="group" data-caption="image-20201209110910083" class="fancybox"><img alt="image-20201209110910083" title="image-20201209110910083" data-src="image-20201209110910083.png" class="lazyload"></a></p><p> 4、操练</p><p>read_write.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//open file</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"english.txt"</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd1 = <span class="built_in">open</span>(<span class="string">"newfile"</span>,O_CREAD | O_WRONLY,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open1()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> bud[<span class="number">2048</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"read()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">write</span>(fd1,buf,count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write bytes %d\n"</span>,ret);</span><br><span class="line">        count = <span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc read_write.c -o readwrite</span><br><span class="line">ls</span><br><span class="line">.&#x2F;readwrite</span><br><span class="line">ls -l newfile english.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201211101216193.png" data-fancybox="group" data-caption="image-20201211101216193" class="fancybox"><img alt="image-20201211101216193" title="image-20201211101216193" data-src="image-20201211101216193.png" class="lazyload"></a></p><p><a href="image-20201211101302972.png" data-fancybox="group" data-caption="image-20201211101302972" class="fancybox"><img alt="image-20201211101302972" title="image-20201211101302972" data-src="image-20201211101302972.png" class="lazyload"></a></p><p>如图，文件大小一样，读写成功。其中的perror，每次在错误发生时，系统会去修改全局变量errno的值，perror每次就会去读取errno的值，找寻对应的错误信息打印。</p><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h3><p>功能：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 获取文件大小</span><br><span class="line">2. 移动文件指针</span><br><span class="line">3. 文件拓展</span><br></pre></td></tr></table></figure></div><p>查看lssek的man文档：</p><p><a href="image-20201209111100770.png" data-fancybox="group" data-caption="image-20201209111100770" class="fancybox"><img alt="image-20201209111100770" title="image-20201209111100770" data-src="image-20201209111100770.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"english.txt"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"open()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret1 = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"file length = %d\n"</span>,ret1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret2 = lseek(fd,<span class="number">2000</span>,SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"return value:%d\n"</span>,ret2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>(fd,<span class="string">"a"</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201211103523527.png" data-fancybox="group" data-caption="image-20201211103523527" class="fancybox"><img alt="image-20201211103523527" title="image-20201211103523527" data-src="image-20201211103523527.png" class="lazyload"></a></p><p><a href="image-20201211103544889.png" data-fancybox="group" data-caption="image-20201211103544889" class="fancybox"><img alt="image-20201211103544889" title="image-20201211103544889" data-src="image-20201211103544889.png" class="lazyload"></a></p><p>如图可知，english.txt的大小从129030–&gt;131031，因为需要用lseek拓展文件成功需要最后在最后进行写操作，多写了一个a字符，所以字符数增加了2001。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GDB调试&quot;&gt;&lt;a href=&quot;#GDB调试&quot; class=&quot;headerlink&quot; title=&quot;GDB调试&quot;&gt;&lt;/a&gt;GDB调试&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发一-基础/Day3/Day3</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day3/Day3/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day3/Day3/</id>
    <published>2021-01-30T07:20:25.022Z</published>
    <updated>2020-12-05T08:47:35.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>是一个文本编辑程序，没有菜单栏，只有命令，且命令繁多</p><p>vim是从vi发展过来的一款文本编辑器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi a.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130101153609.png" data-fancybox="group" data-caption="image-20201130101153609" class="fancybox"><img alt="image-20201130101153609" title="image-20201130101153609" data-src="image-20201130101153609.png" class="lazyload"></a></p><p>前提: 安装了vim软件</p><h3 id="基本工作模式"><a href="#基本工作模式" class="headerlink" title="基本工作模式"></a>基本工作模式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作模式:</span><br><span class="line">1. 命令模式 -- 打开文件之后, 默认进入命令模式</span><br><span class="line">2. 编辑模式 -- 需要输入一些命令, 切换到编辑模式</span><br><span class="line">3. 末行模式 -- 在末行模式下可以输入一些命令</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130101245566.png" data-fancybox="group" data-caption="image-20201130101245566" class="fancybox"><img alt="image-20201130101245566" title="image-20201130101245566" data-src="image-20201130101245566.png" class="lazyload"></a></p><h4 id="命令模式下的操作"><a href="#命令模式下的操作" class="headerlink" title="命令模式下的操作"></a>命令模式下的操作</h4><p>1、光标的移动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">H（前）、J（下）、K（上）、L（后）</span><br><span class="line">行首: 0</span><br><span class="line">行尾: $</span><br><span class="line">文件开始位置: gg</span><br><span class="line">文件末尾: G</span><br><span class="line">行跳转: 300G</span><br></pre></td></tr></table></figure></div><p>2、删除操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">删除光标后边的字符: x</span><br><span class="line">........前......: X</span><br><span class="line">........单词: dw  (光标移动到单词的开始位置, 否只能删除一部分)</span><br><span class="line">...光标到行首的字符串: d0</span><br><span class="line">.........行尾.......: D(d$)</span><br><span class="line">删除光标当前行: dd</span><br><span class="line">删除多行: ndd (n -- 自然数)</span><br></pre></td></tr></table></figure></div><p>3、撤销操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">撤销: u</span><br><span class="line">反撤销: ctrl + r</span><br></pre></td></tr></table></figure></div><p>4、复制粘贴</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">复制: yy</span><br><span class="line">复制多行: nyy</span><br><span class="line"></span><br><span class="line">粘贴: p（小写） (光标所在行的下一行)</span><br><span class="line">粘贴: P （大写）(光标所在行)</span><br><span class="line"></span><br><span class="line">剪切 &#x3D;&#x3D; 删除</span><br></pre></td></tr></table></figure></div><p>5、可视模式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换到可是模式: v</span><br><span class="line">选择内容: hjkl</span><br><span class="line">操作: 复制: y   删除: d</span><br></pre></td></tr></table></figure></div><p>6、查找操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1). &#x2F;hello-----从光标所在位置向后查找 hello</span><br><span class="line">2). ?hello-----从光标所在位置向前查找 hello</span><br><span class="line">3). # -- 把光标移动到查找的单词身上 , 按#</span><br><span class="line">遍历时候的快捷键: N（上一个）&#x2F;n（下一个）</span><br></pre></td></tr></table></figure></div><p>7、替换和缩进</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r：r+需替换字符，只能对单个字符操作来替换当前字符</span><br><span class="line">缩进:</span><br><span class="line">向右: &gt;&gt;</span><br><span class="line">向左: &lt;&lt;</span><br></pre></td></tr></table></figure></div><p>8、在vim中查看man文档</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">光标移动到函数上,Shift-k 光标移动到函数上</span><br><span class="line">（顺序查找，从第一卷开始）</span><br><span class="line">3Shift-k,查看第三章的 ManPage</span><br></pre></td></tr></table></figure></div><p>9、保存退出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZZ</span><br></pre></td></tr></table></figure></div><h4 id="文本模式下的操作"><a href="#文本模式下的操作" class="headerlink" title="文本模式下的操作"></a>文本模式下的操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">切换到文本模式:</span><br><span class="line">a -- 在光标所在位置的后边插入</span><br><span class="line">A -- 在当前行的尾部插入</span><br><span class="line"></span><br><span class="line">i -- 在光标所在位置的前边插入</span><br><span class="line">I -- 在光标所在行的行首插入</span><br><span class="line"></span><br><span class="line">o -- 在光标所在行的下边开辟一个新的行</span><br><span class="line">O -- ...........上.........</span><br><span class="line"></span><br><span class="line">s -- 删除光标后边的字符</span><br><span class="line">S -- 删除光标所在的行</span><br></pre></td></tr></table></figure></div><h4 id="末行模式下的操作"><a href="#末行模式下的操作" class="headerlink" title="末行模式下的操作"></a>末行模式下的操作</h4><p>1、查找</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替换当前行的第一个目标字符串：s&#x2F;tom&#x2F;jack</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130104537428.png" data-fancybox="group" data-caption="image-20201130104537428" class="fancybox"><img alt="image-20201130104537428" title="image-20201130104537428" data-src="image-20201130104537428.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替换当前行的所有字符串：s&#x2F;tom&#x2F;jack&#x2F;g</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130104705909.png" data-fancybox="group" data-caption="image-20201130104705909" class="fancybox"><img alt="image-20201130104705909" title="image-20201130104705909" data-src="image-20201130104705909.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替换当前文件的所有行的第一个字符串：%s&#x2F;tom&#x2F;rose</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130104934246.png" data-fancybox="group" data-caption="image-20201130104934246" class="fancybox"><img alt="image-20201130104934246" title="image-20201130104934246" data-src="image-20201130104934246.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替换当前文件的所有字符串：%s&#x2F;tom&#x2F;dabai&#x2F;g</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130105024606.png" data-fancybox="group" data-caption="image-20201130105024606" class="fancybox"><img alt="image-20201130105024606" title="image-20201130105024606" data-src="image-20201130105024606.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">替换特定行的所有字符串：20,25s&#x2F;tom&#x2F;jack&#x2F;g</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130113351438.png" data-fancybox="group" data-caption="image-20201130113351438" class="fancybox"><img alt="image-20201130113351438" title="image-20201130113351438" data-src="image-20201130113351438.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在末行模式下输入shell命令---&gt;:!+命令，再次按下回车回到编辑器</span><br></pre></td></tr></table></figure></div><p>2、保存退出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q: 退出</span><br><span class="line">q!: 退出不保存</span><br><span class="line">w: 保存</span><br><span class="line">wq: 保存退出</span><br><span class="line">x: &#x3D;&#x3D; wq</span><br></pre></td></tr></table></figure></div><h3 id="分屏操作"><a href="#分屏操作" class="headerlink" title="分屏操作"></a>分屏操作</h3><h4 id="水平分屏"><a href="#水平分屏" class="headerlink" title="水平分屏"></a>水平分屏</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp</span><br></pre></td></tr></table></figure></div><p>使用Ctrl+w+w在各个分屏中进行切换</p><p><a href="image-20201130150319607.png" data-fancybox="group" data-caption="image-20201130150319607" class="fancybox"><img alt="image-20201130150319607" title="image-20201130150319607" data-src="image-20201130150319607.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp + 文件名</span><br><span class="line">可以实现打开其他文档</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130151111958.png" data-fancybox="group" data-caption="image-20201130151111958" class="fancybox"><img alt="image-20201130151111958" title="image-20201130151111958" data-src="image-20201130151111958.png" class="lazyload"></a></p><h4 id="垂直分屏"><a href="#垂直分屏" class="headerlink" title="垂直分屏"></a>垂直分屏</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vsp</span><br></pre></td></tr></table></figure></div><p>使用Ctrl+w+w在各个分屏中进行切换</p><p>提示：</p><p>我在使用vsp命令的时候报错无此命令，这时候直接更新一下vim即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130151154590.png" data-fancybox="group" data-caption="image-20201130151154590" class="fancybox"><img alt="image-20201130151154590" title="image-20201130151154590" data-src="image-20201130151154590.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wqall</span><br><span class="line">对所有打开的文件进行保存退出</span><br></pre></td></tr></table></figure></div><h3 id="vim打造IDE"><a href="#vim打造IDE" class="headerlink" title="vim打造IDE"></a>vim打造IDE</h3><p><a href="https://blog.csdn.net/stay_zezo/article/details/97959357" target="_blank" rel="noopener">参考链接</a>：<a href="https://blog.csdn.net/stay_zezo/article/details/97959357" target="_blank" rel="noopener">https://blog.csdn.net/stay_zezo/article/details/97959357</a></p><p>1、在用户的家目录下，即~/下新建一个文件命名为：vimrc</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch vimrc</span><br></pre></td></tr></table></figure></div><p>2、修改vimrc的读写执行权限</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 vimrc</span><br></pre></td></tr></table></figure></div><p>3、将vimrc移动到隐藏目录  .vimrc下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv vimrc .vimrc</span><br></pre></td></tr></table></figure></div><p>4、打开 .vimrc，参考上面给出的链接对文件内容进行编辑即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi .vimrc</span><br></pre></td></tr></table></figure></div><h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><p><a href="3_gcc%E7%BC%96%E8%AF%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5.png" data-fancybox="group" data-caption="3_gcc编译的四个阶段" class="fancybox"><img alt="3_gcc编译的四个阶段" title="3_gcc编译的四个阶段" data-src="3_gcc%E7%BC%96%E8%AF%91%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5.png" class="lazyload"></a></p><h3 id="gcc的工作流程"><a href="#gcc的工作流程" class="headerlink" title="gcc的工作流程"></a>gcc的工作流程</h3><p>1、hello.c—&gt;hello.i</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130153728566.png" data-fancybox="group" data-caption="image-20201130153728566" class="fancybox"><img alt="image-20201130153728566" title="image-20201130153728566" data-src="image-20201130153728566.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi hello.i</span><br><span class="line">该文件是一个将很多头文件都包含进来的c文件</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130153806126.png" data-fancybox="group" data-caption="image-20201130153806126" class="fancybox"><img alt="image-20201130153806126" title="image-20201130153806126" data-src="image-20201130153806126.png" class="lazyload"></a></p><p>2、hello.i—&gt;hello.s</p><p>（该步最耗时）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130153938358.png" data-fancybox="group" data-caption="image-20201130153938358" class="fancybox"><img alt="image-20201130153938358" title="image-20201130153938358" data-src="image-20201130153938358.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi hello.s</span><br><span class="line">该文件是一个汇编文件，里面有很多汇编指令</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130154034625.png" data-fancybox="group" data-caption="image-20201130154034625" class="fancybox"><img alt="image-20201130154034625" title="image-20201130154034625" data-src="image-20201130154034625.png" class="lazyload"></a></p><p>3、hello.s—&gt;hello.o</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130154150014.png" data-fancybox="group" data-caption="image-20201130154150014" class="fancybox"><img alt="image-20201130154150014" title="image-20201130154150014" data-src="image-20201130154150014.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi hello.o</span><br><span class="line">该文件是一个二进制文件</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130154242216.png" data-fancybox="group" data-caption="image-20201130154242216" class="fancybox"><img alt="image-20201130154242216" title="image-20201130154242216" data-src="image-20201130154242216.png" class="lazyload"></a></p><p>4、hello.o–&gt;a.out</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o a.out</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130154417757.png" data-fancybox="group" data-caption="image-20201130154417757" class="fancybox"><img alt="image-20201130154417757" title="image-20201130154417757" data-src="image-20201130154417757.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;a.out</span><br><span class="line">执行该文件</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130154459958.png" data-fancybox="group" data-caption="image-20201130154459958" class="fancybox"><img alt="image-20201130154459958" title="image-20201130154459958" data-src="image-20201130154459958.png" class="lazyload"></a></p><p>5、一步到位</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o app.out</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130155127206.png" data-fancybox="group" data-caption="image-20201130155127206" class="fancybox"><img alt="image-20201130155127206" title="image-20201130155127206" data-src="image-20201130155127206.png" class="lazyload"></a></p><h3 id="gcc的一些参数使用"><a href="#gcc的一些参数使用" class="headerlink" title="gcc的一些参数使用"></a>gcc的一些参数使用</h3><p>1、查看版本号</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130160404632.png" data-fancybox="group" data-caption="image-20201130160404632" class="fancybox"><img alt="image-20201130160404632" title="image-20201130160404632" data-src="image-20201130160404632.png" class="lazyload"></a></p><p>2、<strong>产生目标文件</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o</span><br></pre></td></tr></table></figure></div><p>3、<strong>指定头文件目录</strong></p><p>（由于有时候有文件不与.c文件在同一目录下，故编译时报错，在生成可执行文件是需要指定头文件路径）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o b.out</span><br></pre></td></tr></table></figure></div><p>不指定头文件报错信息如下</p><p><a href="image-20201130160824055.png" data-fancybox="group" data-caption="image-20201130160824055" class="fancybox"><img alt="image-20201130160824055" title="image-20201130160824055" data-src="image-20201130160824055.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -I .&#x2F;include -o b.out</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130161017423.png" data-fancybox="group" data-caption="image-20201130161017423" class="fancybox"><img alt="image-20201130161017423" title="image-20201130161017423" data-src="image-20201130161017423.png" class="lazyload"></a></p><p>4、<strong>编译时定义宏</strong></p><p>一般用于控制log输出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D</span><br></pre></td></tr></table></figure></div><p>5、编译优化</p><p>最高等级就是3级</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -O0</span><br><span class="line">gcc -O1</span><br><span class="line">gcc -O3</span><br></pre></td></tr></table></figure></div><p>6、提示更多警告信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall</span><br></pre></td></tr></table></figure></div><p>7、<strong>只编译子程序</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c</span><br></pre></td></tr></table></figure></div><p>8、生成预处理文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E</span><br></pre></td></tr></table></figure></div><p>9、<strong>包含调试信息</strong>（gdb调试的时候必须加参数）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g</span><br></pre></td></tr></table></figure></div><h2 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib + 库的名字 + .a</span><br><span class="line">例如：libmytest.a</span><br></pre></td></tr></table></figure></div><h3 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h3><p>测试：</p><p>1、建立一个test目录，在test目录下分别建立src、lib和include目录，以及main.c文件</p><p>main.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = add(<span class="number">2</span>, <span class="number">24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>src：包含add.c、sub.c、mul.c、div.c</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = a - b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = a * b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"head.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = a / b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>include：包含一个head.h</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __HEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HEAD_H_</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>2、生成对应的.o文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -c -I ..&#x2F;include</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130165935210.png" data-fancybox="group" data-caption="image-20201130165935210" class="fancybox"><img alt="image-20201130165935210" title="image-20201130165935210" data-src="image-20201130165935210.png" class="lazyload"></a></p><p>3、将生成的.o文件打包  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar rcs + 静态库的名字(libMytest.a) + 生成的所有的.o</span><br><span class="line">例如：ar rcs libMyCalc.a *.o</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130170146616.png" data-fancybox="group" data-caption="image-20201130170146616" class="fancybox"><img alt="image-20201130170146616" title="image-20201130170146616" data-src="image-20201130170146616.png" class="lazyload"></a></p><p>将新生成的库文件放到lib目录下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv libMyCalc.a ..&#x2F;lib</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130170332737.png" data-fancybox="group" data-caption="image-20201130170332737" class="fancybox"><img alt="image-20201130170332737" title="image-20201130170332737" data-src="image-20201130170332737.png" class="lazyload"></a></p><h3 id="发布和使用静态库"><a href="#发布和使用静态库" class="headerlink" title="发布和使用静态库"></a>发布和使用静态库</h3><p>1、发布</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）静态库、2）头文件 给用户</span><br><span class="line">静态库包含.o文件，而一般代码的接口都在头文件中给出，所以需要把头文件也发布给用户，便于用户调用接口</span><br></pre></td></tr></table></figure></div><p>2、使用静态库</p><p>法1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c lib&#x2F;libMyCalc.a -I include -o sum</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130170832298.png" data-fancybox="group" data-caption="image-20201130170832298" class="fancybox"><img alt="image-20201130170832298" title="image-20201130170832298" data-src="image-20201130170832298.png" class="lazyload"></a></p><p>法2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -I include -L lib -l MyCalc -o mysum</span><br><span class="line">I：指定头文件目录</span><br><span class="line">L：指定库目录</span><br><span class="line">l：指定用哪一个库，需要掐头去尾</span><br><span class="line">o：指定生成可执行文件的名字</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130171256185.png" data-fancybox="group" data-caption="image-20201130171256185" class="fancybox"><img alt="image-20201130171256185" title="image-20201130171256185" data-src="image-20201130171256185.png" class="lazyload"></a></p><p>3、查看可执行程序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm mysum</span><br></pre></td></tr></table></figure></div><p><a href="image-20201130171628388.png" data-fancybox="group" data-caption="image-20201130171628388" class="fancybox"><img alt="image-20201130171628388" title="image-20201130171628388" data-src="image-20201130171628388.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm</span><br></pre></td></tr></table></figure></div><p><strong>解释</strong>：在main函数中，静态库的程序以.o为最小单元进行选取，若需要某个.o则后续同main一起编译为可执行文件</p><p><a href="6_%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%89%93%E5%8C%85.png" data-fancybox="group" data-caption="6_静态库的打包" class="fancybox"><img alt="6_静态库的打包" title="6_静态库的打包" data-src="6_%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%89%93%E5%8C%85.png" class="lazyload"></a></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">静态库的优点：</span><br><span class="line">1、发布程序的时候，不需要提供对应的库</span><br><span class="line">2、加载库的速度快</span><br><span class="line"></span><br><span class="line">缺点（来源于优点）：</span><br><span class="line">1、库被打包到应用程序中，导致库的体积很大</span><br><span class="line">2、库发生改变，需要重新编译程序</span><br></pre></td></tr></table></figure></div><h2 id="共享库的制作"><a href="#共享库的制作" class="headerlink" title="共享库的制作"></a>共享库的制作</h2><h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib + 名字 + .so</span><br></pre></td></tr></table></figure></div><h3 id="制作步骤-1"><a href="#制作步骤-1" class="headerlink" title="制作步骤"></a>制作步骤</h3><p>先按照静态库的制作步骤准备好相应的文件</p><p>1、生成与位置无关的代码（生成与位置无关的.o）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -c *.c -I ..&#x2F;include</span><br></pre></td></tr></table></figure></div><p><a href="image-20201203151504653.png" data-fancybox="group" data-caption="image-20201203151504653" class="fancybox"><img alt="image-20201203151504653" title="image-20201203151504653" data-src="image-20201203151504653.png" class="lazyload"></a></p><p><strong>什么是与位置有关，什么是与位置无关呢？</strong></p><p><a href="7_%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" data-fancybox="group" data-caption="7_虚拟地址空间" class="fancybox"><img alt="7_虚拟地址空间" title="7_虚拟地址空间" data-src="7_%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" class="lazyload"></a></p><p>2、将.o打包生成.so文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libMyCalc.so *.o </span><br><span class="line">MV LibmMyCalc.so ..&#x2F;lib</span><br></pre></td></tr></table></figure></div><p><a href="image-20201203161602530.png" data-fancybox="group" data-caption="image-20201203161602530" class="fancybox"><img alt="image-20201203161602530" title="image-20201203161602530" data-src="image-20201203161602530.png" class="lazyload"></a></p><h3 id="发布和使用共享库"><a href="#发布和使用共享库" class="headerlink" title="发布和使用共享库"></a>发布和使用共享库</h3><p>1、发布</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）静态库、2）头文件 给用户</span><br><span class="line">静态库包含.o文件，而一般代码的接口都在头文件中给出，所以需要把头文件也发布给用户，便于用户调用接口</span><br></pre></td></tr></table></figure></div><p>2、使用共享库</p><p>法1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c lib&#x2F;libMyCalc.so -o app -I include</span><br></pre></td></tr></table></figure></div><p><a href="image-20201203161944589.png" data-fancybox="group" data-caption="image-20201203161944589" class="fancybox"><img alt="image-20201203161944589" title="image-20201203161944589" data-src="image-20201203161944589.png" class="lazyload"></a></p><p>法2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -Iinclude -L.&#x2F;lib -lMyCalc - o myapp</span><br><span class="line">-L：指定库所在路径</span><br><span class="line">l：指定用哪一个库，注意：去掉前缀lib，去掉后缀.so，只留中间部分</span><br><span class="line">-I：头文件目录位置</span><br><span class="line"></span><br><span class="line">.&#x2F;myapp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201205153258121.png" data-fancybox="group" data-caption="image-20201205153258121" class="fancybox"><img alt="image-20201205153258121" title="image-20201205153258121" data-src="image-20201205153258121.png" class="lazyload"></a></p><p>！！！运行失败</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看依赖的共享库：ldd app发现libMyCalc找不到</span><br><span class="line">没有给动态链接器（ld-linux.so2）指定好动态库libMyCalc.so路径</span><br></pre></td></tr></table></figure></div><p><a href="image-20201205153332647.png" data-fancybox="group" data-caption="image-20201205153332647" class="fancybox"><img alt="image-20201205153332647" title="image-20201205153332647" data-src="image-20201205153332647.png" class="lazyload"></a></p><p>解决方案</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、粗暴设置：直接将libmytest.so文件拷贝到&#x2F;usr&#x2F;lib&#x2F;【&#x2F;lib】目录下。(受libc库的启发)</span><br><span class="line">sudo cp .&#x2F;lib&#x2F;libMyCalc.so &#x2F;lib</span><br><span class="line">运行成功，不推荐，因为库名很可能与系统的库名重复，从而覆盖系统的库名</span><br></pre></td></tr></table></figure></div><p><a href="image-20201205153549944.png" data-fancybox="group" data-caption="image-20201205153549944" class="fancybox"><img alt="image-20201205153549944" title="image-20201205153549944" data-src="image-20201205153549944.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2、临时设置：export LD_LIBRARY_PATH&#x3D;库路径，将当前目录加入环境变量，但是终端退出了就无效了。</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;.&#x2F;lib</span><br><span class="line">开发动态库过程中常用的设置方法</span><br></pre></td></tr></table></figure></div><p><strong>LD_LIBRARY_PATH</strong></p><p>用于存放用户自己写的动态库的路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">1、指定查找共享库（动态链接库）时除了默认路径之外的其他路径</span><br><span class="line">2、该路径在默认路径之前查找</span><br><span class="line">设置方法：</span><br><span class="line">用export命令来设置值</span><br></pre></td></tr></table></figure></div><p><a href="image-20201205153837880.png" data-fancybox="group" data-caption="image-20201205153837880" class="fancybox"><img alt="image-20201205153837880" title="image-20201205153837880" data-src="image-20201205153837880.png" class="lazyload"></a></p><p><a href="image-20201205154139655.png" data-fancybox="group" data-caption="image-20201205154139655" class="fancybox"><img alt="image-20201205154139655" title="image-20201205154139655" data-src="image-20201205154139655.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3、永久设置：将上条写入家目录下.bashrc文件中（在末行添加）</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;.&#x2F;lib</span><br><span class="line">sudo vi .bashrc</span><br><span class="line">修改完成后需重启终端生效</span><br></pre></td></tr></table></figure></div><p><a href="image-20201205155519654.png" data-fancybox="group" data-caption="image-20201205155519654" class="fancybox"><img alt="image-20201205155519654" title="image-20201205155519654" data-src="image-20201205155519654.png" class="lazyload"></a></p><p><a href="image-20201205155616437.png" data-fancybox="group" data-caption="image-20201205155616437" class="fancybox"><img alt="image-20201205155616437" title="image-20201205155616437" data-src="image-20201205155616437.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4、将libmytest.so所在绝对路径追加入到&#x2F;etc&#x2F;ld.so.conf文件，使用sudo ldconfig -v 更新</span><br><span class="line">vi &#x2F;etc&#x2F;ld.so.conf</span><br><span class="line">sudo ldconfig -v</span><br></pre></td></tr></table></figure></div><p><a href="image-20201205160059014.png" data-fancybox="group" data-caption="image-20201205160059014" class="fancybox"><img alt="image-20201205160059014" title="image-20201205160059014" data-src="image-20201205160059014.png" class="lazyload"></a></p><p><a href="image-20201205160138293.png" data-fancybox="group" data-caption="image-20201205160138293" class="fancybox"><img alt="image-20201205160138293" title="image-20201205160138293" data-src="image-20201205160138293.png" class="lazyload"></a></p><p>用sudo ldconfig -v查看更新</p><p><a href="image-20201205160228099.png" data-fancybox="group" data-caption="image-20201205160228099" class="fancybox"><img alt="image-20201205160228099" title="image-20201205160228099" data-src="image-20201205160228099.png" class="lazyload"></a></p><p>看是否链接上了，此时的动态库链接到的是一个绝对路径</p><p><a href="image-20201205160412453.png" data-fancybox="group" data-caption="image-20201205160412453" class="fancybox"><img alt="image-20201205160412453" title="image-20201205160412453" data-src="image-20201205160412453.png" class="lazyload"></a></p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>在生成可执行程序时，系统只会在main.c生成app的过程中标记动态库，与静态库不同不是一起打包生成可执行程序，而是在运行阶段再去链接到动态库的某函数上执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（静态库的优点就是动态库的缺点，静态库的缺点就是动态库的优点）</span><br><span class="line">动态库优点：</span><br><span class="line">1、执行程序体积小</span><br><span class="line">2、动态库更新了，不需要重新编译程序（前提：函数接口不变）</span><br><span class="line"></span><br><span class="line">动态库缺点：</span><br><span class="line">1、发布程序的时候，需要将动态库提供给用户</span><br><span class="line">2、动态库没有被打包到应用程序中，加载速度相对慢</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vim编辑器&quot;&gt;&lt;a href=&quot;#vim编辑器&quot; class=&quot;headerlink&quot; title=&quot;vim编辑器&quot;&gt;&lt;/a&gt;vim编辑器&lt;/h2&gt;&lt;p&gt;是一个文本编辑程序，没有菜单栏，只有命令，且命令繁多&lt;/p&gt;
&lt;p&gt;vim是从vi发展过来的一款文本编辑器&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发一-基础/Day2/Day2</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day2/Day2/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day2/Day2/</id>
    <published>2021-01-30T07:20:24.584Z</published>
    <updated>2020-11-29T08:00:27.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><h3 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h3><p>生成 .gz格式的压缩包，该压缩方式，如果对一批文件进行打包是将每个文件逐个打包压缩，原文件会消失，并且不能压缩目录（不推荐）</p><p><strong>压缩</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip *.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125145634464.png" data-fancybox="group" data-caption="image-20201125145634464" class="fancybox"><img alt="image-20201125145634464" title="image-20201125145634464" data-src="image-20201125145634464.png" class="lazyload"></a></p><p><strong>解压缩</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip *.gz</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125151408679.png" data-fancybox="group" data-caption="image-20201125151408679" class="fancybox"><img alt="image-20201125151408679" title="image-20201125151408679" data-src="image-20201125151408679.png" class="lazyload"></a></p><h3 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h3><p>生成.bz2格式的压缩包，该压缩方式，如果对一批文件进行打包是将每个文件逐个打包压缩，不能压缩目录（不推荐）</p><p><strong>压缩</strong>（不保留原文件）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 *.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125151836888.png" data-fancybox="group" data-caption="image-20201125151836888" class="fancybox"><img alt="image-20201125151836888" title="image-20201125151836888" data-src="image-20201125151836888.png" class="lazyload"></a></p><p><strong>压缩</strong>（保留原文件）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -k *.txt</span><br><span class="line">k----&gt;keep</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125151934552.png" data-fancybox="group" data-caption="image-20201125151934552" class="fancybox"><img alt="image-20201125151934552" title="image-20201125151934552" data-src="image-20201125151934552.png" class="lazyload"></a></p><p><strong>解压缩</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bunzip2 *.bz2</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125152003665.png" data-fancybox="group" data-caption="image-20201125152003665" class="fancybox"><img alt="image-20201125152003665" title="image-20201125152003665" data-src="image-20201125152003665.png" class="lazyload"></a></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">参数:</span><br><span class="line">c -- 创建 -- 压缩</span><br><span class="line">x -- 释放 -- 解压缩</span><br><span class="line">v -- 显示提示信息 -- 压缩解压缩 -- 可以省略</span><br><span class="line">f -- 指定压缩文件的名字</span><br><span class="line"></span><br><span class="line">z -- 使用gzip的方式压缩文件 -- .gz</span><br><span class="line">j -- 使用bizp2的方式压缩文件 -- .bz2</span><br><span class="line">(不使用z&#x2F;j参数 , 该命令只能对文件或目录打包)</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">压缩:</span><br><span class="line">tar zcvf 生成的压缩包的名字(xxx.tar.gz) 要压缩的文件或目录</span><br><span class="line">tar jcvf 生成的压缩包的名字(xxx.tar.bz2) 要压缩的文件或目录</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125153202107.png" data-fancybox="group" data-caption="image-20201125153202107" class="fancybox"><img alt="image-20201125153202107" title="image-20201125153202107" data-src="image-20201125153202107.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压缩:</span><br><span class="line">tar jxvf 压缩包的名字(解压到当前目录)</span><br><span class="line">tar jxvf 压缩包名字 -C 压缩的目录</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125153909054.png" data-fancybox="group" data-caption="image-20201125153909054" class="fancybox"><img alt="image-20201125153909054" title="image-20201125153909054" data-src="image-20201125153909054.png" class="lazyload"></a></p><p><a href="image-20201125153803411.png" data-fancybox="group" data-caption="image-20201125153803411" class="fancybox"><img alt="image-20201125153803411" title="image-20201125153803411" data-src="image-20201125153803411.png" class="lazyload"></a></p><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><p>必须手动安装该软件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install rar</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125154812831.png" data-fancybox="group" data-caption="image-20201125154812831" class="fancybox"><img alt="image-20201125154812831" title="image-20201125154812831" data-src="image-20201125154812831.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数:</span><br><span class="line">压缩: a&#x2F;a -r(r可加可不加)</span><br><span class="line">解压缩: x</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">压缩:</span><br><span class="line">rar a 生成的压缩文件的名字(temp) 压缩的文件或目录</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125155009881.png" data-fancybox="group" data-caption="image-20201125155009881" class="fancybox"><img alt="image-20201125155009881" title="image-20201125155009881" data-src="image-20201125155009881.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压缩:</span><br><span class="line">rar x 压缩文件名 (解压缩目录)</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125155214250.png" data-fancybox="group" data-caption="image-20201125155214250" class="fancybox"><img alt="image-20201125155214250" title="image-20201125155214250" data-src="image-20201125155214250.png" class="lazyload"></a></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数:</span><br><span class="line">压缩目录需要加参数 -r</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">压缩:</span><br><span class="line">zip 压缩包的名字 压缩的文件</span><br><span class="line">zip -r 压缩包的名字 压缩的目录</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125155557771.png" data-fancybox="group" data-caption="image-20201125155557771" class="fancybox"><img alt="image-20201125155557771" title="image-20201125155557771" data-src="image-20201125155557771.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压缩: </span><br><span class="line">unzip 压缩包的名字</span><br><span class="line">unzip 压缩包的名字 -d 解压目录</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125155648258.png" data-fancybox="group" data-caption="image-20201125155648258" class="fancybox"><img alt="image-20201125155648258" title="image-20201125155648258" data-src="image-20201125155648258.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结: </span><br><span class="line">相同之处: </span><br><span class="line">tar&#x2F;rar&#x2F;zip  参数  生成的压缩文件的名字   压缩的文件或目录 --- 压缩的时候的语法</span><br><span class="line">tar&#x2F;rar&#x2F;unzip 参数 压缩包的名字  参数(rar没有参数)  解压缩目录 -- 解压缩语法</span><br></pre></td></tr></table></figure></div><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>简单理解，只要一个程序启动就代表一个进程</p><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>查看当前在线用户的情况：登陆的用户名、使用的设备终端（pst）、登陆到系统的时间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tty7----&gt;界面终端</span><br><span class="line">tty1-tty6----&gt;文字终端</span><br><span class="line">切换方式：Ctrl+Alt+f1-f7</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125161121420.png" data-fancybox="group" data-caption="image-20201125161121420" class="fancybox"><img alt="image-20201125161121420" title="image-20201125161121420" data-src="image-20201125161121420.png" class="lazyload"></a></p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看整个系统内部所运行的进程状况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">a：(all)当前系统所有用户的进程</span><br><span class="line">u：查看进程所有者及其他一些信息</span><br><span class="line">x：显示没有控制终端的进程--不能与用户进行交互的进程【输入、输出】</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps a</span><br><span class="line">当前系统所有用户的进程</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125162447307.png" data-fancybox="group" data-caption="image-20201125162447307" class="fancybox"><img alt="image-20201125162447307" title="image-20201125162447307" data-src="image-20201125162447307.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps u</span><br><span class="line">PID--&gt;进程ID</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125162518970.png" data-fancybox="group" data-caption="image-20201125162518970" class="fancybox"><img alt="image-20201125162518970" title="image-20201125162518970" data-src="image-20201125162518970.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps x</span><br><span class="line">显示没有控制终端的进程</span><br><span class="line">有终端 vs 没有终端：有终端就可以跟用户进行交互，没有终端（tty&#x3D;？）也就是不需要与用户进行交互</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125162554345.png" data-fancybox="group" data-caption="image-20201125162554345" class="fancybox"><img alt="image-20201125162554345" title="image-20201125162554345" data-src="image-20201125162554345.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">显示当前用户下的所有进程</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125163520299.png" data-fancybox="group" data-caption="image-20201125163520299" class="fancybox"><img alt="image-20201125163520299" title="image-20201125163520299" data-src="image-20201125163520299.png" class="lazyload"></a></p><p>信息太多，需要通过管道进行过滤</p><p><strong>什么是管道？</strong></p><p><a href="image-20201125163658879.png" data-fancybox="group" data-caption="image-20201125163658879" class="fancybox"><img alt="image-20201125163658879" title="image-20201125163658879" data-src="image-20201125163658879.png" class="lazyload"></a></p><p>执行完第一个命令后会得到一些输出，将指令1的输出作为指令2的输入，指令2相当于对指令1的输出进行一些执行操作最后输出到屏幕。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep bash</span><br><span class="line">即将ps aux得到的所有进程中的含有bash的进程进行输出</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125164116092.png" data-fancybox="group" data-caption="image-20201125164116092" class="fancybox"><img alt="image-20201125164116092" title="image-20201125164116092" data-src="image-20201125164116092.png" class="lazyload"></a></p><p><strong>注意</strong>：最后一个bash不是我们查出来的记录，是grep在查找的时候占用的进程</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>用来终止指定的进程（terminate a process）的运行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br><span class="line">查看信号编号</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125164551928.png" data-fancybox="group" data-caption="image-20201125164551928" class="fancybox"><img alt="image-20201125164551928" title="image-20201125164551928" data-src="image-20201125164551928.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGKILL 进程编号（PID）</span><br><span class="line">向当前进程发送9号信号（SIGKILL）</span><br></pre></td></tr></table></figure></div><p>模拟过程：多打开一个虚拟终端，再将其杀死，如图打开了两个终端，第二次打开的终端的进程编号PID=5630</p><p><a href="image-20201125165048867.png" data-fancybox="group" data-caption="image-20201125165048867" class="fancybox"><img alt="image-20201125165048867" title="image-20201125165048867" data-src="image-20201125165048867.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGKILL 5630</span><br><span class="line">或</span><br><span class="line">kill -9 5630</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125165211907.png" data-fancybox="group" data-caption="image-20201125165211907" class="fancybox"><img alt="image-20201125165211907" title="image-20201125165211907" data-src="image-20201125165211907.png" class="lazyload"></a></p><p>PID=5630进程被杀死，第二次打开的虚拟终端也随之被关闭</p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>查看当前进程的环境变量</p><p><a href="image-20201125171149902.png" data-fancybox="group" data-caption="image-20201125171149902" class="fancybox"><img alt="image-20201125171149902" title="image-20201125171149902" data-src="image-20201125171149902.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">什么是环境变量？</span><br><span class="line">当前系统下用户的配置路径信息</span><br><span class="line">格式为键值对：key&#x3D;value：value（多个值之间用：分隔）</span><br><span class="line">PATH：该环境变量中记录着shell命令解析器去查找命令的目录位置，从前往后的顺序查找</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看PATH相关环境变量</span><br><span class="line">env | grep PATH</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125171251605.png" data-fancybox="group" data-caption="image-20201125171251605" class="fancybox"><img alt="image-20201125171251605" title="image-20201125171251605" data-src="image-20201125171251605.png" class="lazyload"></a></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>相当于windows下的任务管理器（文字版，不能翻页）</p><p><a href="image-20201125171453207.png" data-fancybox="group" data-caption="image-20201125171453207" class="fancybox"><img alt="image-20201125171453207" title="image-20201125171453207" data-src="image-20201125171453207.png" class="lazyload"></a></p><p>动态的，Ctrl+c关闭。</p><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mac地址：网卡编号，不会重复</span><br><span class="line">Bcast：广播地址，在150网段的广播地址</span><br><span class="line">lo：回环地址</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125172040689.png" data-fancybox="group" data-caption="image-20201125172040689" class="fancybox"><img alt="image-20201125172040689" title="image-20201125172040689" data-src="image-20201125172040689.png" class="lazyload"></a></p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>测试与目标主机的连通性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">ping [参数] [主机名或IP地址]</span><br><span class="line">参数：</span><br><span class="line">-c 数目：在发送指定数目的包后停止（c---count次数）</span><br><span class="line">-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是1s送一次</span><br></pre></td></tr></table></figure></div><p>例如测试与本机windows之间的连通性</p><p>1、查找windows的ip地址</p><p>在cmd中输入ipconfig</p><p><a href="image-20201125172524044.png" data-fancybox="group" data-caption="image-20201125172524044" class="fancybox"><img alt="image-20201125172524044" title="image-20201125172524044" data-src="image-20201125172524044.png" class="lazyload"></a></p><p>2、在虚拟机中的linux系统中去ping本机的windows</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、不停的去ping，需要人为停止（Ctrl+c）</span><br><span class="line">ping 192.168.0.101</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125172959485.png" data-fancybox="group" data-caption="image-20201125172959485" class="fancybox"><img alt="image-20201125172959485" title="image-20201125172959485" data-src="image-20201125172959485.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2、指定ping的次数4</span><br><span class="line">ping -c 4 192.168.0.101</span><br><span class="line">或</span><br><span class="line">ping 192.168.0.101 -c 4</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125173133762.png" data-fancybox="group" data-caption="image-20201125173133762" class="fancybox"><img alt="image-20201125173133762" title="image-20201125173133762" data-src="image-20201125173133762.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3、指定发送间隔2s</span><br><span class="line">ping -i 2 192.168.0.101</span><br><span class="line">或</span><br><span class="line">ping 192.168.0.101 -i 2</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125173341935.png" data-fancybox="group" data-caption="image-20201125173341935" class="fancybox"><img alt="image-20201125173341935" title="image-20201125173341935" data-src="image-20201125173341935.png" class="lazyload"></a></p><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>查看服务器域名对应的IP地址</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup www.baidu.com</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125173614024.png" data-fancybox="group" data-caption="image-20201125173614024" class="fancybox"><img alt="image-20201125173614024" title="image-20201125173614024" data-src="image-20201125173614024.png" class="lazyload"></a></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>1、若用户名中包含大写字母则不能用这种方式创建用户</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser + 用户名(luffy)</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125193845392.png" data-fancybox="group" data-caption="image-20201125193845392" class="fancybox"><img alt="image-20201125193845392" title="image-20201125193845392" data-src="image-20201125193845392.png" class="lazyload"></a></p><p><a href="image-20201125201648543.png" data-fancybox="group" data-caption="image-20201125201648543" class="fancybox"><img alt="image-20201125201648543" title="image-20201125201648543" data-src="image-20201125201648543.png" class="lazyload"></a></p><p>exit退出</p><p>2、创建名字包含大写字母的用户</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -s &#x2F;bin&#x2F;bash -g Robin -d &#x2F;home&#x2F;Robin -m Robin</span><br><span class="line">参数解释：</span><br><span class="line">-s 指定新用户登录时shell类型</span><br><span class="line">-g 指定所属组，该组必须已经存在</span><br><span class="line">-d 用户家目录</span><br><span class="line">-m 用户家目录不存在时，自动创建该目录</span><br></pre></td></tr></table></figure></div><h3 id="设置用户组"><a href="#设置用户组" class="headerlink" title="设置用户组"></a>设置用户组</h3><p>由于创建用户时所属组必须存在，故需先创建用户组</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd Robin</span><br><span class="line">sudo useradd -s &#x2F;bin&#x2F;bash -g Robin -d &#x2F;home&#x2F;Robin -m Robin</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125204515539.png" data-fancybox="group" data-caption="image-20201125204515539" class="fancybox"><img alt="image-20201125204515539" title="image-20201125204515539" data-src="image-20201125204515539.png" class="lazyload"></a></p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改非登录用户密码：</span><br><span class="line">sudo passwd Robin</span><br><span class="line">修改登录用户密码：</span><br><span class="line">passwd</span><br><span class="line">修改root用户密码：</span><br><span class="line">sudo passwd root&#x2F;sudo passed</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125204627251.png" data-fancybox="group" data-caption="image-20201125204627251" class="fancybox"><img alt="image-20201125204627251" title="image-20201125204627251" data-src="image-20201125204627251.png" class="lazyload"></a></p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo deluser luffy</span><br><span class="line">需要手动删除&#x2F;home下的luffy目录</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125205327789.png" data-fancybox="group" data-caption="image-20201125205327789" class="fancybox"><img alt="image-20201125205327789" title="image-20201125205327789" data-src="image-20201125205327789.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo userdel -r Robin</span><br><span class="line">删除的比较干净</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125205526024.png" data-fancybox="group" data-caption="image-20201125205526024" class="fancybox"><img alt="image-20201125205526024" title="image-20201125205526024" data-src="image-20201125205526024.png" class="lazyload"></a></p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su luffy</span><br></pre></td></tr></table></figure></div><h3 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></div><h3 id="退出登录用户"><a href="#退出登录用户" class="headerlink" title="退出登录用户"></a>退出登录用户</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125210020300.png" data-fancybox="group" data-caption="image-20201125210020300" class="fancybox"><img alt="image-20201125210020300" title="image-20201125210020300" data-src="image-20201125210020300.png" class="lazyload"></a></p><h2 id="ftp服务器搭建"><a href="#ftp服务器搭建" class="headerlink" title="ftp服务器搭建"></a>ftp服务器搭建</h2><p>本次介绍：vsftpd</p><p><strong>功能</strong>：文件的上传和下载</p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125210736067.png" data-fancybox="group" data-caption="image-20201125210736067" class="fancybox"><img alt="image-20201125210736067" title="image-20201125210736067" data-src="image-20201125210736067.png" class="lazyload"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>服务器进行配置，配置给客户端使用</p><p>修改配置文件/etc/vsftpd.conf</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc</span><br><span class="line">sudo vi vsftpd.conf</span><br></pre></td></tr></table></figure></div><p><a href="vsftpd.conf.png" data-fancybox="group" data-caption="vsftpd.conf" class="fancybox"><img alt="vsftpd.conf" title="vsftpd.conf" data-src="vsftpd.conf.png" class="lazyload"></a></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>配置完成之后，必须重启服务器新的配置才能够生效</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;lib&#x2F;init&#x2F;upstart-job vsftpd restart -- 14.04版本</span><br><span class="line">sudo service vsftpd restart --通用，与版本无关</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125212332125.png" data-fancybox="group" data-caption="image-20201125212332125" class="fancybox"><img alt="image-20201125212332125" title="image-20201125212332125" data-src="image-20201125212332125.png" class="lazyload"></a></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="实名用户登录"><a href="#实名用户登录" class="headerlink" title="实名用户登录"></a>实名用户登录</h4><p>获取IP地址</p><p><a href="image-20201125212734530.png" data-fancybox="group" data-caption="image-20201125212734530" class="fancybox"><img alt="image-20201125212734530" title="image-20201125212734530" data-src="image-20201125212734530.png" class="lazyload"></a></p><p>1、登录ftp服务器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ftp + 服务器IP</span><br><span class="line">输入服务器用户名</span><br><span class="line">输入服务器密码</span><br></pre></td></tr></table></figure></div><p>现在假设dabai为服务器端，现在yujiao用户要登录到dabai服务器</p><p><a href="image-20201125214402478.png" data-fancybox="group" data-caption="image-20201125214402478" class="fancybox"><img alt="image-20201125214402478" title="image-20201125214402478" data-src="image-20201125214402478.png" class="lazyload"></a></p><p>如图可知，ftp登录到了dabai服务器的家目录下，ls显示出来的内容一致</p><p><a href="image-20201125214447933.png" data-fancybox="group" data-caption="image-20201125214447933" class="fancybox"><img alt="image-20201125214447933" title="image-20201125214447933" data-src="image-20201125214447933.png" class="lazyload"></a></p><p>2、文件的上传和下载</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件的上传：</span><br><span class="line">put + 文件名（该文件为登录时目录下存在的文件）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125215339526.png" data-fancybox="group" data-caption="image-20201125215339526" class="fancybox"><img alt="image-20201125215339526" title="image-20201125215339526" data-src="image-20201125215339526.png" class="lazyload"></a></p><p>可以看到在dabai的家目录下有通过ftp上传的hello.c文件</p><p><a href="image-20201125215520685.png" data-fancybox="group" data-caption="image-20201125215520685" class="fancybox"><img alt="image-20201125215520685" title="image-20201125215520685" data-src="image-20201125215520685.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文件的下载：</span><br><span class="line">get + 文件名（服务器下的文件）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125220008158.png" data-fancybox="group" data-caption="image-20201125220008158" class="fancybox"><img alt="image-20201125220008158" title="image-20201125220008158" data-src="image-20201125220008158.png" class="lazyload"></a></p><p><a href="image-20201125220103474.png" data-fancybox="group" data-caption="image-20201125220103474" class="fancybox"><img alt="image-20201125220103474" title="image-20201125220103474" data-src="image-20201125220103474.png" class="lazyload"></a></p><p>由此看出，用户成功在dabai服务器上下载了aa.bb.cc.dd文件到yujiao客户端的登录目录下</p><p>（不允许操作目录，如果想操作目录，可以先将目录<strong>打包</strong>再进行上传下载）</p><p>3、退出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">bye</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div><h4 id="匿名用户登录"><a href="#匿名用户登录" class="headerlink" title="匿名用户登录"></a>匿名用户登录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、不允许匿名用户在任意目录直接切换</span><br><span class="line">2、只能在一个指定的目录范围工作</span><br><span class="line">3、需要再ftp服务器上创建一个匿名用户的目录 -- 匿名用户的根目录</span><br></pre></td></tr></table></figure></div><p>为了将登录的用户的活动范围限制在某一个目录下需要做如下操作：</p><p>1、创建一个活动范围目录，例如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir MyFtp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125221312681.png" data-fancybox="group" data-caption="image-20201125221312681" class="fancybox"><img alt="image-20201125221312681" title="image-20201125221312681" data-src="image-20201125221312681.png" class="lazyload"></a></p><p>2、修改配置文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;vsftpd.conf</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125221732014.png" data-fancybox="group" data-caption="image-20201125221732014" class="fancybox"><img alt="image-20201125221732014" title="image-20201125221732014" data-src="image-20201125221732014.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重启服务器</span><br><span class="line">sudo service vsftpd restart</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125221837979.png" data-fancybox="group" data-caption="image-20201125221837979" class="fancybox"><img alt="image-20201125221837979" title="image-20201125221837979" data-src="image-20201125221837979.png" class="lazyload"></a></p><p>3、登录ftp服务器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ftp + 服务器IP</span><br><span class="line">匿名用户：anonymous</span><br><span class="line">密码：无，直接回车</span><br></pre></td></tr></table></figure></div><p>默认MyFtp目录是登录的根目录</p><p><a href="image-20201125222150750.png" data-fancybox="group" data-caption="image-20201125222150750" class="fancybox"><img alt="image-20201125222150750" title="image-20201125222150750" data-src="image-20201125222150750.png" class="lazyload"></a></p><p>4、文件的上传和下载</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上传：put xxx</span><br><span class="line">下载：get xxx</span><br><span class="line">不能够上传下载目录，如有需求可以制作成压缩包</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125222918648.png" data-fancybox="group" data-caption="image-20201125222918648" class="fancybox"><img alt="image-20201125222918648" title="image-20201125222918648" data-src="image-20201125222918648.png" class="lazyload"></a></p><p>如图，dabai服务器下面的MyFtp目录对于其他人没有写权限，故需要修改其权限才能实现上传文件到dabai的MyFtp目录下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 MyFtp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125223109429.png" data-fancybox="group" data-caption="image-20201125223109429" class="fancybox"><img alt="image-20201125223109429" title="image-20201125223109429" data-src="image-20201125223109429.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp&gt;put mike.put</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126160932744.png" data-fancybox="group" data-caption="image-20201126160932744" class="fancybox"><img alt="image-20201126160932744" title="image-20201126160932744" data-src="image-20201126160932744.png" class="lazyload"></a></p><p>5、退出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">推荐：</span><br><span class="line">quit</span><br><span class="line">bye</span><br><span class="line">不友好：</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div><h2 id="lftp"><a href="#lftp" class="headerlink" title="lftp"></a>lftp</h2><p>一个ftp客户端工具，可以长传和下载目录</p><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lftp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126161915945.png" data-fancybox="group" data-caption="image-20201126161915945" class="fancybox"><img alt="image-20201126161915945" title="image-20201126161915945" data-src="image-20201126161915945.png" class="lazyload"></a></p><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><h4 id="匿名登录"><a href="#匿名登录" class="headerlink" title="匿名登录"></a>匿名登录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、lftp 服务器IP 回车</span><br><span class="line">2、login</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126162428264.png" data-fancybox="group" data-caption="image-20201126162428264" class="fancybox"><img alt="image-20201126162428264" title="image-20201126162428264" data-src="image-20201126162428264.png" class="lazyload"></a></p><h4 id="实名登录"><a href="#实名登录" class="headerlink" title="实名登录"></a>实名登录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、lftp username@127.0.0.1 回车</span><br><span class="line">2、输入服务器密码</span><br></pre></td></tr></table></figure></div><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常见的命令，例如cd、pwd是针对服务器端的操作</span><br><span class="line">l+常见命令，例如lcd、lpwd是针对本地登录的local目录的操作</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126165038168.png" data-fancybox="group" data-caption="image-20201126165038168" class="fancybox"><img alt="image-20201126165038168" title="image-20201126165038168" data-src="image-20201126165038168.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">put：上传文件</span><br><span class="line">mput：上传多个文件</span><br><span class="line">get：下载文件</span><br><span class="line">mget：下载多个文件</span><br><span class="line">mirror：下载整个目录及其子目录</span><br><span class="line">mirror -R：上传整个目录及其子目录</span><br></pre></td></tr></table></figure></div><h2 id="nfs服务器搭建"><a href="#nfs服务器搭建" class="headerlink" title="nfs服务器搭建"></a>nfs服务器搭建</h2><p>dabai作为server端，yujiao作为用户端</p><h3 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></div><h4 id="创建共享目录"><a href="#创建共享目录" class="headerlink" title="创建共享目录"></a>创建共享目录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir NfsShare</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126170729327.png" data-fancybox="group" data-caption="image-20201126170729327" class="fancybox"><img alt="image-20201126170729327" title="image-20201126170729327" data-src="image-20201126170729327.png" class="lazyload"></a></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;exports</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126171313865.png" data-fancybox="group" data-caption="image-20201126171313865" class="fancybox"><img alt="image-20201126171313865" title="image-20201126171313865" data-src="image-20201126171313865.png" class="lazyload"></a></p><p><a href="image-20201126171203290.png" data-fancybox="group" data-caption="image-20201126171203290" class="fancybox"><img alt="image-20201126171203290" title="image-20201126171203290" data-src="image-20201126171203290.png" class="lazyload"></a></p><h4 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service nfs-kernel-server restart</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126171528810.png" data-fancybox="group" data-caption="image-20201126171528810" class="fancybox"><img alt="image-20201126171528810" title="image-20201126171528810" data-src="image-20201126171528810.png" class="lazyload"></a></p><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><h4 id="挂载服务器共享目录"><a href="#挂载服务器共享目录" class="headerlink" title="挂载服务器共享目录"></a>挂载服务器共享目录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount serverIP:sharedir &#x2F;mnt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126171834730.png" data-fancybox="group" data-caption="image-20201126171834730" class="fancybox"><img alt="image-20201126171834730" title="image-20201126171834730" data-src="image-20201126171834730.png" class="lazyload"></a></p><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="ssh服务器"><a href="#ssh服务器" class="headerlink" title="ssh服务器"></a>ssh服务器</h2><p>应用场景：服务器管理员通过ssh远程登录外地主机，进行维护</p><p>为了远程登录操作服务器，远程对服务器的操作和在当地对服务器的操作没有差别</p><h3 id="服务器端-2"><a href="#服务器端-2" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">查看ssh是否安装：</span><br><span class="line">sudo aptitude show openssh-server</span><br></pre></td></tr></table></figure></div><h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><h4 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@IP   确认连接的时候一定要写yes&#x2F;no</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126172909119.png" data-fancybox="group" data-caption="image-20201126172909119" class="fancybox"><img alt="image-20201126172909119" title="image-20201126172909119" data-src="image-20201126172909119.png" class="lazyload"></a></p><p>远程登录与在服务器端登录的一样，在服务器端可以进行的操作远程登录时一样可以，例如远程登录在dabai的家目录下留下一个hello.ssh的文件</p><p><a href="image-20201126173414441.png" data-fancybox="group" data-caption="image-20201126173414441" class="fancybox"><img alt="image-20201126173414441" title="image-20201126173414441" data-src="image-20201126173414441.png" class="lazyload"></a></p><h4 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logout</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126173435209.png" data-fancybox="group" data-caption="image-20201126173435209" class="fancybox"><img alt="image-20201126173435209" title="image-20201126173435209" data-src="image-20201126173435209.png" class="lazyload"></a></p><h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><h3 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></div><h3 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scp -r 目标用户名@目标主机IP地址:&#x2F;目标文件的绝对路径 &#x2F;保存到本机的绝对（相对）路径</span><br><span class="line">（在后续会提示输入“yes”此时，只能输“yes”而不能简单输入“Y”）</span><br><span class="line"></span><br><span class="line">scp -r 目标用户名@目标主机IP地址：&#x2F;目标文件的绝对路径 &#x2F;保存到本机的绝对&#x2F;相对路径</span><br><span class="line"></span><br><span class="line">scp -r itcast@192.168.1.100:&#x2F;home&#x2F;itcast&#x2F;QQ_dir&#x2F; .&#x2F;mytest&#x2F;360</span><br><span class="line"></span><br><span class="line">拷贝目录需要加参数 -r</span><br></pre></td></tr></table></figure></div><p>1、提前在dabai目录下创建目录scp_haha</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir scp_haha</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126174144884.png" data-fancybox="group" data-caption="image-20201126174144884" class="fancybox"><img alt="image-20201126174144884" title="image-20201126174144884" data-src="image-20201126174144884.png" class="lazyload"></a></p><p>2、远程将该目录拷贝到本地</p><p>将dabai下的scp_haha目录拷贝到本地的./test下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r dabai@192.168.150.128:&#x2F;home&#x2F;dabai&#x2F;scp_haha .&#x2F;test</span><br></pre></td></tr></table></figure></div><p><a href="image-20201126174624219.png" data-fancybox="group" data-caption="image-20201126174624219" class="fancybox"><img alt="image-20201126174624219" title="image-20201126174624219" data-src="image-20201126174624219.png" class="lazyload"></a></p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="终端翻页"><a href="#终端翻页" class="headerlink" title="终端翻页"></a>终端翻页</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shift+PageUp--&gt;上翻页</span><br><span class="line">shift+PageDown---&gt;下翻页</span><br></pre></td></tr></table></figure></div><h3 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean</span><br><span class="line">ctrl+l</span><br></pre></td></tr></table></figure></div><h3 id="创建终端"><a href="#创建终端" class="headerlink" title="创建终端"></a>创建终端</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl+Alt+T(Ubuntu)</span><br><span class="line">Ctrl+Shift+T（添加新标签页）</span><br></pre></td></tr></table></figure></div><h3 id="看手册"><a href="#看手册" class="headerlink" title="看手册"></a>看手册</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man man</span><br></pre></td></tr></table></figure></div><p><a href="image-20201127172356204.png" data-fancybox="group" data-caption="image-20201127172356204" class="fancybox"><img alt="image-20201127172356204" title="image-20201127172356204" data-src="image-20201127172356204.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按q退出</span><br></pre></td></tr></table></figure></div><h3 id="设置或查看别名"><a href="#设置或查看别名" class="headerlink" title="设置或查看别名"></a>设置或查看别名</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看</span><br><span class="line">alias</span><br></pre></td></tr></table></figure></div><p><a href="image-20201127172606904.png" data-fancybox="group" data-caption="image-20201127172606904" class="fancybox"><img alt="image-20201127172606904" title="image-20201127172606904" data-src="image-20201127172606904.png" class="lazyload"></a></p><p>表示ls是被封装过的，键入ls实际上是ls –color=auto</p><p><a href="image-20201127172805778.png" data-fancybox="group" data-caption="image-20201127172805778" class="fancybox"><img alt="image-20201127172805778" title="image-20201127172805778" data-src="image-20201127172805778.png" class="lazyload"></a></p><p><a href="image-20201127172823315.png" data-fancybox="group" data-caption="image-20201127172823315" class="fancybox"><img alt="image-20201127172823315" title="image-20201127172823315" data-src="image-20201127172823315.png" class="lazyload"></a></p><p>直接访问bin下面的ls显示的文件等是没有颜色的，而直接输入ls是有颜色的，原因就是ls被重新封装过</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置</span><br><span class="line">alias pag&#x3D;&#39;ps aux | grep&#39;</span><br><span class="line">注意：该修改是临时的，需要长久有效需要去设置配置文件：.bashrc</span><br></pre></td></tr></table></figure></div><p><a href="image-20201127173046850.png" data-fancybox="group" data-caption="image-20201127173046850" class="fancybox"><img alt="image-20201127173046850" title="image-20201127173046850" data-src="image-20201127173046850.png" class="lazyload"></a></p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>把指定字符串输入到终端，在显示器上显示数据</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">普通数据：echo 字符串</span><br><span class="line">显示环境变量：echo $PATH</span><br><span class="line">解释：$表示从变量取值，echo进行输出</span><br><span class="line">显示上一次程序退出值：echo $?</span><br></pre></td></tr></table></figure></div><p><a href="image-20201127173447049.png" data-fancybox="group" data-caption="image-20201127173447049" class="fancybox"><img alt="image-20201127173447049" title="image-20201127173447049" data-src="image-20201127173447049.png" class="lazyload"></a></p><h3 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h3><p>必须使用管理员权限去执行命令</p><h4 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h4><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p><a href="image-20201127173639919.png" data-fancybox="group" data-caption="image-20201127173639919" class="fancybox"><img alt="image-20201127173639919" title="image-20201127173639919" data-src="image-20201127173639919.png" class="lazyload"></a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="压缩包管理-1"><a href="#压缩包管理-1" class="headerlink" title="压缩包管理"></a>压缩包管理</h3><ol><li><p>Gzip命令能够对目录进行压缩吗？</p><p>No</p></li><li><p>Gzip命令对对文件压缩完毕之后会保留原文件吗，如果能请写出该命令？</p><p>No</p><p>Gzip ./*.txt</p><p>.gz格式</p></li><li><p>Gzip命令对多个文件压缩之后会生成一个压缩包还是多个，都是什么格式的？</p><p>多个，xxx.gz</p></li><li><p>Bzip2命令能够对目录进行压缩吗？</p><p>No</p></li><li><p>Bzip2命令对对文件压缩完毕之后会保留原文件吗，如果能请写出该命令？</p><p>可以</p><p>Bzip2 -k ./*.txt</p></li><li><p>Bzip2命令对多个文件压缩之后会生成一个压缩包还是多个，都是什么格式的？</p><p>多个，xxx.bz2</p></li><li><p>使用tar命令将目录 dir1压缩成gz格式，请写出该命令</p><p>tar zcvf mydir.tar.gz dir1</p></li><li><p>使用tar命令对压缩包test.tar.bz2 进行解压缩， 请写出该命令</p><p>tar jxvf test.tar.bz2</p></li><li><p>使用tar命令将压缩包test.tar.gz解压到家目录下，请写出该命令</p><p>tar zxvf test.tar.gz -C /home</p></li><li><p>使用rar命令压缩目录mytest，写出该命令</p><p>rar a myrar mytest（无需指定压缩包的后缀，会自动添加）</p><p>可以在后面加上-r（不加也可以）</p></li><li><p>使用rar命令解压缩 mytest.rar，写出该命令</p><p>解压到当前目录：rar x mytest.rar</p><p>解压到指定目录：rar x mytest.rar + 解压路径</p></li><li><p>使用zip命令压缩目录mytest，写出该命令</p><p>zip -r myzip mytest</p></li><li><p>写出命令，解压缩mytest.zip</p><p>unzip mytest.zip -d + 解压目录</p></li></ol><p>压缩：命令+参数+压缩文件的名字+压缩的文件或目录</p><p>解压缩：命令+压缩包名字+参数（rar没有参数）+解压目录</p><h3 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li><p>查看当前在线用户的状况的命令</p><p>who</p></li><li><p>Linux下如何切换设备终端？</p><p>一共有7个设备终端，前六个是文字终端，第七个是界面终端</p><p>Alt+Ctrl+f1-f7</p></li><li><p>Linux下各个设备终端之间是相互依赖的还是互补影响？</p><p>互不影响，可认为是七台电脑，各司其职</p></li><li><p>写出命令，在终端下查看操作系统下所有的bash进程</p><p>ps aux|grep “bash”</p></li><li><p>如何使用kill命令查看信号编号？</p><p>kill -l</p></li><li><p>写出命令，杀死进程编号为998877（PID）的进程</p><p>kill -9 998877</p></li><li><p>查看当前进程环境变量的命令是哪一个？</p><p>evn —–PATH</p><p>env|grep PATH</p></li></ol><h3 id="网络管理-1"><a href="#网络管理-1" class="headerlink" title="网络管理"></a>网络管理</h3><ol><li><p>获取网络接口信息的命令</p><p>ifconfig</p></li><li><p>测试与目标主机连通性的命令</p><p>ping  ip（域名或ip）</p></li><li><p>查看服务器域名对应的ip地址命令</p><p>nslookup</p></li></ol><h3 id="用户管理-1"><a href="#用户管理-1" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li><p>写出命令创建出一个新的用户itcast</p><p>sudo adduser luffy（不能大写）</p><p>sudo useradd -s /bin/bash -g Luffy -d /home/Luffy -m Luffy（创建后需手动添加密码）</p><p>若Luffy组不存在需添加：</p><p>sudo groupadd Luffy</p></li><li><p>写出命令删除一个用户itcast</p><p>deluser luffy—–家目录需手动删除</p><p>userdel -r luffy</p></li><li><p>写出命令切换到用户itcast</p><p>su itcast</p></li><li><p>写出命令在ubuntu下切换到root用户</p><p>sudo su</p><p>su</p><p>su -</p></li><li><p>写出命令修改itcast用户的密码</p><p>sudo passwd itcast</p></li></ol><h3 id="ftp服务器搭建-1"><a href="#ftp服务器搭建-1" class="headerlink" title="ftp服务器搭建"></a>ftp服务器搭建</h3><ol><li><p>ftp服务器安装完毕之后，服务会随系统的启动而自动启动吗？</p><p>会</p></li><li><p>如果需要修改ftp服务器的配置文件，应该去哪个目录下找？</p><p>/etc/vsftpd.conf</p></li><li><p>ftp服务器配置文件修改完毕之后，修改的配置能够马上生效吗，为什么？</p><p>不会</p><p>需要重启，不重启系统不会自动去读修改的配置文件</p></li><li><p>假设使用的ftp服务器为vsftpd，写出服务器重启命令？</p><p>sudo service vsftpd restart</p></li><li><p>从ftp服务器下载文件的命令是什么，上传文件的命令是什么？</p><p>下载：get</p><p>上传：put</p></li><li><p>Fpt服务器自带的客户端能够对目录进行上传和下载操作吗？</p><p>不能，打包可以上传</p></li><li><p>使用ftp自带的客户端如何使用匿名用户登录服务器，写出命令</p><p>ftp serverIP</p><p>用户名：anonymous</p><p>密码：回车</p></li><li><p>登录到ftp服务器之后，使用什么命令能够退出登录？</p><p>quit/exit/bye</p></li><li><p>如何使用lftp客户端匿名登录到ftp服务器？</p><p>lfpt + serverIP</p><p>login</p></li><li><p>使用lftp如何上传下载文件，写出命令</p><p>上传：put</p><p>下载：get</p></li><li><p>使用lftp如何上传下载多个文件，写出命令</p><p>上传多个：mput xxx xxx</p><p>下载多个：mget xxx xxx</p></li><li><p>使用lftp如何上传下载目录，写出命令</p><p>上传目录：mirror dir</p><p>下载目录：mirror -R dir</p></li></ol><h3 id="nfs网络共享服务器"><a href="#nfs网络共享服务器" class="headerlink" title="nfs网络共享服务器"></a>nfs网络共享服务器</h3><ol><li><p>Nfs服务器配置文件修改完毕之后，会马上生效吗？</p><p>不行，需要重启服务</p></li><li><p>Nfs服务器安装成功之后，服务会随系统自动启动吗？</p><p>会的，否则重启命令为啥叫restart呢</p></li><li><p>使用什么命令能够重启nfs服务器？（服务器名 nfs-kernel-server）</p><p>sudo nfs-kernel-server restart</p></li><li><p>客户端如何登陆到nfs服务器，写出命令</p></li></ol><p>（ip：192.168.1.100，共享目录：/home/itcast/nfs）</p><p>​        通过挂载的方式：sudo mount 192.168.1.100:/home/itcast/nfs /mnt</p><p>​        也可以挂载到其他目录，只不过挂载后目录内容会临时被覆盖</p><h3 id="ssh服务器-1"><a href="#ssh服务器-1" class="headerlink" title="ssh服务器"></a>ssh服务器</h3><ol><li><p>如何登陆到ssh服务器？</p><p>安装软件</p><p>ssh 用户名@serverIP</p><p>输入serverPassed</p></li></ol><h3 id="scp命令-1"><a href="#scp命令-1" class="headerlink" title="scp命令"></a>scp命令</h3><ol><li><p>如何使用scp命令从目标主机拷贝数据？</p><p>安装软件openssh-server</p><p>scp -r(拷贝目录加上) <a href="mailto:itcast@192.168.1.200">itcast@192.168.1.200</a>:/home/itcast/share /home/Robin/copy</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;压缩包管理&quot;&gt;&lt;a href=&quot;#压缩包管理&quot; class=&quot;headerlink&quot; title=&quot;压缩包管理&quot;&gt;&lt;/a&gt;压缩包管理&lt;/h2&gt;&lt;h3 id=&quot;gzip&quot;&gt;&lt;a href=&quot;#gzip&quot; class=&quot;headerlink&quot; title=&quot;gzip&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux学习笔记/linux服务器开发一-基础/Day1/Day1</title>
    <link href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day1/Day1/"/>
    <id>http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%B8%80-%E5%9F%BA%E7%A1%80/Day1/Day1/</id>
    <published>2021-01-30T07:20:23.941Z</published>
    <updated>2020-12-15T13:04:38.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="历史命令滚动"><a href="#历史命令滚动" class="headerlink" title="历史命令滚动"></a>历史命令滚动</h3><p>1、历史命令向上滚动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+p</span><br></pre></td></tr></table></figure></div><p>2、历史命令向下滚动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+n</span><br></pre></td></tr></table></figure></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>1、删除光标后的字符（即光标覆盖的字符）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+d</span><br></pre></td></tr></table></figure></div><p>2、删除光标前的字符</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+h &#x2F; backspace</span><br></pre></td></tr></table></figure></div><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>1、光标移动到行首</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+a</span><br></pre></td></tr></table></figure></div><p>2、光标移动到行位</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+e</span><br></pre></td></tr></table></figure></div><h3 id="自动补齐"><a href="#自动补齐" class="headerlink" title="自动补齐"></a>自动补齐</h3><p>（自动补齐命令和路径）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab键</span><br></pre></td></tr></table></figure></div><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><h3 id="重要的目录"><a href="#重要的目录" class="headerlink" title="重要的目录"></a>重要的目录</h3><p><a href="Image.jpg" data-fancybox="group" data-caption="Image" class="fancybox"><img alt="Image" title="Image" data-src="Image.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1&gt;. 根目录:</span><br><span class="line">2&gt;. &#x2F;bin: 二进制命令</span><br><span class="line">3&gt;. &#x2F;dev: 设备文件（所有外设都被抽象成文件）</span><br><span class="line">4&gt;. &#x2F;etc: 系统安装配置文件信息</span><br><span class="line">5&gt;. &#x2F;home: 所有用户的目录，home下有各个文件的宿主目录</span><br><span class="line">6&gt;. &#x2F;lib: 程序调用时所需的一些动态库</span><br><span class="line">7&gt;. &#x2F;media: 自动挂载的挂载目录</span><br><span class="line">8&gt;. &#x2F;mnt: 手动挂载的挂载目录</span><br><span class="line">9&gt;. &#x2F;root: 管理员目录</span><br><span class="line">10&gt;. &#x2F;usr: 当前用户的软件安装目录</span><br></pre></td></tr></table></figure></div><h3 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>1、查看当前目录下已存在的文件等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123185449329.png" data-fancybox="group" data-caption="image-20201123185449329" class="fancybox"><img alt="image-20201123185449329" title="image-20201123185449329" data-src="image-20201123185449329.png" class="lazyload"></a></p><p>2、查看当前目录下文件的详细信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123185521286.png" data-fancybox="group" data-caption="image-20201123185521286" class="fancybox"><img alt="image-20201123185521286" title="image-20201123185521286" data-src="image-20201123185521286.png" class="lazyload"></a></p><p>3、查看当前目录下所有的文件（包含隐藏文件，以.开头的文件）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123185549478.png" data-fancybox="group" data-caption="image-20201123185549478" class="fancybox"><img alt="image-20201123185549478" title="image-20201123185549478" data-src="image-20201123185549478.png" class="lazyload"></a></p><p>4、查看当前目录下所有文件及其详细信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123185610867.png" data-fancybox="group" data-caption="image-20201123185610867" class="fancybox"><img alt="image-20201123185610867" title="image-20201123185610867" data-src="image-20201123185610867.png" class="lazyload"></a></p><p>5、对于文件详细信息的解释</p><p>![1_ls -l](1_ls -l.png)</p><p>注意：占用存储空间与windows不同，目录为当前目录的大小</p><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>功能：用于查看当前路径下的目录结构</p><p>使用前需在Linux下联网进行安装</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install apt-get tree</span><br></pre></td></tr></table></figure></div><p>之后在shell框中键入tree即可查看当前目录的树形结构显示，如图</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123174442829.png" data-fancybox="group" data-caption="20201123174442829" class="fancybox"><img alt="20201123174442829" title="20201123174442829" data-src="image-20201123174442829.png" class="lazyload"></a></p><h3 id="路径切换"><a href="#路径切换" class="headerlink" title="路径切换"></a>路径切换</h3><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>1、相对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd .   &#x2F;&#x2F;.代表当前路径，相当于不动</span><br><span class="line">cd ..  &#x2F;&#x2F; ..代表上一级目录，相当于返回当前目录的前一级目录</span><br><span class="line">cd -   &#x2F;&#x2F;在相邻的两个目录下进行切换</span><br></pre></td></tr></table></figure></div><p>2、绝对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;yujiao&#x2F;aa</span><br></pre></td></tr></table></figure></div><p>3、回到家目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;yujiao</span><br><span class="line">cd</span><br><span class="line">cd ~</span><br></pre></td></tr></table></figure></div><h2 id="文件和目录相关操作"><a href="#文件和目录相关操作" class="headerlink" title="文件和目录相关操作"></a>文件和目录相关操作</h2><h3 id="文件和目录的创建"><a href="#文件和目录的创建" class="headerlink" title="文件和目录的创建"></a>文件和目录的创建</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>1、创建一级目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir aa</span><br></pre></td></tr></table></figure></div><p>2、创建多级目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p aa&#x2F;bb&#x2F;cc</span><br><span class="line">或</span><br><span class="line">mkdir aa&#x2F;bb&#x2F;cc -p</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123175052940.png" data-fancybox="group" data-caption="image-20201123175052940" class="fancybox"><img alt="image-20201123175052940" title="image-20201123175052940" data-src="image-20201123175052940.png" class="lazyload"></a></p><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>(若创建文件已存在则更新其日期为最后一次操作或修改该文件的日期)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch hello.c</span><br></pre></td></tr></table></figure></div><h3 id="文件和目录的删除"><a href="#文件和目录的删除" class="headerlink" title="文件和目录的删除"></a>文件和目录的删除</h3><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>1、删除空目录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmdir wenjian</span><br><span class="line">或</span><br><span class="line">rm wenjian</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123190435840.png" data-fancybox="group" data-caption="image-20201123190435840" class="fancybox"><img alt="image-20201123190435840" title="image-20201123190435840" data-src="image-20201123190435840.png" class="lazyload"></a></p><p>2、删除非空目录</p><p>（若目录为非空目录，则用rmdir命令无法删除）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -r aa</span><br><span class="line">或</span><br><span class="line">rm aa -r</span><br><span class="line">（使用rm命令的时候默认已经添加了-f参数，强制删除，故不需要添加）</span><br></pre></td></tr></table></figure></div><p>(aa是一个非空目录)</p><p><a href="image-20201123190758794.png" data-fancybox="group" data-caption="image-20201123190758794" class="fancybox"><img alt="image-20201123190758794" title="image-20201123190758794" data-src="image-20201123190758794.png" class="lazyload"></a></p><p>-i提示用户是否需要删除目录或文件，防止误删除操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -ri aa</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123191326258.png" data-fancybox="group" data-caption="image-20201123191326258" class="fancybox"><img alt="image-20201123191326258" title="image-20201123191326258" data-src="image-20201123191326258.png" class="lazyload"></a></p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm examples.desktop</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123191434146.png" data-fancybox="group" data-caption="image-20201123191434146" class="fancybox"><img alt="image-20201123191434146" title="image-20201123191434146" data-src="image-20201123191434146.png" class="lazyload"></a></p><h3 id="文件和目录的拷贝"><a href="#文件和目录的拷贝" class="headerlink" title="文件和目录的拷贝"></a>文件和目录的拷贝</h3><h4 id="文件的拷贝"><a href="#文件的拷贝" class="headerlink" title="文件的拷贝"></a>文件的拷贝</h4><p>1、拷贝文件到一个不存在的文件中（自动创建文件temp）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp hello.c temp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123192709081.png" data-fancybox="group" data-caption="image-20201123192709081" class="fancybox"><img alt="image-20201123192709081" title="image-20201123192709081" data-src="image-20201123192709081.png" class="lazyload"></a></p><p>2、拷贝文件到一个已存在的文件中（覆盖已存在文件内容）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp hello.c temp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123192840432.png" data-fancybox="group" data-caption="image-20201123192840432" class="fancybox"><img alt="image-20201123192840432" title="image-20201123192840432" data-src="image-20201123192840432.png" class="lazyload"></a></p><h4 id="目录的拷贝"><a href="#目录的拷贝" class="headerlink" title="目录的拷贝"></a>目录的拷贝</h4><p>目录不存在则自动创建，并把mytest的内容拷贝到newdir文件下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mytest&#x2F; newdir -r</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123193337368.png" data-fancybox="group" data-caption="image-20201123193337368" class="fancybox"><img alt="image-20201123193337368" title="image-20201123193337368" data-src="image-20201123193337368.png" class="lazyload"></a></p><p><a href="image-20201123193434834.png" data-fancybox="group" data-caption="image-20201123193434834" class="fancybox"><img alt="image-20201123193434834" title="image-20201123193434834" data-src="image-20201123193434834.png" class="lazyload"></a></p><p>目录存在则将mytest文件包含mytest目录一并拷贝到newdir下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp aa bb -r</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124221750790.png" data-fancybox="group" data-caption="image-20201124221750790" class="fancybox"><img alt="image-20201124221750790" title="image-20201124221750790" data-src="image-20201124221750790.png" class="lazyload"></a></p><p>若不想将外层目录进行拷贝，则使用*</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp aa&#x2F;* bb -r</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124221926822.png" data-fancybox="group" data-caption="image-20201124221926822" class="fancybox"><img alt="image-20201124221926822" title="image-20201124221926822" data-src="image-20201124221926822.png" class="lazyload"></a></p><h3 id="文件和目录的重命名-移动"><a href="#文件和目录的重命名-移动" class="headerlink" title="文件和目录的重命名/移动"></a>文件和目录的重命名/移动</h3><h4 id="文件-目录重命名"><a href="#文件-目录重命名" class="headerlink" title="文件/目录重命名"></a>文件/目录重命名</h4><p>（若第二个名字dd不存在则为重命名）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv aa dd</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123204436128.png" data-fancybox="group" data-caption="image-20201123204436128" class="fancybox"><img alt="image-20201123204436128" title="image-20201123204436128" data-src="image-20201123204436128.png" class="lazyload"></a></p><h4 id="文件-目录移动"><a href="#文件-目录移动" class="headerlink" title="文件/目录移动"></a>文件/目录移动</h4><p>（若第二个名字dd存在则为移动）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv aa dd</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123204140805.png" data-fancybox="group" data-caption="image-20201123204140805" class="fancybox"><img alt="image-20201123204140805" title="image-20201123204140805" data-src="image-20201123204140805.png" class="lazyload"></a></p><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>（用于查看比较小的文件，大文件显示不全）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat hello.c</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123194240997.png" data-fancybox="group" data-caption="image-20201123194240997" class="fancybox"><img alt="image-20201123194240997" title="image-20201123194240997" data-src="image-20201123194240997.png" class="lazyload"></a></p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>（用于查看较大的文件）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more stdio.h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123194425298.png" data-fancybox="group" data-caption="image-20201123194425298" class="fancybox"><img alt="image-20201123194425298" title="image-20201123194425298" data-src="image-20201123194425298.png" class="lazyload"></a></p><p>注意（只能往后翻，回不去）：</p><p>1、每一次回车则在屏幕多往后显示一行</p><p>2、每一次点空格就翻一页进行显示</p><p>3、按q或Ctrl+c结束查阅文档</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less stdio.h</span><br></pre></td></tr></table></figure></div><p>（比more智能）</p><p>注意：</p><p>1、每一次回车/Ctrl+n/向下箭头往后翻（按行），Ctrl+f（按页）</p><p>2、每一次点空格就翻一页进行显示</p><p>3、Ctrl+p/向上箭头往前翻（按行），Ctrl+b往前翻（按页）</p><p>4、按q或Ctrl+c结束查阅文档</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>默认显示文件前十行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head stdio.h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123195509189.png" data-fancybox="group" data-caption="image-20201123195509189" class="fancybox"><img alt="image-20201123195509189" title="image-20201123195509189" data-src="image-20201123195509189.png" class="lazyload"></a></p><p>若想修改显示行数，中间加” -参数”即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -5 stdio.h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123195912104.png" data-fancybox="group" data-caption="image-20201123195912104" class="fancybox"><img alt="image-20201123195912104" title="image-20201123195912104" data-src="image-20201123195912104.png" class="lazyload"></a></p><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>默认显示后十行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail stdio.h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123195529041.png" data-fancybox="group" data-caption="image-20201123195529041" class="fancybox"><img alt="image-20201123195529041" title="image-20201123195529041" data-src="image-20201123195529041.png" class="lazyload"></a></p><p>若想修改显示行数，中间加” -参数”即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -5 stdio.h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123200002152.png" data-fancybox="group" data-caption="image-20201123200002152" class="fancybox"><img alt="image-20201123200002152" title="image-20201123200002152" data-src="image-20201123200002152.png" class="lazyload"></a></p><h2 id="软、硬链接创建"><a href="#软、硬链接创建" class="headerlink" title="软、硬链接创建"></a>软、硬链接创建</h2><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>相当于windows下的快捷方式</p><p>示例：ln -s /home/a.txt  （源文件名+绝对路径） a.txt（软链接的名字）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;home&#x2F;yujiao&#x2F;file file_ruan</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124212109203.png" data-fancybox="group" data-caption="image-20201124212109203" class="fancybox"><img alt="image-20201124212109203" title="image-20201124212109203" data-src="image-20201124212109203.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">1、创建软链接，源文件要用绝对路径</span><br><span class="line">2、软链接大小：原文件+路径 的总字节数</span><br><span class="line">3、目录可以创建软链接</span><br></pre></td></tr></table></figure></div><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><h4 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file file.hard</span><br></pre></td></tr></table></figure></div><p><a href="image-20201123210803229.png" data-fancybox="group" data-caption="image-20201123210803229" class="fancybox"><img alt="image-20201123210803229" title="image-20201123210803229" data-src="image-20201123210803229.png" class="lazyload"></a></p><h4 id="硬链接原理剖析"><a href="#硬链接原理剖析" class="headerlink" title="硬链接原理剖析"></a>硬链接原理剖析</h4><p><a href="image-20201123210520785.png" data-fancybox="group" data-caption="image-20201123210520785" class="fancybox"><img alt="image-20201123210520785" title="image-20201123210520785" data-src="image-20201123210520785.png" class="lazyload"></a></p><p>所谓的硬链接指的是一种访问磁盘同一个位置不同的链接方式，指向的是磁盘上的一个iNode节点，节点存储了一些文件信息，可以通过iNode找到对应的文件，每创建一个硬链接，指向磁盘位置对应文件的硬链接数就+1，详细信息会显示文件的实际大小，但硬链接的本质并没有对磁盘的内容进行复制，而是一种对文件的备份，对每个硬链接的访问都是对同一块磁盘空间进行访问；每删除一个硬链接，该磁盘对应的硬链接数-1,；对任意一个硬链接文件进行修改，则指向该文件的所有硬链接所指向的内容也被改变。</p><p><strong>查看文件的Inode</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat file</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124211316519.png" data-fancybox="group" data-caption="image-20201124211316519" class="fancybox"><img alt="image-20201124211316519" title="image-20201124211316519" data-src="image-20201124211316519.png" class="lazyload"></a></p><p>如图硬链接数为3，访问任何一个都是通过同一个iNode访问同一块磁盘空间。</p><p><a href="image-20201124101416658.png" data-fancybox="group" data-caption="image-20201124101416658" class="fancybox"><img alt="image-20201124101416658" title="image-20201124101416658" data-src="image-20201124101416658.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">1、以文件副本的形式存在，但不占用实际空间</span><br><span class="line">2、不允许给目录创建硬链接</span><br><span class="line">3、硬链接只有在同一个文件系统中才能创建</span><br></pre></td></tr></table></figure></div><p><strong>对于Inode号的解释</strong>：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">索引节点inode：保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。</span><br><span class="line">例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或修改的时间戳，</span><br><span class="line">链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。</span><br><span class="line">( 注意数据分成：元数据+数据本身 )</span><br><span class="line"></span><br><span class="line">注意inode怎样生成的：每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定</span><br><span class="line">(现代OS可以动态变化)，一般每2KB就设置一个inode。一般文件系统中很少有文件小于2KB的，所以预定按照2KB分，</span><br><span class="line">一般inode是用不完的。所以inode在文件系统安装的时候会有一个默认数量，后期会根据实际的需要发生变化。</span><br><span class="line"></span><br><span class="line">注意inode号：inode号是唯一的，表示不同的文件。其实在Linux内部的时候，访问文件都是通过inode号来进行的，</span><br><span class="line">所谓文件名仅仅是给用户容易使用的。当我们打开一个文件的时候，首先，系统找到这个文件名对应的inode号；然后，</span><br><span class="line">通过inode号，得到inode信息，最后，由inode找到文件数据所在的block，现在可以处理文件数据了。</span><br><span class="line"></span><br><span class="line">inode和文件的关系：当创建一个文件的时候，就给文件分配了一个inode。一个inode只对应一个实际文件，</span><br><span class="line">一个文件也会只有一个inode。inodes最大数量就是文件的最大数量。</span><br></pre></td></tr></table></figure></div><h2 id="文件或目录属性"><a href="#文件或目录属性" class="headerlink" title="文件或目录属性"></a>文件或目录属性</h2><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>获取一个<strong>文本文件</strong>的信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc stdio.h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124101833767.png" data-fancybox="group" data-caption="image-20201124101833767" class="fancybox"><img alt="image-20201124101833767" title="image-20201124101833767" data-src="image-20201124101833767.png" class="lazyload"></a></p><p>44–行数</p><p>38–单词个数（以空格为分界）</p><p>96–字节数</p><p>stdio.h–文件名</p><h3 id="od"><a href="#od" class="headerlink" title="od"></a>od</h3><p>查看二进制文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">od -t 指定数据的显示格式</span><br><span class="line">1、c--ASCII字符</span><br><span class="line">2、d--有符号十进制</span><br><span class="line">3、f--浮点数</span><br><span class="line">4、o--八进制数</span><br><span class="line">5、u--无符号十进制数</span><br><span class="line">6、x--十六进制数</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">od -tx a.out</span><br><span class="line">（a.out是一个可执行文件，即一个二进制文件，以16进制显示）</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124102415777.png" data-fancybox="group" data-caption="image-20201124102415777" class="fancybox"><img alt="image-20201124102415777" title="image-20201124102415777" data-src="image-20201124102415777.png" class="lazyload"></a></p><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>显示当前目录下所有文件的大小</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du</span><br><span class="line">du -h(以人类可读方式显示，h---human)</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124102748635.png" data-fancybox="group" data-caption="image-20201124102748635" class="fancybox"><img alt="image-20201124102748635" title="image-20201124102748635" data-src="image-20201124102748635.png" class="lazyload"></a></p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>显示当前磁盘使用情况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124102938225.png" data-fancybox="group" data-caption="image-20201124102938225" class="fancybox"><img alt="image-20201124102938225" title="image-20201124102938225" data-src="image-20201124102938225.png" class="lazyload"></a></p><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>命令解析器在解析一些命令的时候，显示其查找的路径，即通过执行bin目录下的对应文件执行命令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which ls</span><br><span class="line">which cp</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124103228278.png" data-fancybox="group" data-caption="image-20201124103228278" class="fancybox"><img alt="image-20201124103228278" title="image-20201124103228278" data-src="image-20201124103228278.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which cd</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124103319013.png" data-fancybox="group" data-caption="image-20201124103319013" class="fancybox"><img alt="image-20201124103319013" title="image-20201124103319013" data-src="image-20201124103319013.png" class="lazyload"></a></p><p>不会有任何显示，因为cd为shell的内建命令，不需要去磁盘目录进行搜索</p><h2 id="文件权限-用户-用户组"><a href="#文件权限-用户-用户组" class="headerlink" title="文件权限, 用户, 用户组"></a>文件权限, 用户, 用户组</h2><h3 id="查看当前登陆用户"><a href="#查看当前登陆用户" class="headerlink" title="查看当前登陆用户"></a>查看当前登陆用户</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124103726889.png" data-fancybox="group" data-caption="image-20201124103726889" class="fancybox"><img alt="image-20201124103726889" title="image-20201124103726889" data-src="image-20201124103726889.png" class="lazyload"></a></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>查看各文件对文件所有者、文件所属组和其他人对文件的操作权限</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124103818541.png" data-fancybox="group" data-caption="image-20201124103818541" class="fancybox"><img alt="image-20201124103818541" title="image-20201124103818541" data-src="image-20201124103818541.png" class="lazyload"></a></p><h4 id="文字设定法"><a href="#文字设定法" class="headerlink" title="文字设定法"></a>文字设定法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chmod [who] [+|-|&#x3D;] [mode]</span><br><span class="line">who: </span><br><span class="line">文件所有者: u</span><br><span class="line">文件所属组: g</span><br><span class="line">其他人:    o</span><br><span class="line">所有的人:   a</span><br><span class="line"></span><br><span class="line">+: 添加权限:</span><br><span class="line">-: 减少权限</span><br><span class="line">&#x3D;: 覆盖原来的权限</span><br><span class="line"></span><br><span class="line">mode:</span><br><span class="line">r: 读</span><br><span class="line">w: 写</span><br><span class="line">x: 执行</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给dict.txt的其他人添加写权限</span><br><span class="line">chmod o+w dict.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124104800585.png" data-fancybox="group" data-caption="image-20201124104800585" class="fancybox"><img alt="image-20201124104800585" title="image-20201124104800585" data-src="image-20201124104800585.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给dict.txt的所有人添加执行权限x</span><br><span class="line">chmod a+x dict.txt  &#x2F;  chmod +x dict.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124105039206.png" data-fancybox="group" data-caption="image-20201124105039206" class="fancybox"><img alt="image-20201124105039206" title="image-20201124105039206" data-src="image-20201124105039206.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给dict.txt的所有人覆盖写权限w</span><br><span class="line">chmod a&#x3D;w dict.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124105345155.png" data-fancybox="group" data-caption="image-20201124105345155" class="fancybox"><img alt="image-20201124105345155" title="image-20201124105345155" data-src="image-20201124105345155.png" class="lazyload"></a></p><h4 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- : 没有权限</span><br><span class="line">r: 4</span><br><span class="line">w: 2</span><br><span class="line">x: 1</span><br><span class="line"></span><br><span class="line">例如：765</span><br><span class="line">7 -- rwx -- 文件所有者</span><br><span class="line">6 -- rw -- 文件所属组</span><br><span class="line">5 -- rx -- 其他人</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打开dict.txt的所有人的所有权限（相当于等号操作）</span><br><span class="line">chmod 777 dict.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124110200655.png" data-fancybox="group" data-caption="image-20201124110200655" class="fancybox"><img alt="image-20201124110200655" title="image-20201124110200655" data-src="image-20201124110200655.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用减法操作将dict.txt的其他人rwx修改为rw，即7--&gt;6</span><br><span class="line">chmod -001 dict.txt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124110858252.png" data-fancybox="group" data-caption="image-20201124110858252" class="fancybox"><img alt="image-20201124110858252" title="image-20201124110858252" data-src="image-20201124110858252.png" class="lazyload"></a></p><h3 id="改变文件或目录的所有者或所属组"><a href="#改变文件或目录的所有者或所属组" class="headerlink" title="改变文件或目录的所有者或所属组"></a>改变文件或目录的所有者或所属组</h3><p>对于一个文件，该文件的所属者为A，A属于Group1，但是该文件的所属组不一定是Group1，也可以是其他组，例如Group2。</p><p><a href="image-20201124111544127.png" data-fancybox="group" data-caption="image-20201124111544127" class="fancybox"><img alt="image-20201124111544127" title="image-20201124111544127" data-src="image-20201124111544127.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">改变文件所属者</span><br><span class="line">sudo chown zhangsan dict.txt </span><br><span class="line">改变文件所属组</span><br><span class="line">sudo chgrp zhangsan dict.txt</span><br><span class="line">改变文件的所属者和所属组</span><br><span class="line">sudo chown zhangsan:lisi dict.txt</span><br></pre></td></tr></table></figure></div><p>（对于目录而言，一般都必须具有执行权限x，否则无法打开目录）</p><p><a href="image-20201124150856198.png" data-fancybox="group" data-caption="image-20201124150856198" class="fancybox"><img alt="image-20201124150856198" title="image-20201124150856198" data-src="image-20201124150856198.png" class="lazyload"></a></p><h3 id="改变文件或目录所属的组"><a href="#改变文件或目录所属的组" class="headerlink" title="改变文件或目录所属的组"></a>改变文件或目录所属的组</h3><h2 id="查找和检索"><a href="#查找和检索" class="headerlink" title="查找和检索"></a>查找和检索</h2><h3 id="按文件属性查找"><a href="#按文件属性查找" class="headerlink" title="按文件属性查找"></a>按文件属性查找</h3><p>1、文件名:find + 查找的目录 + -name + “文件的名字”</p><p>相对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name &quot;hello&quot;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124152105639.png" data-fancybox="group" data-caption="image-20201124152105639" class="fancybox"><img alt="image-20201124152105639" title="image-20201124152105639" data-src="image-20201124152105639.png" class="lazyload"></a></p><p>绝对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;home&#x2F;yujiao -name &quot;hello&quot;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124152033271.png" data-fancybox="group" data-caption="image-20201124152033271" class="fancybox"><img alt="image-20201124152033271" title="image-20201124152033271" data-src="image-20201124152033271.png" class="lazyload"></a></p><p>加通配符查找</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*---&gt;占一串通配字符</span><br><span class="line">find &#x2F;home&#x2F;yujiao&#x2F; -name &quot;hel*&quot;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124152328764.png" data-fancybox="group" data-caption="image-20201124152328764" class="fancybox"><img alt="image-20201124152328764" title="image-20201124152328764" data-src="image-20201124152328764.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">？---&gt;占一个通配字符</span><br><span class="line">find &#x2F;home&#x2F;yujiao&#x2F; -name &quot;hello??&quot;</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124152509375.png" data-fancybox="group" data-caption="image-20201124152509375" class="fancybox"><img alt="image-20201124152509375" title="image-20201124152509375" data-src="image-20201124152509375.png" class="lazyload"></a></p><p>2、文件大小: find + 查找目录 + -size + +10k</p><p>(注意大小写，k—小写，M—大写）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查找小于10kb的文件</span><br><span class="line">find &#x2F;home&#x2F;yujiao&#x2F; -size -10k</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124152843006.png" data-fancybox="group" data-caption="image-20201124152843006" class="fancybox"><img alt="image-20201124152843006" title="image-20201124152843006" data-src="image-20201124152843006.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查找大于2kb的文件</span><br><span class="line">find .&#x2F; -size +2k</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124153145608.png" data-fancybox="group" data-caption="image-20201124153145608" class="fancybox"><img alt="image-20201124153145608" title="image-20201124153145608" data-src="image-20201124153145608.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查找大于2M的文件</span><br><span class="line">find &#x2F;home&#x2F;yujiao&#x2F; -size +2M</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124153332505.png" data-fancybox="group" data-caption="image-20201124153332505" class="fancybox"><img alt="image-20201124153332505" title="image-20201124153332505" data-src="image-20201124153332505.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查找大于2M小于10M的文件</span><br><span class="line">find &#x2F;home&#x2F;yujiao&#x2F; -size +2M -size -10M</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124153600401.png" data-fancybox="group" data-caption="image-20201124153600401" class="fancybox"><img alt="image-20201124153600401" title="image-20201124153600401" data-src="image-20201124153600401.png" class="lazyload"></a></p><p>3、文件类型: find + 查找目录 + -type + d/f/b/c/s/p/l</p><p>相对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -type f</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124153838852.png" data-fancybox="group" data-caption="image-20201124153838852" class="fancybox"><img alt="image-20201124153838852" title="image-20201124153838852" data-src="image-20201124153838852.png" class="lazyload"></a></p><p>绝对路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;home&#x2F;yujiao&#x2F;dd -type f</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124153932192.png" data-fancybox="group" data-caption="image-20201124153932192" class="fancybox"><img alt="image-20201124153932192" title="image-20201124153932192" data-src="image-20201124153932192.png" class="lazyload"></a></p><h3 id="按文件内容查找"><a href="#按文件内容查找" class="headerlink" title="按文件内容查找"></a>按文件内容查找</h3><p>grep -r “查找的内容” + 查找的路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;stdio.h&quot; &#x2F;home</span><br></pre></td></tr></table></figure></div><p><a href="image-20201124154836349.png" data-fancybox="group" data-caption="image-20201124154836349" class="fancybox"><img alt="image-20201124154836349" title="image-20201124154836349" data-src="image-20201124154836349.png" class="lazyload"></a></p><h2 id="软件的安装和卸载"><a href="#软件的安装和卸载" class="headerlink" title="软件的安装和卸载"></a>软件的安装和卸载</h2><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get（注意需要添加管理员权限）</span><br><span class="line">安装：sudo apt-get install tree --- 在线下载安装</span><br><span class="line">移除：sudo apt-get remove tree</span><br><span class="line">更新：sudo apt-get update --- 更新软件列表</span><br><span class="line">清理所有软件安装包：sudo apt-get clean</span><br><span class="line">（实际上清理的是：&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives目录下的.deb文件）</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aptitide</span><br><span class="line">安装：sudo aptitude install tree</span><br><span class="line">重新安装：sudo aptitude reinstall tree</span><br><span class="line">更新：sudo apt-get undate</span><br><span class="line">移除：sudo aptitude remove tree</span><br><span class="line">显示状态：sudo aptitude show tree</span><br></pre></td></tr></table></figure></div><h3 id="deb包安装"><a href="#deb包安装" class="headerlink" title="deb包安装"></a>deb包安装</h3><p>（前提下载好了.deb的安装包）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装：sudo dpkg -i xxx.deb</span><br><span class="line">删除：sudo dpkg -r xxx</span><br><span class="line">记忆：</span><br><span class="line">d--&gt;.deb</span><br><span class="line">pkg--&gt;package</span><br><span class="line">i--&gt;install</span><br></pre></td></tr></table></figure></div><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、解压缩源代码包</span><br><span class="line">2、进入到安装目录：cd dir</span><br><span class="line">3、检测文件是否缺失，创建Makefile，检测编译环境：.&#x2F;configure</span><br><span class="line">4、编译源码，生成库和可执行程序：make</span><br><span class="line">5、把库和可执行程序，安装到系统目录下：sudo make install</span><br><span class="line">6、删除和卸载软件：sudo make distclean</span><br><span class="line">7、上述安装步骤不是绝对的，应该先查看附带的README文件</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例: 安装 svn</span><br><span class="line">a. .&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;apr-util  --with--apr&#x3D;&#x2F;usr&#x2F;local&#x2F;apr</span><br><span class="line">b. make</span><br><span class="line">c. sudo make install</span><br></pre></td></tr></table></figure></div><h2 id="U盘的挂载和卸载"><a href="#U盘的挂载和卸载" class="headerlink" title="U盘的挂载和卸载"></a>U盘的挂载和卸载</h2><p>插上U盘后，虚拟机自动将u盘挂载到/media下，如果需要手动挂载到/mnt下，需要先将u盘卸载后再挂载到/mnt下。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1、插入u盘</p><p>如图，插上u盘后，会在/media下显示以用户名命名的目录，如yujiao，/media/yujiao下有一个插入u盘的u盘目录。</p><p><a href="image-20201125101235812.png" data-fancybox="group" data-caption="image-20201125101235812" class="fancybox"><img alt="image-20201125101235812" title="image-20201125101235812" data-src="image-20201125101235812.png" class="lazyload"></a></p><p>2、卸载u盘</p><p>卸载后yujiao目录下就没有目录了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &#x2F;media&#x2F;yujiao&#x2F;JXK-USB</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125101459664.png" data-fancybox="group" data-caption="image-20201125101459664" class="fancybox"><img alt="image-20201125101459664" title="image-20201125101459664" data-src="image-20201125101459664.png" class="lazyload"></a></p><p>3、挂载u盘</p><p>（可以选择挂载到任意目录下面，需要注意的是，被挂载目录在挂载u盘后显示的是u盘的内容，当将u盘卸载后又会重新恢复目录原来的一些信息，但是尽量挂载到空目录，以免覆盖原来的内容）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount devicename 挂载路径</span><br></pre></td></tr></table></figure></div><p>获取设备名字devicename</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125102102991.png" data-fancybox="group" data-caption="image-20201125102102991" class="fancybox"><img alt="image-20201125102102991" title="image-20201125102102991" data-src="image-20201125102102991.png" class="lazyload"></a></p><p>故devicename=/dev/sdb1</p><p>挂载u盘到/mnt下，之后可以在/mut查看u盘的一些内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt</span><br><span class="line">cd &#x2F;mnt</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125102346114.png" data-fancybox="group" data-caption="image-20201125102346114" class="fancybox"><img alt="image-20201125102346114" title="image-20201125102346114" data-src="image-20201125102346114.png" class="lazyload"></a></p><p>若需要获取u盘的内容，使用cp命令拷贝到系统磁盘上即可</p><p>4、卸载u盘</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &#x2F;mnt</span><br></pre></td></tr></table></figure></div><p><a href="image-20201125102703488.png" data-fancybox="group" data-caption="image-20201125102703488" class="fancybox"><img alt="image-20201125102703488" title="image-20201125102703488" data-src="image-20201125102703488.png" class="lazyload"></a></p><p>卸载失败是因为用户所处在将要卸载的目录下，需要退出到非/mn的目录再进行卸载，卸载成功，此时的/mnt是一个空目录</p><p><a href="image-20201125103021888.png" data-fancybox="group" data-caption="image-20201125103021888" class="fancybox"><img alt="image-20201125103021888" title="image-20201125103021888" data-src="image-20201125103021888.png" class="lazyload"></a></p><h3 id="磁盘命名规则"><a href="#磁盘命名规则" class="headerlink" title="磁盘命名规则"></a>磁盘命名规则</h3><p><a href="image-20201125103806454.png" data-fancybox="group" data-caption="image-20201125103806454" class="fancybox"><img alt="image-20201125103806454" title="image-20201125103806454" data-src="image-20201125103806454.png" class="lazyload"></a></p><p>sd1、sd2中的sd是根据磁盘的类型进行命名，之后按照顺序，加上后缀a、b、c、d等</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h3><ol><li><p>Shell、 Bash 学名叫什么？</p><p>命令解析器</p></li><li><p>Shell 和 Bash的关系？</p><p>现有Shell后有Bash，同一个人写的</p></li><li><p>在linux终端下使用什么键来补齐命令或者路径？</p><p>Tab</p></li><li><p>当前用户所在目录为/home/itcast/ 此时按两侧tab键会看到什么效果？</p><p>会列出itcast目录下边的目录（？？？）</p></li><li><p>终端下， 查看上一条历史命令的快捷键？</p><p>Ctrl+p</p></li><li><p>终端下， 查看下一条历史命令的快捷键？</p><p>Ctrl+n</p></li><li><p>终端下， 光标向左移动的快捷键？</p><p>Ctrl+b</p></li><li><p>终端下， 光标向右移动的快捷键？</p><p>Ctrl+f</p></li><li><p>终端下， 光标移动到行首的快捷键？</p><p>Ctrl+a</p></li><li><p>终端下， 光标移动到行尾的快捷键？</p><p>Ctrl+e</p></li><li><p>终端下， 删除光标前边字符的快捷键？</p><p>Ctrl+h / backspace</p></li><li><p>终端下， 删除光标后边字符（光标所在字符）的快捷键？</p><p>Ctrl+d</p></li><li><p>终端下， 删除光标前面所有内容的快捷键？</p><p>Ctrl+u</p></li></ol><h3 id="类unix系统目录结构"><a href="#类unix系统目录结构" class="headerlink" title="类unix系统目录结构"></a>类unix系统目录结构</h3><ol><li><p>类unix系统的目录结构是什么样的？</p><p>倒树结构</p></li><li><p>根目录下，存放系统和用户配置信息的目录是哪一个？</p><p>/etc</p></li><li><p>根目录下，存放设备文件的目录是哪一个？</p><p>/dev</p></li><li><p>根目录下，操作系统所安装的所有用户的主目录是哪一个？</p><p>/home</p></li><li><p>根目录下，存放操作系统所使用的库文件的目录是哪一个？</p><p>/lib</p></li><li><p>根目录下，存放系统级的可执行的二进制命令的目录是哪一个？</p><p>/bin</p></li><li><p>如果需要手动挂载设备， 那么一般挂载到哪个目录下？</p><p>/mut</p></li><li><p>当前用户的软件资源管理目录，是根目录下的哪一个？</p><p>/usr</p></li><li><p>假设当前登录用户为zhangsan, 请写出张三的宿主目录</p><p>a)  /home/zhangsan</p><p>b)  ~</p></li><li><p>请使用两种方式来表示一个用户的宿主目录，如itcast用户</p><p>a)  /home/itcast</p><p>b)  ~</p></li><li><p>什么是绝对路径，举例</p><p>从根目录/开始</p></li><li><p>什么是相对路径，举例</p><p>./abc</p><p>..表示当前目录的前一级目录</p></li><li><p>在linux中 . 表示什么？</p><p>表示当前目录</p></li><li><p>在linxu中 .. 表示什么？</p><p>表示当前目录的上一级目录</p></li><li><p>怎么切换临近两个目录？</p><p>cd -</p></li><li><p>Linux终端中的提示字符串：itcast@itcast:~$</p></li></ol><p>a)     第一个itcast表示什么</p><p>​    当前登陆的用户</p><p>b)    第二个itcast表示什么</p><p>​    主机名</p><p>c)     ~表示什么</p><p>​    宿主目录/当前目录所在的路径</p><p>d)    $表示什么，如果该字符换成#呢？</p><pre><code>root超级用户</code></pre><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><ol><li><p>以树状形式显示文件和目录结构的命令是什么？</p><p>tree</p></li><li><p>查看指定目录下的文件和目录是什么命令？</p><p>ls</p></li><li><p>如何列出指定目录下的所有文件和目录（隐藏和非隐藏）？</p><p>ls -a</p></li><li><p>如何列出指定目录下的文件或目录的详细信息？</p><p>ls -l</p></li><li><p>如何从当前目录进入到目录：/home/zhangsan/hello</p><p>cd /home/zhangsan/hello</p></li><li><p>如何进入到当前目录的上一级目录？</p><p>cd ..</p></li><li><p>如何从当前目录进入到当前用户的宿主目录（/home/itcast），使用三种方式？</p><p>cd ~</p><p>cd</p><p>cd /home/itcast</p></li><li><p>查看当前用户所在目录的命令？</p><p>pwd</p></li><li><p>创建目录的命令？</p><p>mkdir</p></li><li><p>如何创建一个多级目录， 如：aa/bb/cc/dd </p><p>mkdir -p aa/bb/cc/dd</p></li><li><p>有一个目录aa/hello.txt，rmdir 命令能够删除目录aa吗， 为什么？</p><p>不能，rmdir只能删除空目录</p></li><li><p>使用什么命令能够创建一个空文件？</p><p>touch a</p></li><li><p>使用什么命令能够删除文件和目录，怎么删除？</p><p>rm -r dir</p><p>rm file -i</p></li><li><p>拷贝文件和目录的命令是什么？</p><p>cp file file1（file1不存在：创建并拷贝；file1存在：覆盖）</p><p>cp dir dir1 -r（dir1不存在：将dir的内容拷贝到dir1中；dir1存在：将dir包括其内容放到dir1下）</p><p>cp dir/* dir1（不包含dir目录，只包含dir内容）</p></li><li><p>将a文件中的内容拷贝到b文件中，b文件存在和不存在会发生什么情况？</p><p>存在则覆盖</p><p>不存在则创建</p></li><li><p>将目录dir1内容拷贝到dir2中， 如果dir2不存在，dir2会被自动创建吗？</p><p>会</p></li><li><p>什么命令能够将文件中的内容一次性输出到终端上？</p><p>cat</p></li><li><p>有一个命令能够在终端中分页显示文件内容，但是只能向下翻页，是哪个命令？</p><p>more</p></li><li><p>有一个命令能够在终端中分页显示文件内容，也可以上下翻页，是哪个命令？</p><p>less</p></li><li><p>要显示hello.c文件中的前20行，应该用什么命令，怎么写？</p><p>head -20 hello.c</p></li><li><p>要显示hello.c文件中的后20行，应该用什么命令，怎么写？</p><p>tail -20 hello.c</p></li><li><p>如何给/home/itcast/目录下的stdio.h 创建一个软连接？</p><p>ln -s /home/itcast/stdio.h mysoft</p></li><li><p>给/home/itcast/目录下的stdio.h 创建一个软连接stdio.soft，删除stdio.h文件后软连接stdio.soft 还能使用吗？</p><p>不能，软链接就是源文件的一种快捷方式</p></li><li><p>如何给/home/itcast/目录下的stdio.h 创建一个硬连接？</p><p>ln /home/itcast/stdio.h std.hard（可不写绝对路径）</p></li><li><p>给/home/itcast/目录下的stdio.h 创建一个硬连接stdio.hard，删除stdio.h文件后硬连接stdio.hard 还能使用吗？</p><p>能，他们互不影响，都是通过INode去访问磁盘的某块空间</p></li></ol><h3 id="文件权限、用户、用户组"><a href="#文件权限、用户、用户组" class="headerlink" title="文件权限、用户、用户组"></a>文件权限、用户、用户组</h3><ol><li><p>使用什么命令能够查看当前登录用户</p><p>whoami</p></li><li><p>修改文件访问权限的命令是什么？</p><p>chmod</p></li><li><p>文件权限分别是哪几个，这几个权限对应的数字是几？</p><p>3个</p><p>w–2</p><p>r–4</p><p>x–1</p></li><li><p>使用文字设定法给hello.c文件的所属用户itcast添加执行权限</p><p>chmod u+x hello.c</p></li><li><p>Hello.c文件的权限为777，使用数字设定法给hello.c文件的其他人用户权限改成0</p><p>chmod -007 hello.c</p></li><li><p>能够修改文件的所有者和所属组的命令是哪一个？</p><p>chown</p><p>chown 新的所有者：新的所属组  文件名</p></li><li><p>使用chown命令的使用需要注意什么？</p><p>使用管理员权限</p></li><li><p>修改文件hello.c的所有者为tom，所属组为 china</p><p>sudo chown tom:china hello.c</p></li></ol><h3 id="查找和检索-1"><a href="#查找和检索-1" class="headerlink" title="查找和检索"></a>查找和检索</h3><ol><li><p>查找宿主目录下的hello.c文件，写出命令</p><p>find ~ -name “hello.c”</p></li><li><p>查找宿主目录下文件大小 大于1000k，小于1M的文件，写出命令</p><p>find ~ -size +1000k -size -1M</p></li><li><p>查找宿主目录下文件类型为 普通文件 的文件， 写出命令</p><p>find ~ -type f</p></li><li><p>查找宿主目录下文件内容中含有字符串 “hello，world”的文件</p><p>grep -r “hello,world” ~</p></li></ol><h3 id="文件的安装和卸载"><a href="#文件的安装和卸载" class="headerlink" title="文件的安装和卸载"></a>文件的安装和卸载</h3><ol><li><p>命令sudo apt-get update 是更新系统中的软件吗？</p><p>不是，更新的是软件列表</p></li><li><p>已知软件名为 tree，如何在线安装该软件？</p><p>sudo apt-get install tree</p></li><li><p>如何清理系统缓存的软件安装包？</p><p>sudo apt-get clean</p></li><li><p>有一个软件安装包 xxx.deb 如何安装到ubuntu中？</p><p>sudo dpkg -i xxx.deb</p><p>卸载</p><p>sudo dpkg -r xxx</p></li></ol><h3 id="U盘的挂载和卸载-1"><a href="#U盘的挂载和卸载-1" class="headerlink" title="U盘的挂载和卸载"></a>U盘的挂载和卸载</h3><ol><li><p>手动挂载设备到linux系统中，一般挂载到哪个目录下？</p></li><li><p>如何将一个U盘挂载到linux系统上？U盘设备名（sdb1）</p></li><li><p>如何将挂载的U盘卸载</p></li><li><p>在卸载U盘的时候有什么注意事项？</p></li><li><p>使用什么命令能够检测设备名称？</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;h3 id=&quot;历史命令滚动&quot;&gt;&lt;a href=&quot;#历史命令滚动&quot; class=&quot;headerlink&quot; title=&quot;历史命令滚动&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vivado2018使用教程</title>
    <link href="http://yoursite.com/2020/09/06/vivado2018%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/09/06/vivado2018%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2020-09-06T12:05:32.252Z</published>
    <updated>2020-09-06T15:27:47.172Z</updated>
    
    <content type="html"><![CDATA[<p>第一步</p><p>双击图标打开Vivado2018的界面</p><p>1、可以选择打开已有工程，或者新建工程（此处以新建工程为例）</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394125386.png" data-fancybox="group" data-caption="1599394125386" class="fancybox"><img alt="1599394125386" title="1599394125386" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394125386.png" class="lazyload"></a></p><p>2、设置工程名与保存路径</p><p>点击next</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394219393.png" data-fancybox="group" data-caption="1599394219393" class="fancybox"><img alt="1599394219393" title="1599394219393" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394219393.png" class="lazyload"></a></p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394483504.png" data-fancybox="group" data-caption="1599394483504" class="fancybox"><img alt="1599394483504" title="1599394483504" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394483504.png" class="lazyload"></a></p><p>3、选择RTL Project</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394528543.png" data-fancybox="group" data-caption="1599394528543" class="fancybox"><img alt="1599394528543" title="1599394528543" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394528543.png" class="lazyload"></a></p><p>之后两次都直接next即可</p><p>4、选择器件型号</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394786194.png" data-fancybox="group" data-caption="1599394786194" class="fancybox"><img alt="1599394786194" title="1599394786194" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394786194.png" class="lazyload"></a></p><p>5、最后显示工程项目摘要</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394832884.png" data-fancybox="group" data-caption="1599394832884" class="fancybox"><img alt="1599394832884" title="1599394832884" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394832884.png" class="lazyload"></a></p><p>第二步</p><p>1、为工程添加源文件</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394999590.png" data-fancybox="group" data-caption="1599394999590" class="fancybox"><img alt="1599394999590" title="1599394999590" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599394999590.png" class="lazyload"></a></p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395104834.png" data-fancybox="group" data-caption="1599395104834" class="fancybox"><img alt="1599395104834" title="1599395104834" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395104834.png" class="lazyload"></a></p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395138450.png" data-fancybox="group" data-caption="1599395138450" class="fancybox"><img alt="1599395138450" title="1599395138450" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395138450.png" class="lazyload"></a></p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395209577.png" data-fancybox="group" data-caption="1599395209577" class="fancybox"><img alt="1599395209577" title="1599395209577" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395209577.png" class="lazyload"></a></p><p>新建好后可以在左侧目录栏找到新建的.v文件</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395292343.png" data-fancybox="group" data-caption="1599395292343" class="fancybox"><img alt="1599395292343" title="1599395292343" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599395292343.png" class="lazyload"></a></p><p>附：关于字体的调节方法</p><p>tool–&gt;settings–&gt;Text Editor–&gt;Fonts and Colors</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599396462436.png" data-fancybox="group" data-caption="1599396462436" class="fancybox"><img alt="1599396462436" title="1599396462436" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599396462436.png" class="lazyload"></a></p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599396565999.png" data-fancybox="group" data-caption="1599396565999" class="fancybox"><img alt="1599396565999" title="1599396565999" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599396565999.png" class="lazyload"></a></p><p>测试代码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">verilog</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Create Date: 2020/09/06 20:26:33</span></span><br><span class="line"><span class="comment">// Design Name: 流水灯</span></span><br><span class="line"><span class="comment">// Module Name: led</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> led(</span><br><span class="line">    clk,</span><br><span class="line">    rst_n,</span><br><span class="line">    pio_led</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//定义输入信号</span></span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> rst_n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义输出信号</span></span><br><span class="line">    <span class="keyword">output</span> pio_led;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] pio_led;</span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">0</span>] state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//时序逻辑</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst_n!=<span class="number">0</span>)<span class="keyword">begin</span></span><br><span class="line">            pio_led&lt;=<span class="number">4'b0000</span>;</span><br><span class="line">            state&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//led低电平有效</span></span><br><span class="line">            <span class="keyword">case</span>(state)</span><br><span class="line">                <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                    pio_led&lt;=<span class="number">4'b0111</span>;</span><br><span class="line">                    state&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">1</span>:<span class="keyword">begin</span></span><br><span class="line">                    pio_led&lt;=<span class="number">4'b1011</span>;</span><br><span class="line">                    state&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2</span>:<span class="keyword">begin</span></span><br><span class="line">                    pio_led&lt;=<span class="number">4'b1101</span>;</span><br><span class="line">                    state&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">3</span>:<span class="keyword">begin</span></span><br><span class="line">                    pio_led&lt;=<span class="number">4'b1110</span>;</span><br><span class="line">                    state&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    state&lt;=<span class="number">0</span>;</span><br><span class="line">             <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div><p>点击右侧的RTL ANALYSIS 下的Open Elaborated Design即可查看电路图</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599396885725.png" data-fancybox="group" data-caption="1599396885725" class="fancybox"><img alt="1599396885725" title="1599396885725" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599396885725.png" class="lazyload"></a></p><p>2、仿真文件编写</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599397067893.png" data-fancybox="group" data-caption="1599397067893" class="fancybox"><img alt="1599397067893" title="1599397067893" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599397067893.png" class="lazyload"></a></p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599397144668.png" data-fancybox="group" data-caption="1599397144668" class="fancybox"><img alt="1599397144668" title="1599397144668" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599397144668.png" class="lazyload"></a></p><p>最后点击finish即可新建一个testbench</p><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599397187768.png" data-fancybox="group" data-caption="1599397187768" class="fancybox"><img alt="1599397187768" title="1599397187768" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599397187768.png" class="lazyload"></a></p><p>双击右侧新建的仿真文件进行testbench的书写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">verilog</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><a href="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599405170709.png" data-fancybox="group" data-caption="1599405170709" class="fancybox"><img alt="1599405170709" title="1599405170709" data-src="/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1599405170709.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一步&lt;/p&gt;
&lt;p&gt;双击图标打开Vivado2018的界面&lt;/p&gt;
&lt;p&gt;1、可以选择打开已有工程，或者新建工程（此处以新建工程为例）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/../images/Vivado%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>FPGA/GVIM操作</title>
    <link href="http://yoursite.com/2020/09/02/FPGA/GVIM%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/09/02/FPGA/GVIM%E6%93%8D%E4%BD%9C/</id>
    <published>2020-09-02T11:13:07.310Z</published>
    <updated>2020-09-02T11:43:55.677Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/../../images/fpga/1599045189473.png" data-fancybox="group" data-caption="1599045189473" class="fancybox"><img alt="1599045189473" title="1599045189473" data-src="/../../images/fpga/1599045189473.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;/../../images/fpga/1599045189473.png&quot; data-fancybox=&quot;group&quot; data-caption=&quot;1599045189473&quot; class=&quot;fancybox&quot;&gt;&lt;img alt=&quot;159904518947
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>FPGA/测试文件</title>
    <link href="http://yoursite.com/2020/09/02/FPGA/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/09/02/FPGA/%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6/</id>
    <published>2020-09-02T08:12:13.984Z</published>
    <updated>2020-09-03T13:50:15.406Z</updated>
    
    <content type="html"><![CDATA[<p>一、认识测试文件</p><p>​    testbench是一种验证的手段。首先，任何设计都是会有输入输出的。但是在软环境中没有激励输入，也不会对你设计的输出正确性进行评估。那么此时便有一种，模拟实际环境的输入激励和输出校验的一种“虚拟平台”产生。在这个平台上你可以对你的设计从软件层面进行分析和校验，这个就是testbench的含义。</p><p>！！！testbench是写输入激励的</p><p>二、测试文件编写流程</p><p><a href="/../../images/fpga/1599037131889.png" data-fancybox="group" data-caption="1599037131889" class="fancybox"><img alt="1599037131889" title="1599037131889" data-src="/../../images/fpga/1599037131889.png" class="lazyload"></a></p><p>【时间标尺】</p><p><code>格式：    &#39;timescale 仿真时间单位/时间精度</code></p><p><code>举例：    &#39;timescale 1ns/100ps（表示时延单位为1ns，时延精度为100ps）</code></p><p>注：时间单位&gt;=时间精度</p><p>时间单位指的是在后续的参数中的数字，如果时间单位为1ns，则后面的3指的就是3ns，时间精度若为1ns，则3.1ns代表的也是3ns</p><p>三、常用信号的编写方法</p><p>1、时钟信号的固定写法</p><p>2、复位信号的固定写法</p><p>3、其他信号的固定写法</p><p><a href="/../../images/fpga/1599131765850.png" data-fancybox="group" data-caption="1599131765850" class="fancybox"><img alt="1599131765850" title="1599131765850" data-src="/../../images/fpga/1599131765850.png" class="lazyload"></a></p><p><a href="/../../images/fpga/1599131854885.png" data-fancybox="group" data-caption="1599131854885" class="fancybox"><img alt="1599131854885" title="1599131854885" data-src="/../../images/fpga/1599131854885.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">verilog</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns/1 ns</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> testbench_name();</span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟和复位</span></span><br><span class="line"><span class="keyword">reg</span> clk  ;</span><br><span class="line"><span class="keyword">reg</span> rst_n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uut的输入信号</span></span><br><span class="line"><span class="keyword">reg</span>       datain  ;</span><br><span class="line"><span class="keyword">reg</span>       enable  ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//uut的输出信号</span></span><br><span class="line"><span class="keyword">wire</span>      F       ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//时钟周期，单位为ns，可在此修改时钟周期。</span></span><br><span class="line"><span class="keyword">parameter</span> CYCLE    = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复位时间，此时表示复位2个时钟周期的时间。</span></span><br><span class="line"><span class="keyword">parameter</span> RST_TIME = <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//待测试的模块例化</span></span><br><span class="line">module_name uut(</span><br><span class="line"><span class="variable">.clk</span>          (clk     ), </span><br><span class="line"><span class="variable">.rst_n</span>        (rst_n   ),</span><br><span class="line"><span class="variable">.enable</span>       (enable  ),</span><br><span class="line"><span class="variable">.datain</span>       (datain  ),</span><br><span class="line"><span class="variable">.F</span>            (F       )</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成本地时钟50M</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">clk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">forever</span></span><br><span class="line"><span class="variable">#(CYCLE/2)</span></span><br><span class="line">clk=~clk;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//产生复位信号</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">rst_n = <span class="number">1</span>;</span><br><span class="line">#<span class="number">2</span>;</span><br><span class="line">rst_n = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(CYCLE*RST_TIME)</span>;</span><br><span class="line">rst_n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入信号enable赋值方式</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">#<span class="number">1</span>;</span><br><span class="line"><span class="comment">//赋初值</span></span><br><span class="line">enable = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(CYCLE*(RST_TIME+1))</span>;</span><br><span class="line"><span class="comment">//开始赋值</span></span><br><span class="line">enable = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(CYCLE*9)</span>;</span><br><span class="line">enable=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入信号datain赋值方式</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">#<span class="number">1</span>;</span><br><span class="line"><span class="comment">//赋初值</span></span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(CYCLE*(RST_TIME+1))</span>;</span><br><span class="line"><span class="comment">//开始赋值</span></span><br><span class="line">datain = <span class="number">1</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">1</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(2*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">1</span>;</span><br><span class="line"><span class="variable">#(2*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">1</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">1</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">1</span>;</span><br><span class="line"><span class="variable">#(1*CYCLE)</span>;</span><br><span class="line">datain = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、认识测试文件&lt;/p&gt;
&lt;p&gt;​    testbench是一种验证的手段。首先，任何设计都是会有输入输出的。但是在软环境中没有激励输入，也不会对你设计的输出正确性进行评估。那么此时便有一种，模拟实际环境的输入激励和输出校验的一种“虚拟平台”产生。在这个平台上你可以对你的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>FPGA/明德扬规范</title>
    <link href="http://yoursite.com/2020/09/02/FPGA/%E6%98%8E%E5%BE%B7%E6%89%AC%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2020/09/02/FPGA/%E6%98%8E%E5%BE%B7%E6%89%AC%E8%A7%84%E8%8C%83/</id>
    <published>2020-09-02T03:51:41.207Z</published>
    <updated>2020-09-02T08:36:33.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、时序逻辑和组合逻辑"><a href="#一、时序逻辑和组合逻辑" class="headerlink" title="一、时序逻辑和组合逻辑"></a>一、时序逻辑和组合逻辑</h3><p>（1）时序逻辑的敏感信号必须是(posedge clk or negedge rst_n)；</p><p>注：信号多写不行，而且两个信号一个必须是上升沿一个必须是下降沿</p><p>（2）组合逻辑的写法always@(*)；</p><p>注：*的作用代表所有与always相关的信号，一旦相关信号有变化就执行该always语句</p><p>（3）只允许用always，不用assign；</p><p>（4）一个always里面只允许设计一个输出，但可以有多个输入</p><p>注意要点：</p><p>a、组合逻辑不能作为时钟、复位信号</p><p>b、组合逻辑一定要写else，避免生成锁存器</p><h3 id="二、阻塞赋值与非阻塞赋值"><a href="#二、阻塞赋值与非阻塞赋值" class="headerlink" title="二、阻塞赋值与非阻塞赋值"></a>二、阻塞赋值与非阻塞赋值</h3><p>（1）时序逻辑里面使用非阻塞赋值，即“&lt;=”</p><p>（2）组合逻辑里面使用阻塞赋值，即“=”</p><p>注意要点：</p><p>a、非阻塞赋值必须根据时钟沿触发，阻塞赋值是无视时钟的</p><h3 id="三、always写法规范"><a href="#三、always写法规范" class="headerlink" title="三、always写法规范"></a>三、always写法规范</h3><p>（1）只允许用always，不用assign</p><p>（2）一个always里面只允许设计一个输出，但可以有多个输入</p><p>注：一个always只设计一个信号的好处</p><p>a、仅需考虑一个信号，设计思路更加清晰</p><p>b、信号与信号之间不会造成干扰</p><h3 id="四、begin-end以及信号的对齐"><a href="#四、begin-end以及信号的对齐" class="headerlink" title="四、begin end以及信号的对齐"></a>四、begin end以及信号的对齐</h3><p>（1）always、条件之间，必须加begin和end</p><p>（2）begin统一在括号后面，end与begin一行开始处对齐，内部内容空4格开始编写</p><p>（3）模块的信号定义，必须对齐，包括类型、位宽、信号名等的对齐</p><h3 id="五、信号大小写的规范"><a href="#五、信号大小写的规范" class="headerlink" title="五、信号大小写的规范"></a>五、信号大小写的规范</h3><p>（1）参数、宏定义，必须大写，信号必须小写</p><h3 id="六、时钟及复位信号问题"><a href="#六、时钟及复位信号问题" class="headerlink" title="六、时钟及复位信号问题"></a>六、时钟及复位信号问题</h3><p>（1）一个模块只使用一个时钟，该模块中，任何时序逻辑敏感信号中的时钟，必须为该时钟。名称默认为clk</p><p>（2）禁止用计数器分频后的信号做其他模块的时钟，而要用改成时钟使能的方式</p><p><strong>正确的做法：</strong></p><p>​    图中en为使能信号，当en为1时也就是counter计数到了7，即实现的分频。</p><p><a href="/../../images/fpga/1599032084332.png" data-fancybox="group" data-caption="1599032084332" class="fancybox"><img alt="1599032084332" title="1599032084332" data-src="/../../images/fpga/1599032084332.png" class="lazyload"></a></p><p><strong>错误的做法：</strong></p><p>​    图中直接用分频后的信号clk1作为第三个always块中的使能信号</p><p><a href="/../../images/fpga/1599032244126.png" data-fancybox="group" data-caption="1599032244126" class="fancybox"><img alt="1599032244126" title="1599032244126" data-src="/../../images/fpga/1599032244126.png" class="lazyload"></a></p><p>（3）复位信号默认低电平有效，名称为rst_n</p><h3 id="七、reg，wire类型的使用"><a href="#七、reg，wire类型的使用" class="headerlink" title="七、reg，wire类型的使用"></a>七、reg，wire类型的使用</h3><p>（1）reg常用来表示用于“always”模块内的指定信号的类型，常代表触发器，在always里面赋值的信号都必须定义为reg类型</p><p>注：也就是无论是组合还是时序，always块中等号左边的信号都是reg类型</p><p>（2）wire类型信号表示线，常用于模块例化等</p><p>注意要点：</p><p>a、reg类型在代码综合后可能综合成时序逻辑，也可能是组合逻辑</p><h3 id="八、输入输出的规范"><a href="#八、输入输出的规范" class="headerlink" title="八、输入输出的规范"></a>八、输入输出的规范</h3><p>（1）输出信号必须是寄存器直接输出，不能用wire类型数据作为的输出</p><p>（2）输入输出的信号声明只能一行写一个，例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">verilog</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> clk;</span><br><span class="line"><span class="keyword">input</span> rst_n;</span><br><span class="line"><span class="keyword">output</span> key;</span><br></pre></td></tr></table></figure></div><h3 id="九、特色指令"><a href="#九、特色指令" class="headerlink" title="九、特色指令"></a>九、特色指令</h3><p>（1）Shixu：输出时序逻辑的模板代码部分</p><p>（2）Zuhe：输出组合逻辑的模板代码部分</p><p>（3）Module：输出整个模块模板代码部分</p><p>（4）Test：输出测试文件的模板代码部分</p><p>注意要点：</p><p>a、安装Gvim</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、时序逻辑和组合逻辑&quot;&gt;&lt;a href=&quot;#一、时序逻辑和组合逻辑&quot; class=&quot;headerlink&quot; title=&quot;一、时序逻辑和组合逻辑&quot;&gt;&lt;/a&gt;一、时序逻辑和组合逻辑&lt;/h3&gt;&lt;p&gt;（1）时序逻辑的敏感信号必须是(posedge clk or neg
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>FPGA/模块设计模板</title>
    <link href="http://yoursite.com/2020/09/02/FPGA/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2020/09/02/FPGA/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-09-02T03:16:15.300Z</published>
    <updated>2020-09-02T03:50:52.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、解析电路功能"><a href="#一、解析电路功能" class="headerlink" title="一、解析电路功能"></a>一、解析电路功能</h3><p><a href="/../../images/fpga/1599016649136.png" data-fancybox="group" data-caption="1599016649136" class="fancybox"><img alt="1599016649136" title="1599016649136" data-src="/../../images/fpga/1599016649136.png" class="lazyload"></a></p><p>如图可以看出，模块的输入只有两个，分别是clk和clr(复位信号，低电平有效)；</p><p>在模块的左半边是一个组合逻辑，有半边是时序逻辑，实现了自加1的功能</p><h3 id="二、修改模块设计模板"><a href="#二、修改模块设计模板" class="headerlink" title="二、修改模块设计模板"></a>二、修改模块设计模板</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">verilog</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> module_name(</span><br><span class="line">    clk,</span><br><span class="line">    clr,</span><br><span class="line">    out</span><br><span class="line">);</span><br><span class="line">    <span class="comment">//参数定义</span></span><br><span class="line">    <span class="keyword">parameter</span> DATA_W=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//输入信号定义</span></span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> clr;</span><br><span class="line">    <span class="comment">//输出信号定义</span></span><br><span class="line">    <span class="keyword">output</span>[DATA_W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="comment">//输出信号reg定义</span></span><br><span class="line">    <span class="keyword">reg</span>[DATA_W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="comment">//中间信号定义</span></span><br><span class="line">    <span class="keyword">reg</span>[DATA_w-<span class="number">1</span>:<span class="number">0</span>] out_temp;</span><br><span class="line">    <span class="comment">//组合逻辑</span></span><br><span class="line">    <span class="keyword">always</span>@(*)<span class="keyword">begin</span></span><br><span class="line">       out_temp=out+<span class="number">1'b1</span>; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">//时序逻辑</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> clr)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(clr==<span class="number">1'b0</span>)<span class="keyword">begin</span></span><br><span class="line">            out&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            out&lt;=out_temp;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、解析电路功能&quot;&gt;&lt;a href=&quot;#一、解析电路功能&quot; class=&quot;headerlink&quot; title=&quot;一、解析电路功能&quot;&gt;&lt;/a&gt;一、解析电路功能&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;/../../images/fpga/1599016649136.png&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
