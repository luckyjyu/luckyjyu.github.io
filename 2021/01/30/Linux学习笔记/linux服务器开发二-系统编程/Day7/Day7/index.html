<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7 | Lucky's Blog</title><meta name="description" content="Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7"><meta name="author" content="Lucky"><meta name="copyright" content="Lucky"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7"><meta name="twitter:description" content="Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7"><meta property="og:url" content="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day7/Day7/"><meta property="og:site_name" content="Lucky's Blog"><meta property="og:description" content="Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day7/Day7/"><link rel="prev" title="目标检测与配准/1_.dat文件转换方式与图形裁剪" href="http://yoursite.com/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1_.dat%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E8%A3%81%E5%89%AA/"><link rel="next" title="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Lucky's Blog" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Lucky's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">31</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#同步概念"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">同步概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程同步"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">线程同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#数据混乱原因"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">数据混乱原因</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#互斥量mutex"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">互斥量mutex</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主要应用函数"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">主要应用函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-mutex-init函数"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">pthread_mutex_init函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-mutex-destroy函数"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">pthread_mutex_destroy函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-mutex-lock函数"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">pthread_mutex_lock函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-mutex-unlock函数"><span class="toc_mobile_items-number">2.1.4.</span> <span class="toc_mobile_items-text">pthread_mutex_unlock函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-mutex-trylock函数"><span class="toc_mobile_items-number">2.1.5.</span> <span class="toc_mobile_items-text">pthread_mutex_trylock函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#加锁与解锁"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">加锁与解锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#lock与unlock"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">lock与unlock</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#lock与trylock"><span class="toc_mobile_items-number">2.2.2.</span> <span class="toc_mobile_items-text">lock与trylock</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#加锁步骤测试"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">加锁步骤测试</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#死锁"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">死锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#读写锁"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">读写锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#读写锁状态"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">读写锁状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#读写锁特性"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">读写锁特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主要应用函数-1"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">主要应用函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-init函数"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">pthread_rwlock_init函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-destroy函数"><span class="toc_mobile_items-number">4.3.2.</span> <span class="toc_mobile_items-text">pthread_rwlock_destroy函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-rdlock函数"><span class="toc_mobile_items-number">4.3.3.</span> <span class="toc_mobile_items-text">pthread_rwlock_rdlock函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-wrlock函数"><span class="toc_mobile_items-number">4.3.4.</span> <span class="toc_mobile_items-text">pthread_rwlock_wrlock函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-unlock函数"><span class="toc_mobile_items-number">4.3.5.</span> <span class="toc_mobile_items-text">pthread_rwlock_unlock函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-tryrdlock函数"><span class="toc_mobile_items-number">4.3.6.</span> <span class="toc_mobile_items-text">pthread_rwlock_tryrdlock函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-rwlock-trywrlock函数"><span class="toc_mobile_items-number">4.3.7.</span> <span class="toc_mobile_items-text">pthread_rwlock_trywrlock函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#读写锁示例"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">读写锁示例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#条件变量"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">条件变量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主要应用函数-2"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">主要应用函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-cond-init函数"><span class="toc_mobile_items-number">5.1.1.</span> <span class="toc_mobile_items-text">pthread_cond_init函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-cond-destroy函数"><span class="toc_mobile_items-number">5.1.2.</span> <span class="toc_mobile_items-text">pthread_cond_destroy函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-cond-wait函数"><span class="toc_mobile_items-number">5.1.3.</span> <span class="toc_mobile_items-text">pthread_cond_wait函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-cond-timedwait函数"><span class="toc_mobile_items-number">5.1.4.</span> <span class="toc_mobile_items-text">pthread_cond_timedwait函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-cond-signal函数"><span class="toc_mobile_items-number">5.1.5.</span> <span class="toc_mobile_items-text">pthread_cond_signal函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#pthread-cond-broadcast函数"><span class="toc_mobile_items-number">5.1.6.</span> <span class="toc_mobile_items-text">pthread_cond_broadcast函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#生产者消费者条件变量模型"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">生产者消费者条件变量模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#条件变量的优点"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">条件变量的优点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号量"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">信号量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#主要应用函数-3"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">主要应用函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#信号量基本操作"><span class="toc_mobile_items-number">6.1.1.</span> <span class="toc_mobile_items-text">信号量基本操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sem-init函数"><span class="toc_mobile_items-number">6.1.2.</span> <span class="toc_mobile_items-text">sem_init函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sem-destroy函数"><span class="toc_mobile_items-number">6.1.3.</span> <span class="toc_mobile_items-text">sem_destroy函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sem-wait函数"><span class="toc_mobile_items-number">6.1.4.</span> <span class="toc_mobile_items-text">sem_wait函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sem-post函数"><span class="toc_mobile_items-number">6.1.5.</span> <span class="toc_mobile_items-text">sem_post函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sem-trywait函数"><span class="toc_mobile_items-number">6.1.6.</span> <span class="toc_mobile_items-text">sem_trywait函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#sem-timedwait函数"><span class="toc_mobile_items-number">6.1.7.</span> <span class="toc_mobile_items-text">sem_timedwait函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#生产者消费者信号量模型"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">生产者消费者信号量模型</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程间同步"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">进程间同步</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#互斥量mutex-1"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">互斥量mutex</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#主要应用函数-4"><span class="toc_mobile_items-number">7.1.1.</span> <span class="toc_mobile_items-text">主要应用函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#进程间mutex示例"><span class="toc_mobile_items-number">7.1.2.</span> <span class="toc_mobile_items-text">进程间mutex示例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#文件锁"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">文件锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#进程间文件锁示例"><span class="toc_mobile_items-number">7.2.1.</span> <span class="toc_mobile_items-text">进程间文件锁示例</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#哲学家用餐模型分析"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">哲学家用餐模型分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多线程版"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">多线程版</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#多进程版"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">多进程版</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步概念"><span class="toc-number">1.</span> <span class="toc-text">同步概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-number">1.1.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据混乱原因"><span class="toc-number">1.2.</span> <span class="toc-text">数据混乱原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#互斥量mutex"><span class="toc-number">2.</span> <span class="toc-text">互斥量mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要应用函数"><span class="toc-number">2.1.</span> <span class="toc-text">主要应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-init函数"><span class="toc-number">2.1.1.</span> <span class="toc-text">pthread_mutex_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-destroy函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">pthread_mutex_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-lock函数"><span class="toc-number">2.1.3.</span> <span class="toc-text">pthread_mutex_lock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-unlock函数"><span class="toc-number">2.1.4.</span> <span class="toc-text">pthread_mutex_unlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-mutex-trylock函数"><span class="toc-number">2.1.5.</span> <span class="toc-text">pthread_mutex_trylock函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁与解锁"><span class="toc-number">2.2.</span> <span class="toc-text">加锁与解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lock与unlock"><span class="toc-number">2.2.1.</span> <span class="toc-text">lock与unlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock与trylock"><span class="toc-number">2.2.2.</span> <span class="toc-text">lock与trylock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁步骤测试"><span class="toc-number">2.3.</span> <span class="toc-text">加锁步骤测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-number">3.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读写锁"><span class="toc-number">4.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁状态"><span class="toc-number">4.1.</span> <span class="toc-text">读写锁状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁特性"><span class="toc-number">4.2.</span> <span class="toc-text">读写锁特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要应用函数-1"><span class="toc-number">4.3.</span> <span class="toc-text">主要应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-init函数"><span class="toc-number">4.3.1.</span> <span class="toc-text">pthread_rwlock_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-destroy函数"><span class="toc-number">4.3.2.</span> <span class="toc-text">pthread_rwlock_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-rdlock函数"><span class="toc-number">4.3.3.</span> <span class="toc-text">pthread_rwlock_rdlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-wrlock函数"><span class="toc-number">4.3.4.</span> <span class="toc-text">pthread_rwlock_wrlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-unlock函数"><span class="toc-number">4.3.5.</span> <span class="toc-text">pthread_rwlock_unlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-tryrdlock函数"><span class="toc-number">4.3.6.</span> <span class="toc-text">pthread_rwlock_tryrdlock函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-rwlock-trywrlock函数"><span class="toc-number">4.3.7.</span> <span class="toc-text">pthread_rwlock_trywrlock函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁示例"><span class="toc-number">4.4.</span> <span class="toc-text">读写锁示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件变量"><span class="toc-number">5.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要应用函数-2"><span class="toc-number">5.1.</span> <span class="toc-text">主要应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-init函数"><span class="toc-number">5.1.1.</span> <span class="toc-text">pthread_cond_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-destroy函数"><span class="toc-number">5.1.2.</span> <span class="toc-text">pthread_cond_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-wait函数"><span class="toc-number">5.1.3.</span> <span class="toc-text">pthread_cond_wait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-timedwait函数"><span class="toc-number">5.1.4.</span> <span class="toc-text">pthread_cond_timedwait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-signal函数"><span class="toc-number">5.1.5.</span> <span class="toc-text">pthread_cond_signal函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-cond-broadcast函数"><span class="toc-number">5.1.6.</span> <span class="toc-text">pthread_cond_broadcast函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者消费者条件变量模型"><span class="toc-number">5.2.</span> <span class="toc-text">生产者消费者条件变量模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件变量的优点"><span class="toc-number">5.3.</span> <span class="toc-text">条件变量的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量"><span class="toc-number">6.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要应用函数-3"><span class="toc-number">6.1.</span> <span class="toc-text">主要应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#信号量基本操作"><span class="toc-number">6.1.1.</span> <span class="toc-text">信号量基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-init函数"><span class="toc-number">6.1.2.</span> <span class="toc-text">sem_init函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-destroy函数"><span class="toc-number">6.1.3.</span> <span class="toc-text">sem_destroy函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-wait函数"><span class="toc-number">6.1.4.</span> <span class="toc-text">sem_wait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-post函数"><span class="toc-number">6.1.5.</span> <span class="toc-text">sem_post函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-trywait函数"><span class="toc-number">6.1.6.</span> <span class="toc-text">sem_trywait函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sem-timedwait函数"><span class="toc-number">6.1.7.</span> <span class="toc-text">sem_timedwait函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者消费者信号量模型"><span class="toc-number">6.2.</span> <span class="toc-text">生产者消费者信号量模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间同步"><span class="toc-number">7.</span> <span class="toc-text">进程间同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥量mutex-1"><span class="toc-number">7.1.</span> <span class="toc-text">互斥量mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主要应用函数-4"><span class="toc-number">7.1.1.</span> <span class="toc-text">主要应用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程间mutex示例"><span class="toc-number">7.1.2.</span> <span class="toc-text">进程间mutex示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件锁"><span class="toc-number">7.2.</span> <span class="toc-text">文件锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程间文件锁示例"><span class="toc-number">7.2.1.</span> <span class="toc-text">进程间文件锁示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哲学家用餐模型分析"><span class="toc-number">8.</span> <span class="toc-text">哲学家用餐模型分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程版"><span class="toc-number">8.1.</span> <span class="toc-text">多线程版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程版"><span class="toc-number">8.2.</span> <span class="toc-text">多进程版</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2021-01-30<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-01-14</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。如，设备同步，是指在两个设备之间规定一个共同的时间参考；数据库同步，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；文件同步，是指让两个或多个文件夹里的文件保持一致。等等</span><br><span class="line">而，编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。</span><br></pre></td></tr></table></figure></div>



<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	同步即协同步调，按预定的先后次序运行。</span><br><span class="line">	线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</span><br><span class="line">举例1： 银行存款 5000。柜台，折：取3000；提款机，卡：取 3000。剩余：2000</span><br><span class="line">举例2： 内存中100字节，线程T1欲填入全1， 线程T2欲填入全0。但如果T1执行了50个字节失去cpu，T2执行，会将T1写过的内容覆盖。当T1再次获得cpu继续	从失去cpu的位置向后写入1，当执行结束，内存中的100字节，既不是全1，也不是全0。</span><br><span class="line">	产生的现象叫做“与时间有关的错误”(time related)。为了避免这种数据混乱，线程需要同步。</span><br><span class="line">	“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</span><br><span class="line">	因此，所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210113095950695.png" data-fancybox="group" data-caption="image-20210113095950695" class="fancybox"><img alt="image-20210113095950695" title="image-20210113095950695" data-src="image-20210113095950695.png" class="lazyload"></a></p>
<p>例子：假设存折和银行卡都操作同一个账户，在存折需要提款时对账户进行查询发现20000&gt;5000可以提款，之后银行卡方先于存折将10000提取，自动设置账户剩余金额为10000，接下来待柜员将金钱清点交于提款方后，将账户金额设置为15000，产生了错误。</p>
<p>1、共享数据；2、存在竞争；3、多个对象访问共享数据，且无同步机制—&gt;发生与时间有关的错误。</p>
<h3 id="数据混乱原因"><a href="#数据混乱原因" class="headerlink" title="数据混乱原因"></a>数据混乱原因</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 资源共享（独享资源则不会）	</span><br><span class="line">2. 调度随机（意味着数据访问会出现竞争）	</span><br><span class="line">3. 线程间缺乏必要的同步机制。</span><br><span class="line">以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。</span><br><span class="line">所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。</span><br></pre></td></tr></table></figure></div>



<h2 id="互斥量mutex"><a href="#互斥量mutex" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux中提供一把互斥锁mutex（也称之为互斥量）。</span><br><span class="line">每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</span><br><span class="line">资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210113102516774.png" data-fancybox="group" data-caption="image-20210113102516774" class="fancybox"><img alt="image-20210113102516774" title="image-20210113102516774" data-src="image-20210113102516774.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">但，应注意：同一时刻，只能有一个线程持有该锁。</span><br><span class="line">当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。</span><br><span class="line">所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。</span><br><span class="line">因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</span><br></pre></td></tr></table></figure></div>

<h3 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	pthread_mutex_init函数</span><br><span class="line">	pthread_mutex_destroy函数</span><br><span class="line">	pthread_mutex_lock函数</span><br><span class="line">	pthread_mutex_trylock函数</span><br><span class="line">	pthread_mutex_unlock函数</span><br><span class="line">以上5个函数的返回值都是：成功返回0， 失败返回错误号。	</span><br><span class="line">	pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，简单当成整数看待。</span><br><span class="line">	pthread_mutex_t mutex; 变量mutex只有两种取值1、0。</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-mutex-init函数"><a href="#pthread-mutex-init函数" class="headerlink" title="pthread_mutex_init函数"></a>pthread_mutex_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始化一个互斥锁(互斥量) ---&gt; 初值可看作1</span><br><span class="line">	int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</span><br><span class="line">	参1：传出参数，调用时应传 &amp;mutex	</span><br><span class="line">	restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改</span><br><span class="line">	参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性</span><br><span class="line">	1.	静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化。e.g.  pthead_mutex_t muetx &#x3D; PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">	2.	动态初始化：局部变量应采用动态初始化。e.g.  pthread_mutex_init(&amp;mutex, NULL)</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-mutex-destroy函数"><a href="#pthread-mutex-destroy函数" class="headerlink" title="pthread_mutex_destroy函数"></a>pthread_mutex_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一个互斥锁</span><br><span class="line">	int pthread_mutex_destroy(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-mutex-lock函数"><a href="#pthread-mutex-lock函数" class="headerlink" title="pthread_mutex_lock函数"></a>pthread_mutex_lock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加锁。可理解为将mutex--（或-1）</span><br><span class="line">	int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-mutex-unlock函数"><a href="#pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_unlock函数"></a>pthread_mutex_unlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解锁。可理解为将mutex ++（或+1）</span><br><span class="line">	int pthread_mutex_unlock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-mutex-trylock函数"><a href="#pthread-mutex-trylock函数" class="headerlink" title="pthread_mutex_trylock函数"></a>pthread_mutex_trylock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">尝试加锁</span><br><span class="line">	int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br></pre></td></tr></table></figure></div>



<h3 id="加锁与解锁"><a href="#加锁与解锁" class="headerlink" title="加锁与解锁"></a>加锁与解锁</h3><h4 id="lock与unlock"><a href="#lock与unlock" class="headerlink" title="lock与unlock"></a>lock与unlock</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。</span><br><span class="line">unlock主动解锁函数，同时将阻塞在该锁上的所有线程全部唤醒，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。</span><br><span class="line">例如：T1 T2 T3 T4 使用一把mutex锁。T1加锁成功，其他线程均阻塞，直至T1解锁。T1解锁后，T2 T3 T4均被唤醒，并自动再次尝试加锁。</span><br><span class="line">可假想mutex锁 init成功初值为1。	lock 功能是将mutex--。	unlock将mutex++</span><br></pre></td></tr></table></figure></div>



<h4 id="lock与trylock"><a href="#lock与trylock" class="headerlink" title="lock与trylock"></a>lock与trylock</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock加锁失败会阻塞，等待锁释放。</span><br><span class="line">trylock加锁失败直接返回错误号（如：EBUSY），不阻塞。</span><br></pre></td></tr></table></figure></div>



<h3 id="加锁步骤测试"><a href="#加锁步骤测试" class="headerlink" title="加锁步骤测试"></a>加锁步骤测试</h3><p>​    看如下程序：该程序是非常典型的，由于共享、竞争而没有加任何同步机制，导致产生于时间有关的错误，造成数据混乱：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210113103905670.png" data-fancybox="group" data-caption="image-20210113103905670" class="fancybox"><img alt="image-20210113103905670" title="image-20210113103905670" data-src="image-20210113103905670.png" class="lazyload"></a></p>
<p>如图，打印出现了混乱，本来子线程应该打印hello world，主线程应该打印HELLO WORLD，但是由于存在竞争所以打印结果出现了混乱。</p>
<p>【练习】：修改该程序，使用mutex互斥锁进行同步。                                           </p>
<ol>
<li><p>定义全局互斥量，初始化init(&amp;m, NULL)互斥量，添加对应的destry</p>
</li>
<li><p>两个线程while中，两次printf前后，分别加lock和unlock</p>
</li>
<li><p>将unlock挪至第二个sleep后，发现交替现象很难出现。</p>
<p>线程在操作完共享资源后本应该立即解锁，但修改后，线程抱着锁睡眠。睡醒解锁后又立即加锁，这两个库函数本身不会阻塞。</p>
<p>所以在这两行代码之间失去cpu的概率很小。因此，另外一个线程很难得到加锁的机会。</p>
</li>
<li><p>main 中加flag = 5 将flg在while中– 这时，主线程输出5次后试图销毁锁，但子线程未将锁释放，无法完成。</p>
</li>
<li><p>main 中加pthread_cancel()将子线程取消。</p>
</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);<span class="comment">//mutex=1</span></span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210113110311406.png" data-fancybox="group" data-caption="image-20210113110311406" class="fancybox"><img alt="image-20210113110311406" title="image-20210113110311406" data-src="image-20210113110311406.png" class="lazyload"></a></p>
<p>如图，数据未出现混乱，由于每个线程之间是相互独立的。</p>
<p>1、将解锁放在sleep后，修改代码如下</p>
<ol start="4">
<li><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"world\n"</span>);</span><br><span class="line">        </span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);<span class="comment">//mutex=1</span></span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HELLO "</span>);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WORLD\n"</span>);</span><br><span class="line">        </span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ol>
<p><a href="image-20210113110728552.png" data-fancybox="group" data-caption="image-20210113110728552" class="fancybox"><img alt="image-20210113110728552" title="image-20210113110728552" data-src="image-20210113110728552.png" class="lazyload"></a></p>
<p>如图，将会连续出现主线程打印与子线程连续打印，由于没有及时解锁，其他线程很难抢到cpu，所以出现此现象。</p>
<p><strong>结论：</strong></p>
<p>​     <strong>在访问共享资源前加锁，访问结束后立即解锁。锁的“粒度”应越小越好。</strong></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>（现象）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 线程试图对同一个互斥量A加锁两次。</span><br><span class="line">2. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁</span><br></pre></td></tr></table></figure></div>

<p><a href="04_%E6%AD%BB%E9%94%81.png" data-fancybox="group" data-caption="04_死锁" class="fancybox"><img alt="04_死锁" title="04_死锁" data-src="04_%E6%AD%BB%E9%94%81.png" class="lazyload"></a></p>
<p>【作业】：编写程序，实现上述两种死锁现象。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</span><br></pre></td></tr></table></figure></div>



<h3 id="读写锁状态"><a href="#读写锁状态" class="headerlink" title="读写锁状态"></a>读写锁状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一把读写锁具备三种状态：</span><br><span class="line">	1. 读模式下加锁状态 (读锁)</span><br><span class="line">	2. 写模式下加锁状态 (写锁)</span><br><span class="line">	3. 不加锁状态</span><br></pre></td></tr></table></figure></div>



<h3 id="读写锁特性"><a href="#读写锁特性" class="headerlink" title="读写锁特性"></a>读写锁特性</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.	读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</span><br><span class="line">2.	读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</span><br><span class="line">3.	读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高</span><br><span class="line">	读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</span><br><span class="line">	读写锁非常适合于对数据结构读的次数远大于写的情况。</span><br></pre></td></tr></table></figure></div>

<p><a href="03_%E8%AF%BB%E5%86%99%E9%94%81.png" data-fancybox="group" data-caption="03_读写锁" class="fancybox"><img alt="03_读写锁" title="03_读写锁" data-src="03_%E8%AF%BB%E5%86%99%E9%94%81.png" class="lazyload"></a></p>
<h3 id="主要应用函数-1"><a href="#主要应用函数-1" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	pthread_rwlock_init函数</span><br><span class="line">	pthread_rwlock_destroy函数</span><br><span class="line">	pthread_rwlock_rdlock函数  </span><br><span class="line">	pthread_rwlock_wrlock函数</span><br><span class="line">	pthread_rwlock_tryrdlock函数</span><br><span class="line">	pthread_rwlock_trywrlock函数</span><br><span class="line">	pthread_rwlock_unlock函数</span><br><span class="line">以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。	</span><br><span class="line">	pthread_rwlock_t类型	用于定义一个读写锁变量。</span><br><span class="line">	pthread_rwlock_t rwlock;</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-init函数"><a href="#pthread-rwlock-init函数" class="headerlink" title="pthread_rwlock_init函数"></a>pthread_rwlock_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化一把读写锁</span><br><span class="line">	int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</span><br><span class="line">	参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-destroy函数"><a href="#pthread-rwlock-destroy函数" class="headerlink" title="pthread_rwlock_destroy函数"></a>pthread_rwlock_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一把读写锁</span><br><span class="line">	int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-rdlock函数"><a href="#pthread-rwlock-rdlock函数" class="headerlink" title="pthread_rwlock_rdlock函数"></a>pthread_rwlock_rdlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以读方式请求读写锁。（常简称为：请求读锁）</span><br><span class="line">    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-wrlock函数"><a href="#pthread-rwlock-wrlock函数" class="headerlink" title="pthread_rwlock_wrlock函数"></a>pthread_rwlock_wrlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">以写方式请求读写锁。（常简称为：请求写锁）</span><br><span class="line">    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-unlock函数"><a href="#pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_unlock函数"></a>pthread_rwlock_unlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解锁</span><br><span class="line">	int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-tryrdlock函数"><a href="#pthread-rwlock-tryrdlock函数" class="headerlink" title="pthread_rwlock_tryrdlock函数"></a>pthread_rwlock_tryrdlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非阻塞以读方式请求读写锁（非阻塞请求读锁）</span><br><span class="line">	int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_trywrlock函数"></a>pthread_rwlock_trywrlock函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">非阻塞以写方式请求读写锁（非阻塞请求写锁）</span><br><span class="line">	int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></div>



<h3 id="读写锁示例"><a href="#读写锁示例" class="headerlink" title="读写锁示例"></a>读写锁示例</h3><p>【rwlock.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_write</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        t=counter;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"====write %d:%lu:counter=%d ++counter=%d\n"</span>,i,pthread_self(),t,++counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_read</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----read %d:%lu:%d\n"</span>,i,pthread_self(),counter);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">8</span>];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i],<span class="literal">NULL</span>,th_write,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i+<span class="number">3</span>],<span class="literal">NULL</span>,th_read,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210113155305435.png" data-fancybox="group" data-caption="image-20210113155305435" class="fancybox"><img alt="image-20210113155305435" title="image-20210113155305435" data-src="image-20210113155305435.png" class="lazyload"></a></p>
<p>如图，每次写线程都是独立的，读线程是共享的，可以看见好几个读线程读到的都是同一个count，而写锁是相互独立的，图中有两个连续的写操作，其中肯定是先执行一个写线程再执行另一个写线程。</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</span><br></pre></td></tr></table></figure></div>

<h3 id="主要应用函数-2"><a href="#主要应用函数-2" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	pthread_cond_init函数</span><br><span class="line">	pthread_cond_destroy函数</span><br><span class="line">	pthread_cond_wait函数</span><br><span class="line">	pthread_cond_timedwait函数</span><br><span class="line">	pthread_cond_signal函数</span><br><span class="line">	pthread_cond_broadcast函数</span><br><span class="line">以上<span class="number">6</span> 个函数的返回值都是：成功返回<span class="number">0</span>， 失败直接返回错误号。</span><br><span class="line">	<span class="keyword">pthread_cond_t</span>类型	用于定义条件变量</span><br><span class="line">	<span class="keyword">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-cond-init函数"><a href="#pthread-cond-init函数" class="headerlink" title="pthread_cond_init函数"></a>pthread_cond_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化一个条件变量</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;		</span><br><span class="line">	参<span class="number">2</span>：attr表条件变量属性，通常为默认值，传<span class="literal">NULL</span>即可</span><br><span class="line">	也可以使用静态初始化的方法，初始化条件变量：</span><br><span class="line">		<span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-cond-destroy函数"><a href="#pthread-cond-destroy函数" class="headerlink" title="pthread_cond_destroy函数"></a>pthread_cond_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一个条件变量</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-cond-wait函数"><a href="#pthread-cond-wait函数" class="headerlink" title="pthread_cond_wait函数"></a>pthread_cond_wait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">阻塞等待一个条件变量</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line">函数作用：</span><br><span class="line">	<span class="number">1.</span>	阻塞等待条件变量cond（参<span class="number">1</span>）满足	</span><br><span class="line">	<span class="number">2.</span>	释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"> 		<span class="number">1.2</span>.两步为一个原子操作。</span><br><span class="line">	<span class="number">3.</span>	当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-cond-timedwait函数"><a href="#pthread-cond-timedwait函数" class="headerlink" title="pthread_cond_timedwait函数"></a>pthread_cond_timedwait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">限时等待一个条件变量</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line">	参<span class="number">3</span>：	参看man sem_timedwait函数，查看<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>结构体。</span></span><br><span class="line"><span class="class">		<span class="title">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">			<span class="keyword">time_t</span> tv_sec;		<span class="comment">/* seconds */</span> 秒</span><br><span class="line">			<span class="keyword">long</span>   tv_nsec;	<span class="comment">/* nanosecondes*/</span> 纳秒</span><br><span class="line">		&#125;								</span><br><span class="line">	形参abstime：绝对时间。										</span><br><span class="line">		如：time(<span class="literal">NULL</span>)返回的就是绝对时间。而alarm(<span class="number">1</span>)是相对时间，相对当前时间定时<span class="number">1</span>秒钟。	</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> = &#123;</span><span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 只能定时到 <span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日 <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span>秒(早已经过去) </span><br><span class="line">		正确用法：</span><br><span class="line">			<span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span>	定义timespec 结构体变量t</span><br><span class="line">			t.tv_sec = cur+<span class="number">1</span>; 定时<span class="number">1</span>秒</span><br><span class="line">pthread_cond_timedwait (&amp;cond, &amp;mutex, &amp;t); 传参  参考APUE<span class="number">.11</span><span class="number">.6</span>线程同步条件变量小节</span><br><span class="line">		在讲解setitimer函数时我们还提到另外一种时间类型：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">             <span class="keyword">time_t</span>      tv_sec;  <span class="comment">/* seconds */</span> 秒</span><br><span class="line">             <span class="keyword">suseconds_t</span> tv_usec; 	<span class="comment">/* microseconds */</span> 微秒</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-cond-signal函数"><a href="#pthread-cond-signal函数" class="headerlink" title="pthread_cond_signal函数"></a>pthread_cond_signal函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">唤醒至少一个阻塞在条件变量上的线程</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div>



<h4 id="pthread-cond-broadcast函数"><a href="#pthread-cond-broadcast函数" class="headerlink" title="pthread_cond_broadcast函数"></a>pthread_cond_broadcast函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">唤醒全部阻塞在条件变量上的线程</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure></div>



<h3 id="生产者消费者条件变量模型"><a href="#生产者消费者条件变量模型" class="headerlink" title="生产者消费者条件变量模型"></a>生产者消费者条件变量模型</h3><p><a href="05_%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.png" data-fancybox="group" data-caption="05_条件变量" class="fancybox"><img alt="05_条件变量" title="05_条件变量" data-src="05_%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程同步典型的案例即为生产者消费者模型，而借助条件变量来实现这一模型，是比较常见的一种方法。假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。两个线程同时操作一个共享资源（一般称之为汇聚），生产向其中添加产品，消费者从中消费掉产品。</span><br></pre></td></tr></table></figure></div>

<p>【conditionVar_product_consumer.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">head</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">mp</span>=<span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product=PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mp=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));</span><br><span class="line">        mp-&gt;num=rand()%<span class="number">400</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"produced----%d\n"</span>,mp-&gt;num);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        mp-&gt;next=head;</span><br><span class="line">        head=mp;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        pthread_cond_signal(&amp;has_product);</span><br><span class="line">        sleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;has_product,&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        mp=head;</span><br><span class="line">        head=mp-&gt;next;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----comsumer--%d\n"</span>,mp-&gt;num);</span><br><span class="line">        <span class="built_in">free</span>(mp);</span><br><span class="line">        mp=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid,ctid;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;ptid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;ctid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(ptid,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(ctid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210113200805248.png" data-fancybox="group" data-caption="image-20210113200805248" class="fancybox"><img alt="image-20210113200805248" title="image-20210113200805248" data-src="image-20210113200805248.png" class="lazyload"></a></p>
<p>一个顺序向下生产，一个逆序向上消费</p>
<h3 id="条件变量的优点"><a href="#条件变量的优点" class="headerlink" title="条件变量的优点"></a>条件变量的优点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相较于mutex而言，条件变量可以减少竞争。</span><br><span class="line">如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</span><br></pre></td></tr></table></figure></div>



<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进化版的互斥锁（1 --&gt; N）</span><br><span class="line">	由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</span><br><span class="line">	信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</span><br></pre></td></tr></table></figure></div>



<h3 id="主要应用函数-3"><a href="#主要应用函数-3" class="headerlink" title="主要应用函数"></a>主要应用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	sem_init函数</span><br><span class="line">	sem_destroy函数</span><br><span class="line">	sem_wait函数</span><br><span class="line">	sem_trywait函数	</span><br><span class="line">	sem_timedwait函数	</span><br><span class="line">	sem_post函数</span><br><span class="line">以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)</span><br><span class="line">	sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 </span><br><span class="line">	sem_t sem; 规定信号量sem不能 &lt; 0。头文件 &lt;semaphore.h&gt;</span><br></pre></td></tr></table></figure></div>



<h4 id="信号量基本操作"><a href="#信号量基本操作" class="headerlink" title="信号量基本操作"></a>信号量基本操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait:	1. 信号量大于0，则信号量--		（类比pthread_mutex_lock）</span><br><span class="line">	|		2. 信号量等于0，造成线程阻塞</span><br><span class="line">   对应</span><br><span class="line">	|</span><br><span class="line">sem_post：	将信号量++，同时唤醒阻塞在信号量上的线程	（类比pthread_mutex_unlock）</span><br><span class="line">但，由于sem_t的实现对用户隐藏，所以所谓的++、--操作只能通过函数来实现，而不能直接++、--符号。</span><br></pre></td></tr></table></figure></div>

<p><strong>信号量的初值，决定了占用信号量的线程的个数。</strong></p>
<h4 id="sem-init函数"><a href="#sem-init函数" class="headerlink" title="sem_init函数"></a>sem_init函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化一个信号量</span><br><span class="line">	int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">	参1：sem信号量	</span><br><span class="line">	参2：pshared取0用于线程间；取非0（一般为1）用于进程间	</span><br><span class="line">	参3：value指定信号量初值</span><br></pre></td></tr></table></figure></div>



<h4 id="sem-destroy函数"><a href="#sem-destroy函数" class="headerlink" title="sem_destroy函数"></a>sem_destroy函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">销毁一个信号量</span><br><span class="line">	int sem_destroy(sem_t *sem);</span><br></pre></td></tr></table></figure></div>



<h4 id="sem-wait函数"><a href="#sem-wait函数" class="headerlink" title="sem_wait函数"></a>sem_wait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给信号量加锁 -- </span><br><span class="line">	int sem_wait(sem_t *sem);</span><br></pre></td></tr></table></figure></div>



<h4 id="sem-post函数"><a href="#sem-post函数" class="headerlink" title="sem_post函数"></a>sem_post函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给信号量解锁 ++</span><br><span class="line">	 int sem_post(sem_t *sem);</span><br></pre></td></tr></table></figure></div>



<h4 id="sem-trywait函数"><a href="#sem-trywait函数" class="headerlink" title="sem_trywait函数"></a>sem_trywait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">尝试对信号量加锁 --	(与sem_wait的区别类比lock和trylock)</span><br><span class="line">	 int sem_trywait(sem_t *sem);</span><br></pre></td></tr></table></figure></div>



<h4 id="sem-timedwait函数"><a href="#sem-timedwait函数" class="headerlink" title="sem_timedwait函数"></a>sem_timedwait函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">限时尝试对信号量加锁 --</span><br><span class="line">	int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="line">	参2：abs_timeout采用的是绝对时间。			</span><br><span class="line">	定时1秒：</span><br><span class="line">		time_t cur &#x3D; time(NULL); 获取当前时间。</span><br><span class="line">		struct timespec t;	定义timespec 结构体变量t</span><br><span class="line">		t.tv_sec &#x3D; cur+1; 定时1秒</span><br><span class="line">		t.tv_nsec &#x3D; t.tv_sec +100; </span><br><span class="line">		sem_timedwait(&amp;sem, &amp;t); 传参</span><br></pre></td></tr></table></figure></div>

<p><a href="07_%E4%BF%A1%E5%8F%B7%E9%87%8F.png" data-fancybox="group" data-caption="07_信号量" class="fancybox"><img alt="07_信号量" title="07_信号量" data-src="07_%E4%BF%A1%E5%8F%B7%E9%87%8F.png" class="lazyload"></a></p>
<h3 id="生产者消费者信号量模型"><a href="#生产者消费者信号量模型" class="headerlink" title="生产者消费者信号量模型"></a>生产者消费者信号量模型</h3><p>【练习】：使用信号量完成线程间同步，模拟生产者，消费者问题。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">	规定：	如果□中有数据，生产者不能生产，只能阻塞。</span><br><span class="line">			如果□中没有数据，消费者不能消费，只能等待数据。</span><br><span class="line">	定义两个信号量：S满 &#x3D; 0， S空 &#x3D; 1 （S满代表满格的信号量，S空表示空格的信号量，程序起始，格子一定为空）</span><br><span class="line">	所以有：	T生产者主函数 &#123;				T消费者主函数 &#123;</span><br><span class="line">			     	sem_wait(S空);			     sem_wait(S满);</span><br><span class="line">			    	生产....				     	 消费....</span><br><span class="line">			     	sem_post(S满);			     sem_post(S空);</span><br><span class="line">				&#125;							&#125;</span><br><span class="line">	假设：	线程到达的顺序是:T生、T生、T消。</span><br><span class="line">	那么：	T生1 到达，将S空-1，生产，将S满+1</span><br><span class="line">			T生2 到达，S空已经为0， 阻塞</span><br><span class="line">			T消  到达，将S满-1，消费，将S空+1</span><br><span class="line">	三个线程到达的顺序是：T生1、T生2、T消。而执行的顺序是T生1、T消、T生2</span><br><span class="line">	这里，S空 表示空格子的总数，代表可占用信号量的线程总数--&gt;1。其实这样的话，信号量就等同于互斥锁。</span><br><span class="line">	但，如果S空&#x3D;2、3、4……就不一样了，该信号量同时可以由多个线程占用，不再是互斥的形式。因此我们说信号量是互斥锁的加强版。</span><br></pre></td></tr></table></figure></div>

<p>【sem_product_consumer.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[NUM];</span><br><span class="line"><span class="keyword">sem_t</span> blank_number,product_number;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;blank_number);</span><br><span class="line">        <span class="built_in">queue</span>[i]=rand()%<span class="number">1000</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"---product----%d\n"</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">        sem_post(&amp;product_number);</span><br><span class="line">        </span><br><span class="line">        i=(i+<span class="number">1</span>)%NUM;</span><br><span class="line">        sleep(rand()%<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;product_number);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"consume----%d\n"</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">        <span class="built_in">queue</span>[i]=<span class="number">0</span>;</span><br><span class="line">        sem_post(&amp;blank_number);</span><br><span class="line">        i=(i+<span class="number">1</span>)%NUM;</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">pthread_t</span> ptid,ctid;</span><br><span class="line">    </span><br><span class="line">    sem_init(&amp;blank_number,<span class="number">0</span>,NUM);</span><br><span class="line">    sem_init(&amp;product_number,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;ptid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;ctid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    pthread_join(ptid,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(ctid,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    sem_destroy(&amp;blank_number);</span><br><span class="line">    sem_destroy(&amp;product_number);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210114102538864.png" data-fancybox="group" data-caption="image-20210114102538864" class="fancybox"><img alt="image-20210114102538864" title="image-20210114102538864" data-src="image-20210114102538864.png" class="lazyload"></a></p>
<h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><h3 id="互斥量mutex-1"><a href="#互斥量mutex-1" class="headerlink" title="互斥量mutex"></a>互斥量mutex</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其属性为进程间共享。mutex的属性修改函数主要有以下几个。</span><br></pre></td></tr></table></figure></div>



<h4 id="主要应用函数-4"><a href="#主要应用函数-4" class="headerlink" title="主要应用函数"></a>主要应用函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t mattr 类型：		用于定义mutex锁的【属性】</span><br><span class="line">pthread_mutexattr_init函数：			初始化一个mutex属性对象</span><br><span class="line">	int pthread_mutexattr_init(pthread_mutexattr_t *attr);</span><br><span class="line">pthread_mutexattr_destroy函数：		销毁mutex属性对象 (而非销毁锁)</span><br><span class="line">	int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</span><br><span class="line">pthread_mutexattr_setpshared函数：	修改mutex属性。</span><br><span class="line">	int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</span><br><span class="line">	参2：pshared取值：</span><br><span class="line">		线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)</span><br><span class="line">		进程锁：PTHREAD_PROCESS_SHARED</span><br></pre></td></tr></table></figure></div>



<h4 id="进程间mutex示例"><a href="#进程间mutex示例" class="headerlink" title="进程间mutex示例"></a>进程间mutex示例</h4><p>进程间使用mutex来实现同步：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mt</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    mm=mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(*mm),PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANON,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(mm,<span class="number">0</span>,<span class="keyword">sizeof</span>(*mm));</span><br><span class="line">    </span><br><span class="line">    pthread_mutexattr_init(&amp;mm-&gt;mutexattr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;mm-&gt;mutexattr,PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;mm-&gt;mutex,&amp;mm-&gt;mutexattr);</span><br><span class="line">    </span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child-----num++   %d\n"</span>,mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            pthread_mutex_lock(&amp;mm-&gt;mutex);</span><br><span class="line">            (mm-&gt;num)+=<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent-----num+=2   %d\n"</span>,mm-&gt;num);</span><br><span class="line">            pthread_mutex_unlock(&amp;mm-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mm-&gt;mutexattr);</span><br><span class="line">    pthread_mutex_destroy(&amp;mm-&gt;mutex);</span><br><span class="line">    munmap(mm,<span class="keyword">sizeof</span>(*mm));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210114112524450.png" data-fancybox="group" data-caption="image-20210114112524450" class="fancybox"><img alt="image-20210114112524450" title="image-20210114112524450" data-src="image-20210114112524450.png" class="lazyload"></a></p>
<h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	借助 fcntl函数来实现锁机制。	操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。</span><br><span class="line">fcntl函数：	获取、设置文件访问控制属性。</span><br><span class="line">	int fcntl(int fd, int cmd, ... &#x2F;* arg *&#x2F; );</span><br><span class="line">	参2：</span><br><span class="line">		F_SETLK (struct flock *)	设置文件锁（trylock）</span><br><span class="line">		F_SETLKW (struct flock *) 设置文件锁（lock）W --&gt; wait</span><br><span class="line">		F_GETLK (struct flock *)	获取文件锁</span><br><span class="line">	参3：</span><br><span class="line">        struct flock &#123;</span><br><span class="line">              ...</span><br><span class="line">              short l_type;    	锁的类型：F_RDLCK 、F_WRLCK 、F_UNLCK</span><br><span class="line">              short l_whence;  	偏移位置：SEEK_SET、SEEK_CUR、SEEK_END </span><br><span class="line">              off_t l_start;   		起始偏移：1000</span><br><span class="line">              off_t l_len;     		长度：0表示整个文件加锁</span><br><span class="line">              pid_t l_pid;     	持有该锁的进程ID：(F_GETLK only)</span><br><span class="line">              ...</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure></div>

<p><a href="01_fcntl%E5%92%8C%E4%BD%8D%E5%9B%BE.png" data-fancybox="group" data-caption="01_fcntl和位图" class="fancybox"><img alt="01_fcntl和位图" title="01_fcntl和位图" data-src="01_fcntl%E5%92%8C%E4%BD%8D%E5%9B%BE.png" class="lazyload"></a></p>
<h4 id="进程间文件锁示例"><a href="#进程间文件锁示例" class="headerlink" title="进程间文件锁示例"></a>进程间文件锁示例</h4><p>多个进程对加锁文件进行访问： </p>
<p>1、选读锁</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">f_lock</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out filename\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((fd==<span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR))&lt;<span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">"open"</span>);</span><br><span class="line">    <span class="comment">//f_lock.l_type=F_WRLCK;</span></span><br><span class="line">    f_lock.l_type=F_RDLCK;</span><br><span class="line">    f_lock.l_whence=SEEK_SET;</span><br><span class="line">    f_lock.l_start=<span class="number">0</span>;</span><br><span class="line">    f_lock.l_len=<span class="number">0</span>;<span class="comment">//将整个文件加锁</span></span><br><span class="line">    </span><br><span class="line">    fcntl(fd,F_SETLKW,&amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get flock\n"</span>);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    f_lock.l_type=F_UNLCK;</span><br><span class="line">    fcntl(fd,F_SETLKW,&amp;f_lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"un flock\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210114120330676.png" data-fancybox="group" data-caption="image-20210114120330676" class="fancybox"><img alt="image-20210114120330676" title="image-20210114120330676" data-src="image-20210114120330676.png" class="lazyload"></a></p>
<p>如图，两个进程可以对加读锁的文件进行操作。</p>
<p>2、选写锁</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f_lock.l_type=F_WRLCK;</span><br><span class="line"><span class="comment">//f_lock.l_type=F_RDLCK;</span></span><br><span class="line">f_lock.l_whence=SEEK_SET;</span><br><span class="line">f_lock.l_start=<span class="number">0</span>;</span><br><span class="line">f_lock.l_len=<span class="number">0</span>;<span class="comment">//将整个文件加锁</span></span><br></pre></td></tr></table></figure></div>

<p>​    依然遵循“读共享、写独占”特性。但！如若进程不加锁直接操作文件，依然可访问成功，但数据势必会出现混乱。</p>
<p>【思考】：多线程中，可以使用文件锁吗？</p>
<p>​    多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p>
<h2 id="哲学家用餐模型分析"><a href="#哲学家用餐模型分析" class="headerlink" title="哲学家用餐模型分析"></a>哲学家用餐模型分析</h2><p><a href="08_%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%94%A8%E9%A4%90%E7%AE%80%E6%9E%90.png" data-fancybox="group" data-caption="08_哲学家用餐简析" class="fancybox"><img alt="08_哲学家用餐简析" title="08_哲学家用餐简析" data-src="08_%E5%93%B2%E5%AD%A6%E5%AE%B6%E7%94%A8%E9%A4%90%E7%AE%80%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选用互斥锁mutex，如创建5个， pthread_mutex_t m[5];</span><br><span class="line">模型抽象：	</span><br><span class="line">	5个哲学家 --&gt; 5个线程；	5支筷子 --&gt; 5把互斥锁		int left(左手)， right(右手)</span><br><span class="line">	5个哲学家使用相同的逻辑，可通用一个线程主函数，void *tfn(void *arg)，使用参数来表示线程编号：int i &#x3D; (int)arg;</span><br><span class="line">	哲学家线程根据编号知道自己是第几个哲学家，而后选定锁，锁住，吃饭。否则哲学家thinking。</span><br><span class="line">				   			 	 A   B   C   D   E</span><br><span class="line">	5支筷子，在逻辑上形成环： 0   1   2   3   4   分别对应5个哲学家：</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210114121742982.png" data-fancybox="group" data-caption="image-20210114121742982" class="fancybox"><img alt="image-20210114121742982" title="image-20210114121742982" data-src="image-20210114121742982.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">所以有：</span><br><span class="line">	if(i &#x3D;&#x3D; 4)	</span><br><span class="line">		left &#x3D; i, right &#x3D; 0;</span><br><span class="line">	else </span><br><span class="line">		left &#x3D; i, right &#x3D; i+1;</span><br><span class="line">振荡：如果每个人都攥着自己左手的锁，尝试去拿右手锁，拿不到则将锁释放。过会儿五个人又同时再攥着左手锁尝试拿右手锁，依然拿不到。如此往复形成另外一种极端死锁的现象——振荡。</span><br><span class="line">避免振荡现象：只需5个人中，任意一个人，拿锁的方向与其他人相逆即可(如：E，原来：左：4，右：0	现在：左：0， 右：4)。</span><br><span class="line">所以以上if else语句应改为：</span><br><span class="line">	if(i &#x3D;&#x3D; 4)	</span><br><span class="line">		left &#x3D; 0, right &#x3D; i;</span><br><span class="line">	else </span><br><span class="line">		left &#x3D; i, right &#x3D; i+1;</span><br><span class="line">而后， 首先应让哲学家尝试加左手锁：	</span><br><span class="line">while &#123; </span><br><span class="line">		pthread_mutex_lock(&amp;m[left]); 	如果加锁成功，函数返回再加右手锁，</span><br><span class="line">									如果失败，应立即释放左手锁，等待。</span><br><span class="line">		若，左右手都加锁成功 --&gt; 吃 --&gt; 吃完 --&gt; 释放锁（应先释放右手、再释放左手，是加锁顺序的逆			序）</span><br><span class="line">	&#125;</span><br><span class="line">主线程(main)中，初始化5把锁，销毁5把锁，创建5个线程（并将i传递给线程主函数），回收5个线程。</span><br></pre></td></tr></table></figure></div>

<p><strong>避免死锁的方法：</strong></p>
<p>​     <strong>1.</strong> <strong>当得不到所有所需资源时，放弃已经获得的资源，等待。</strong></p>
<p>​     <strong>2.</strong> <strong>保证资源的获取顺序，要求每个线程获取资源的顺序一致。</strong>如：A获取顺序1、2、3；B顺序应也是1、2、3。若B为3、2、1则易出现死锁现象。</p>
<h3 id="多进程版"><a href="#多进程版" class="headerlink" title="多进程版"></a>多进程版</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">相较于多线程需注意问题：</span><br><span class="line">	需注意如何共享信号量 (注意：坚决不能使用全局变量 sem_t s[5])</span><br><span class="line">实现：</span><br><span class="line">	main函数中：	</span><br><span class="line">		循环 sem_init(&amp;s[i], 0, 1); 将信号量初值设为1，信号量变为互斥锁。</span><br><span class="line">		循环 sem_destroy(&amp;s[i]);</span><br><span class="line">		循环 创建 5 个子进程。 if(i &lt; 5) 中完成子进程的代码逻辑。</span><br><span class="line">		循环 回收 5 个子进程。</span><br><span class="line">	子进程中：</span><br><span class="line">		if(i &#x3D;&#x3D; 4)  </span><br><span class="line">			left &#x3D; 0, right &#x3D;&#x3D; 4;</span><br><span class="line">		else	</span><br><span class="line">			left &#x3D; i, right &#x3D; i+1;	</span><br><span class="line">		while (1) &#123;</span><br><span class="line">			使用 sem_wait(&amp;s[left]) 锁左手，尝试锁右手，若成功 --&gt; 吃； 若不成功 --&gt; 将左手锁释放。</span><br><span class="line">			吃完后， 先释放右手锁，再释放左手锁。</span><br><span class="line">		&#125;</span><br><span class="line">【重点注意】：</span><br><span class="line">	直接将sem_t s[5]放在全局位置，试图用于子进程间共享是错误的！应将其定义放置与mmap共享映射区中。main中：</span><br><span class="line">	sem_t *s &#x3D; mmap(NULL, sizeof(sem_t) * 5, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON， -1， 0);</span><br><span class="line">	使用方式：将s当成数组首地址看待，与使用数组s[5]没有差异。</span><br></pre></td></tr></table></figure></div>

</div></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/30/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%85%8D%E5%87%86/1_.dat%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E8%A3%81%E5%89%AA/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>目标检测与配准/1_.dat文件转换方式与图形裁剪</span></div></a></div><div class="next-post pull_right"><a href="/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Lucky</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>