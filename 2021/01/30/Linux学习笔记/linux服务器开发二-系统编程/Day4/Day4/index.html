<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4 | Lucky's Blog</title><meta name="description" content="Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4"><meta name="author" content="Lucky"><meta name="copyright" content="Lucky"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4"><meta name="twitter:description" content="Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4"><meta property="og:url" content="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day4/Day4/"><meta property="og:site_name" content="Lucky's Blog"><meta property="og:description" content="Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day4/Day4/"><link rel="prev" title="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"><link rel="next" title="Linux学习笔记/linux服务器开发二-系统编程/Day2/Day2" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day2/Day2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Lucky's Blog" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Lucky's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">31</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号的概念"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">信号的概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号的机制"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">信号的机制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#与信号相关的事件和状态"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">与信号相关的事件和状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号的编号"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">信号的编号</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号4要素"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">信号4要素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux常规信号一览表"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">Linux常规信号一览表</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号的产生"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">信号的产生</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#终端按键产生信号"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">终端按键产生信号</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#硬件异常产生信号"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">硬件异常产生信号</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#kill函数-命令产生信号"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">kill函数&#x2F;命令产生信号</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#raise和abort函数"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">raise和abort函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#软件条件产生信号"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">软件条件产生信号</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#alarm函数"><span class="toc_mobile_items-number">2.5.1.</span> <span class="toc_mobile_items-text">alarm函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#setitimer函数"><span class="toc_mobile_items-number">2.5.2.</span> <span class="toc_mobile_items-text">setitimer函数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号集操作函数"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">信号集操作函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信号集设定"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">信号集设定</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sigprocmask函数"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">sigprocmask函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sigpendiing函数"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">sigpendiing函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号捕捉"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">信号捕捉</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#signal函数"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">signal函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#sigaction函数"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">sigaction函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#struct-sigaction结构体"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">struct sigaction结构体</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#信号捕捉特性"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">信号捕捉特性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内核实现信号捕捉过程"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">内核实现信号捕捉过程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#竞态条件（时序竞态）"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">竞态条件（时序竞态）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pause函数"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">pause函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#时序竞态"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">时序竞态</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#前导例"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">前导例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#时序问题分析"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">时序问题分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#解决时序问题"><span class="toc_mobile_items-number">5.2.3.</span> <span class="toc_mobile_items-text">解决时序问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#总结"><span class="toc_mobile_items-number">5.2.4.</span> <span class="toc_mobile_items-text">总结</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#全局变量异步I-O"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">全局变量异步I&#x2F;O</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可-不可重入函数"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text">可&#x2F;不可重入函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#注意事项"><span class="toc_mobile_items-number">5.4.1.</span> <span class="toc_mobile_items-text">注意事项</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#SIGCHLD信号"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">SIGCHLD信号</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SIGCHLD的产生条件"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">SIGCHLD的产生条件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#借助SIGCHLD信号回收子进程"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">借助SIGCHLD信号回收子进程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#子进程结束status处理方式"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">子进程结束status处理方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#SIGCHLD信号注意问题"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">SIGCHLD信号注意问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#信号传参"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">信号传参</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#发送信号传参"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">发送信号传参</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#捕捉信号传参"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">捕捉信号传参</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#中断系统调用"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">中断系统调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#终端"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">终端</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#终端的启动流程"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">终端的启动流程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#ttyname函数"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">ttyname函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#网络终端"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">网络终端</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#进程组"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">进程组</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#概念和特性"><span class="toc_mobile_items-number">10.1.</span> <span class="toc_mobile_items-text">概念和特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#进程组操作函数"><span class="toc_mobile_items-number">10.2.</span> <span class="toc_mobile_items-text">进程组操作函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#getpgrp函数"><span class="toc_mobile_items-number">10.2.1.</span> <span class="toc_mobile_items-text">getpgrp函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#getpgid函数"><span class="toc_mobile_items-number">10.2.2.</span> <span class="toc_mobile_items-text">getpgid函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#setpgid函数"><span class="toc_mobile_items-number">10.2.3.</span> <span class="toc_mobile_items-text">setpgid函数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#会话"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">会话</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建会话"><span class="toc_mobile_items-number">11.1.</span> <span class="toc_mobile_items-text">创建会话</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#getsid函数"><span class="toc_mobile_items-number">11.2.</span> <span class="toc_mobile_items-text">getsid函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#setsid函数"><span class="toc_mobile_items-number">11.3.</span> <span class="toc_mobile_items-text">setsid函数</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#守护进程"><span class="toc_mobile_items-number">12.</span> <span class="toc_mobile_items-text">守护进程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#创建守护进程模型"><span class="toc_mobile_items-number">12.1.</span> <span class="toc_mobile_items-text">创建守护进程模型</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#信号的概念"><span class="toc-number">1.</span> <span class="toc-text">信号的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#信号的机制"><span class="toc-number">1.1.</span> <span class="toc-text">信号的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与信号相关的事件和状态"><span class="toc-number">1.2.</span> <span class="toc-text">与信号相关的事件和状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号的编号"><span class="toc-number">1.3.</span> <span class="toc-text">信号的编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号4要素"><span class="toc-number">1.4.</span> <span class="toc-text">信号4要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux常规信号一览表"><span class="toc-number">1.5.</span> <span class="toc-text">Linux常规信号一览表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号的产生"><span class="toc-number">2.</span> <span class="toc-text">信号的产生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#终端按键产生信号"><span class="toc-number">2.1.</span> <span class="toc-text">终端按键产生信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件异常产生信号"><span class="toc-number">2.2.</span> <span class="toc-text">硬件异常产生信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill函数-命令产生信号"><span class="toc-number">2.3.</span> <span class="toc-text">kill函数&#x2F;命令产生信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raise和abort函数"><span class="toc-number">2.4.</span> <span class="toc-text">raise和abort函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#软件条件产生信号"><span class="toc-number">2.5.</span> <span class="toc-text">软件条件产生信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#alarm函数"><span class="toc-number">2.5.1.</span> <span class="toc-text">alarm函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setitimer函数"><span class="toc-number">2.5.2.</span> <span class="toc-text">setitimer函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号集操作函数"><span class="toc-number">3.</span> <span class="toc-text">信号集操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#信号集设定"><span class="toc-number">3.1.</span> <span class="toc-text">信号集设定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigprocmask函数"><span class="toc-number">3.2.</span> <span class="toc-text">sigprocmask函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigpendiing函数"><span class="toc-number">3.3.</span> <span class="toc-text">sigpendiing函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号捕捉"><span class="toc-number">4.</span> <span class="toc-text">信号捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#signal函数"><span class="toc-number">4.1.</span> <span class="toc-text">signal函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigaction函数"><span class="toc-number">4.2.</span> <span class="toc-text">sigaction函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-sigaction结构体"><span class="toc-number">4.2.1.</span> <span class="toc-text">struct sigaction结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号捕捉特性"><span class="toc-number">4.2.2.</span> <span class="toc-text">信号捕捉特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核实现信号捕捉过程"><span class="toc-number">4.3.</span> <span class="toc-text">内核实现信号捕捉过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#竞态条件（时序竞态）"><span class="toc-number">5.</span> <span class="toc-text">竞态条件（时序竞态）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pause函数"><span class="toc-number">5.1.</span> <span class="toc-text">pause函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时序竞态"><span class="toc-number">5.2.</span> <span class="toc-text">时序竞态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前导例"><span class="toc-number">5.2.1.</span> <span class="toc-text">前导例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时序问题分析"><span class="toc-number">5.2.2.</span> <span class="toc-text">时序问题分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决时序问题"><span class="toc-number">5.2.3.</span> <span class="toc-text">解决时序问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">5.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局变量异步I-O"><span class="toc-number">5.3.</span> <span class="toc-text">全局变量异步I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可-不可重入函数"><span class="toc-number">5.4.</span> <span class="toc-text">可&#x2F;不可重入函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意事项"><span class="toc-number">5.4.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIGCHLD信号"><span class="toc-number">6.</span> <span class="toc-text">SIGCHLD信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHLD的产生条件"><span class="toc-number">6.1.</span> <span class="toc-text">SIGCHLD的产生条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#借助SIGCHLD信号回收子进程"><span class="toc-number">6.2.</span> <span class="toc-text">借助SIGCHLD信号回收子进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子进程结束status处理方式"><span class="toc-number">6.3.</span> <span class="toc-text">子进程结束status处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHLD信号注意问题"><span class="toc-number">6.4.</span> <span class="toc-text">SIGCHLD信号注意问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号传参"><span class="toc-number">7.</span> <span class="toc-text">信号传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#发送信号传参"><span class="toc-number">7.1.</span> <span class="toc-text">发送信号传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕捉信号传参"><span class="toc-number">7.2.</span> <span class="toc-text">捕捉信号传参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中断系统调用"><span class="toc-number">8.</span> <span class="toc-text">中断系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终端"><span class="toc-number">9.</span> <span class="toc-text">终端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#终端的启动流程"><span class="toc-number">9.1.</span> <span class="toc-text">终端的启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ttyname函数"><span class="toc-number">9.2.</span> <span class="toc-text">ttyname函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络终端"><span class="toc-number">9.3.</span> <span class="toc-text">网络终端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程组"><span class="toc-number">10.</span> <span class="toc-text">进程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念和特性"><span class="toc-number">10.1.</span> <span class="toc-text">概念和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程组操作函数"><span class="toc-number">10.2.</span> <span class="toc-text">进程组操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getpgrp函数"><span class="toc-number">10.2.1.</span> <span class="toc-text">getpgrp函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getpgid函数"><span class="toc-number">10.2.2.</span> <span class="toc-text">getpgid函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setpgid函数"><span class="toc-number">10.2.3.</span> <span class="toc-text">setpgid函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会话"><span class="toc-number">11.</span> <span class="toc-text">会话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建会话"><span class="toc-number">11.1.</span> <span class="toc-text">创建会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getsid函数"><span class="toc-number">11.2.</span> <span class="toc-text">getsid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setsid函数"><span class="toc-number">11.3.</span> <span class="toc-text">setsid函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#守护进程"><span class="toc-number">12.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建守护进程模型"><span class="toc-number">12.1.</span> <span class="toc-text">创建守护进程模型</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2021-01-30<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-01-11</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号在我们的生活中随处可见， 如：古代战争中摔杯为号；现代战争中的信号弹；体育比赛中使用的信号枪......他们都有共性：1. 简单 2. 不能携带大量信息 3. 满足某个特设条件才发送。</span><br><span class="line">   信号是信息的载体，Linux&#x2F;UNIX 环境下，古老、经典的通信方式， 现下依然是主要的通信手段。</span><br><span class="line">Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。</span><br></pre></td></tr></table></figure></div>

<h3 id="信号的机制"><a href="#信号的机制" class="headerlink" title="信号的机制"></a>信号的机制</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。</span><br><span class="line">信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。</span><br></pre></td></tr></table></figure></div>

<p><strong>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</strong></p>
<p><a href="07_%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6.png" data-fancybox="group" data-caption="07_信号机制" class="fancybox"><img alt="07_信号机制" title="07_信号机制" data-src="07_%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6.png" class="lazyload"></a></p>
<p>如图，信号是由内核传给进程B，并由内核帮助进程B处理信号，并不是所说的A给B发送一个信号；并且信号不能为结构体，是因为其简单不能携带大量信息，只能携带一些状态信息。</p>
<h3 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">产生信号：</span><br><span class="line">	1. 按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\</span><br><span class="line">	2. 系统调用产生，如：kill、raise、abort</span><br><span class="line">	3. 软件条件产生，如：定时器alarm</span><br><span class="line">	4. 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</span><br><span class="line">	5. 命令产生，如：kill命令</span><br><span class="line">递达：递送并且到达进程。</span><br><span class="line">未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 </span><br><span class="line">信号的处理方式: </span><br><span class="line">	1. 执行默认动作 </span><br><span class="line">	2. 忽略(丢弃) ---不是真的忽略，而是处理方式为忽略，将未决信号中的对应信号置0</span><br><span class="line">	3. 捕捉(调用户处理函数)</span><br><span class="line">	Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。</span><br><span class="line">    阻塞信号集(信号屏蔽字)： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)</span><br><span class="line">未决信号集: </span><br><span class="line">	1. 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 </span><br><span class="line">	2. 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</span><br></pre></td></tr></table></figure></div>

<p><a href="11_%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97_%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png" data-fancybox="group" data-caption="11_信号屏蔽字_未决信号集" class="fancybox"><img alt="11_信号屏蔽字_未决信号集" title="11_信号屏蔽字_未决信号集" data-src="11_%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97_%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png" class="lazyload"></a></p>
<p>如图，若发送一个信号，将对应的未决信号集中的对应位置1，若此时阻塞信号集中对应位也为1，则信号处于未决态，无法将执行的程序中断。</p>
<h3 id="信号的编号"><a href="#信号的编号" class="headerlink" title="信号的编号"></a>信号的编号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">可以使用kill –l命令查看当前系统可使用的信号有哪些。</span><br><span class="line">1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br><span class="line">	不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210106174814199.png" data-fancybox="group" data-caption="image-20210106174814199" class="fancybox"><img alt="image-20210106174814199" title="image-20210106174814199" data-src="image-20210106174814199.png" class="lazyload"></a></p>
<h3 id="信号4要素"><a href="#信号4要素" class="headerlink" title="信号4要素"></a>信号4要素</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">与变量三要素类似的，每个信号也有其必备4要素，分别是：</span><br><span class="line">1. 编号 2. 名称 3. 事件 4. 默认处理动作 </span><br><span class="line">可通过man 7 signal查看帮助文档获取。</span><br><span class="line">Signal     	Value     Action   Comment</span><br><span class="line">────────────────────────────────────────────</span><br><span class="line">SIGHUP     	 1       Term    Hangup detected on controlling terminal or death of controlling process</span><br><span class="line">SIGINT       2       Term    Interrupt from keyboard</span><br><span class="line">SIGQUIT      3       Core    Quit from keyboard</span><br><span class="line">SIGILL       4       Core    Illegal Instruction</span><br><span class="line">SIGFPE       8       Core    Floating point exception</span><br><span class="line">SIGKILL      9       Term    Kill signal</span><br><span class="line">SIGSEGV    	 11      Core    Invalid memory reference</span><br><span class="line">SIGPIPE  	 13      Term    Broken pipe: write to pipe with no readers</span><br><span class="line">SIGALRM   	 14      Term    Timer signal from alarm(2)</span><br><span class="line">SIGTERM    	 15      Term    Termination signal</span><br><span class="line">SIGUSR1   30,10,16   Term    User-defined signal 1</span><br><span class="line">SIGUSR2   31,12,17   Term    User-defined signal 2</span><br><span class="line">SIGCHLD   20,17,18   Ign     Child stopped or terminated</span><br><span class="line">SIGCONT   19,18,25   Cont    Continue if stopped</span><br><span class="line">SIGSTOP   17,19,23   Stop    Stop process</span><br><span class="line">SIGTSTP   18,20,24   Stop    Stop typed at terminal</span><br><span class="line">SIGTTIN   21,21,26   Stop    Terminal input for background process</span><br><span class="line">SIGTTOU   22,22,27   Stop    Terminal output for background process</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210106175043191.png" data-fancybox="group" data-caption="image-20210106175043191" class="fancybox"><img alt="image-20210106175043191" title="image-20210106175043191" data-src="image-20210106175043191.png" class="lazyload"></a></p>
<h3 id="Linux常规信号一览表"><a href="#Linux常规信号一览表" class="headerlink" title="Linux常规信号一览表"></a>Linux常规信号一览表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程</span><br><span class="line">2) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动</span><br><span class="line">作为终止进程。</span><br><span class="line">3) SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信</span><br><span class="line">号。默认动作为终止进程。</span><br><span class="line">4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件</span><br><span class="line">5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。</span><br><span class="line">6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。</span><br><span class="line">7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</span><br><span class="line">8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。</span><br><span class="line">9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。</span><br><span class="line">10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line">11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。</span><br><span class="line">12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line">13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。</span><br><span class="line">14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。</span><br><span class="line">15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。</span><br><span class="line">16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</span><br><span class="line">17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。</span><br><span class="line">18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续&#x2F;忽略。</span><br><span class="line">19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</span><br><span class="line">20) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</span><br><span class="line">21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</span><br><span class="line">22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</span><br><span class="line">23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。</span><br><span class="line">24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。</span><br><span class="line">25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</span><br><span class="line">26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。</span><br><span class="line">27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。</span><br><span class="line">28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</span><br><span class="line">29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。</span><br><span class="line">30) SIGPWR：关机。默认动作为终止进程。</span><br><span class="line">31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。</span><br><span class="line">34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。</span><br></pre></td></tr></table></figure></div>



<h2 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h2><h3 id="终端按键产生信号"><a href="#终端按键产生信号" class="headerlink" title="终端按键产生信号"></a>终端按键产生信号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + c  → 2) SIGINT（终止&#x2F;中断）	 &quot;INT&quot; ----Interrupt</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107102830056.png" data-fancybox="group" data-caption="image-20210107102830056" class="fancybox"><img alt="image-20210107102830056" title="image-20210107102830056" data-src="image-20210107102830056.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + z  → 20) SIGTSTP（暂停&#x2F;停止）  &quot;T&quot; ----Terminal 终端。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107103100433.png" data-fancybox="group" data-caption="image-20210107103100433" class="fancybox"><img alt="image-20210107103100433" title="image-20210107103100433" data-src="image-20210107103100433.png" class="lazyload"></a></p>
<p>SIGTSTP是20号信号，默认动作为停止与终端交互的进程，而19号信号SIGTSTOP可以停止所有进程。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + \  → 3) SIGQUIT（退出）</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107103118578.png" data-fancybox="group" data-caption="image-20210107103118578" class="fancybox"><img alt="image-20210107103118578" title="image-20210107103118578" data-src="image-20210107103118578.png" class="lazyload"></a></p>
<p>对应3号信号，将该进程所使用的内存转移到其他地方让后将其结束。</p>
<h3 id="硬件异常产生信号"><a href="#硬件异常产生信号" class="headerlink" title="硬件异常产生信号"></a>硬件异常产生信号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">除0操作   → 8) SIGFPE (浮点数例外)	&quot;F&quot; -----float 浮点数。</span><br><span class="line">非法访问内存  → 11) SIGSEGV (段错误)</span><br><span class="line">总线错误  → 7) SIGBUS</span><br></pre></td></tr></table></figure></div>



<h3 id="kill函数-命令产生信号"><a href="#kill函数-命令产生信号" class="headerlink" title="kill函数/命令产生信号"></a>kill函数/命令产生信号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill命令产生信号：kill -SIGKILL pid</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107103620930.png" data-fancybox="group" data-caption="image-20210107103620930" class="fancybox"><img alt="image-20210107103620930" title="image-20210107103620930" data-src="image-20210107103620930.png" class="lazyload"></a></p>
<p><a href="image-20210107103650066.png" data-fancybox="group" data-caption="image-20210107103650066" class="fancybox"><img alt="image-20210107103650066" title="image-20210107103650066" data-src="image-20210107103650066.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kill函数：给指定进程发送指定信号(不一定杀死)</span><br><span class="line">    int kill(pid_t pid, int sig);	 成功：0；失败：-1 (ID非法，信号非法，普通用户杀init进程等权级问题)，设置errno</span><br><span class="line">	sig：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</span><br><span class="line">    pid &gt; 0:  发送信号给指定的进程。</span><br><span class="line">	pid &#x3D; 0:  发送信号给 与调用kill函数进程属于同一进程组的所有进程。</span><br><span class="line">	pid &lt; 0:  取|pid|发给对应进程组。</span><br><span class="line">	pid &#x3D; -1：发送给进程有权限发送的系统中所有进程。</span><br><span class="line">    进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。</span><br><span class="line">	权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid)  是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID &#x3D;&#x3D; 接收者实际或有效用户ID</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107104546769.png" data-fancybox="group" data-caption="image-20210107104546769" class="fancybox"><img alt="image-20210107104546769" title="image-20210107104546769" data-src="image-20210107104546769.png" class="lazyload"></a></p>
<p><strong>练习</strong>：循环创建5个子进程，任一子进程用kill函数终止其父进程。</p>
<p>【kill.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            q = pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child %d, getpid = %u\n"</span>, i, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        kill(q, SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107113218286.png" data-fancybox="group" data-caption="image-20210107113218286" class="fancybox"><img alt="image-20210107113218286" title="image-20210107113218286" data-src="image-20210107113218286.png" class="lazyload"></a></p>
<p>如图第二次时，第2号进程被杀死故不打印到屏幕。</p>
<p>注意：尽量使用宏来表示信号，因为有些信号对应的值在不同平台下不一样，但是宏不会变。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat | cat | cat</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107115133132.png" data-fancybox="group" data-caption="image-20210107115133132" class="fancybox"><img alt="image-20210107115133132" title="image-20210107115133132" data-src="image-20210107115133132.png" class="lazyload"></a></p>
<p>执行kill -9杀死第一个cat进程，发现所有的cat进程都死了，这是因为|管道，第一个cat的结果作为第二个cat的输入，而管道的输入端被关闭，即管道的写端关闭，那所有的cat都关闭，并且这种关闭方式bash没有提示。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 -2984杀死同一进程组的进程</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107115413981.png" data-fancybox="group" data-caption="image-20210107115413981" class="fancybox"><img alt="image-20210107115413981" title="image-20210107115413981" data-src="image-20210107115413981.png" class="lazyload"></a></p>
<p>如图杀死同一组的进程，bash会提示已杀死。</p>
<h3 id="raise和abort函数"><a href="#raise和abort函数" class="headerlink" title="raise和abort函数"></a>raise和abort函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raise 函数：给当前进程发送指定信号(自己给自己发)	raise(signo) &#x3D;&#x3D; kill(getpid(), signo);</span><br><span class="line">    	int raise(int sig); 成功：0，失败非0值</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, q;</span><br><span class="line"></span><br><span class="line">    raise(SIGINT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            q = pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child %d, getpid = %u\n"</span>, i, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        kill(q, SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107120328668.png" data-fancybox="group" data-caption="image-20210107120328668" class="fancybox"><img alt="image-20210107120328668" title="image-20210107120328668" data-src="image-20210107120328668.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abort 函数：给自己发送异常终止信号 6) SIGABRT 信号，终止并产生core文件</span><br><span class="line">    	void abort(void); 该函数无返回</span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">            q = pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child %d, getpid = %u\n"</span>, i, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        kill(q, SIGKILL);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107120317531.png" data-fancybox="group" data-caption="image-20210107120317531" class="fancybox"><img alt="image-20210107120317531" title="image-20210107120317531" data-src="image-20210107120317531.png" class="lazyload"></a></p>
<h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h3><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。</span><br><span class="line">每个进程都有且只有唯一个定时器。</span><br><span class="line">unsigned int alarm(unsigned int seconds); 返回0或剩余的秒数，无失败。</span><br><span class="line">常用：取消定时器alarm(0)，返回旧闹钟余下秒数。</span><br><span class="line">例：alarm(5) → 3sec → alarm(4) → 5sec → alarm(5) → alarm(0)</span><br><span class="line">   定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸...无论进程处于何种状态，alarm都计时。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107150252531.png" data-fancybox="group" data-caption="image-20210107150252531" class="fancybox"><img alt="image-20210107150252531" title="image-20210107150252531" data-src="image-20210107150252531.png" class="lazyload"></a></p>
<p><a href="03_%E9%97%B9%E9%92%9F.png" data-fancybox="group" data-caption="03_闹钟" class="fancybox"><img alt="03_闹钟" title="03_闹钟" data-src="03_%E9%97%B9%E9%92%9F.png" class="lazyload"></a></p>
<p>练习：编写程序，测试你使用的计算机1秒钟能数多少个数。</p>
<p>【alarm .c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107150806849.png" data-fancybox="group" data-caption="image-20210107150806849" class="fancybox"><img alt="image-20210107150806849" title="image-20210107150806849" data-src="image-20210107150806849.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用time命令查看程序执行的时间。	程序运行的瓶颈在于IO，优化程序，首选优化IO。</span><br><span class="line">	实际执行时间 &#x3D; 系统时间 + 用户时间 + 等待时间</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107151157727.png" data-fancybox="group" data-caption="image-20210107151157727" class="fancybox"><img alt="image-20210107151157727" title="image-20210107151157727" data-src="image-20210107151157727.png" class="lazyload"></a></p>
<h4 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">   int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);	成功：0；失败：-1，设置errno</span><br><span class="line">参数：which：指定定时方式</span><br><span class="line">	1、自然定时：ITIMER_REAL → 14）SIGLARM				 		计算自然时间</span><br><span class="line">	2、虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM  	 只计算进程占用cpu的时间</span><br><span class="line">	3、运行时计时(用户+内核)：ITIMER_PROF → 27）SIGPROF		 计算占用cpu及执行系统调用的时间</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107152551279.png" data-fancybox="group" data-caption="image-20210107152551279" class="fancybox"><img alt="image-20210107152551279" title="image-20210107152551279" data-src="image-20210107152551279.png" class="lazyload"></a></p>
<p>new_value：定时时长</p>
<p>old_value：上次定时剩余时间</p>
<p><a href="image-20210107152959741.png" data-fancybox="group" data-caption="image-20210107152959741" class="fancybox"><img alt="image-20210107152959741" title="image-20210107152959741" data-src="image-20210107152959741.png" class="lazyload"></a></p>
<p>it_interval：指定两次定时间隔时长</p>
<p>it_value：定时时长</p>
<p>tv_sec：秒级</p>
<p>tv_usec：微秒级</p>
<p><strong>练习:</strong> 使用setitimer函数实现alarm函数，重复计算机1秒数数程序。</p>
<p>【setitimer.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * struct itimerval  &#123;</span></span><br><span class="line"><span class="comment">        struct timeval&#123;</span></span><br><span class="line"><span class="comment">            it_value.tv_sec;</span></span><br><span class="line"><span class="comment">            it_value.tv_usec;</span></span><br><span class="line"><span class="comment">        &#125; it_interval;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        struct timeval &#123;</span></span><br><span class="line"><span class="comment">            it_value.tv_sec;</span></span><br><span class="line"><span class="comment">            it_value.tv_usec;</span></span><br><span class="line"><span class="comment">        &#125; it_value;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125; it, oldit;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">my_alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	it.it_value.tv_sec = sec;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_sec = <span class="number">0</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = setitimer(ITIMER_REAL, &amp;it, &amp;oldit);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setitimer"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> oldit.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	my_alarm(<span class="number">1</span>);  <span class="comment">//alarm(sec);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; ; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107160411851.png" data-fancybox="group" data-caption="image-20210107160411851" class="fancybox"><img alt="image-20210107160411851" title="image-20210107160411851" data-src="image-20210107160411851.png" class="lazyload"></a></p>
<p><strong>拓展练习</strong>，结合man page编写程序，测试it_interval、it_value这两个参数的作用。 </p>
<p>提示：   it_interval：用来设定两次定时任务之间间隔的时间。</p>
<p>​               it_value：定时的时长                </p>
<p>两个参数都设置为0，即清0操作。</p>
<p><strong>你需要知道的：</strong></p>
<p>信号捕捉：</p>
<p><a href="image-20210107161614717.png" data-fancybox="group" data-caption="image-20210107161614717" class="fancybox"><img alt="image-20210107161614717" title="image-20210107161614717" data-src="image-20210107161614717.png" class="lazyload"></a></p>
<p>signal中两个参数，第一个为信号编号，第二个为函数指针，该函数指针为一个输入为int类型，输出为void类型的函数指针，捕捉到的信号不去执行默认操作而是执行函数指针所指向的函数。</p>
<p>【setitimer1.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	signal(SIGALRM, myfunc);   <span class="comment">//注册SIGALRM信号的捕捉处理函数。</span></span><br><span class="line"></span><br><span class="line">	it.it_value.tv_sec = <span class="number">5</span>;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	it.it_interval.tv_sec = <span class="number">3</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">"setitimer error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107201159265.png" data-fancybox="group" data-caption="image-20210107201159265" class="fancybox"><img alt="image-20210107201159265" title="image-20210107201159265" data-src="image-20210107201159265.png" class="lazyload"></a></p>
<p>如图，第一次设定的时间为5s，5s后捕捉到了SIGALRM信号进行打印，之后每间隔3s发送一次SIGALRM信号。</p>
<h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。</span><br></pre></td></tr></table></figure></div>

<h3 id="信号集设定"><a href="#信号集设定" class="headerlink" title="信号集设定"></a>信号集设定</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sigset_t  set;		&#x2F;&#x2F; typedef unsigned long sigset_t; </span><br><span class="line">int sigemptyset(sigset_t *set);			        将某个信号集清0		 	 成功：0；失败：-1</span><br><span class="line">int sigfillset(sigset_t *set);				    将某个信号集置1		  	 成功：0；失败：-1</span><br><span class="line">int sigaddset(sigset_t *set, int signum);		将某个信号加入信号集  	   成功：0；失败：-1</span><br><span class="line">int sigdelset(sigset_t *set, int signum);		将某个信号清出信号集   	   成功：0；失败：-1</span><br><span class="line">int sigismember(const sigset_t *set, int signum);判断某个信号是否在信号集中	返回值：在集合：1；不在：0；出错：-1  </span><br><span class="line">sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。</span><br><span class="line">对比认知select 函数。</span><br></pre></td></tr></table></figure></div>

<p><a href="08_%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png" data-fancybox="group" data-caption="08_信号集操作函数" class="fancybox"><img alt="08_信号集操作函数" title="08_信号集操作函数" data-src="08_%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png" class="lazyload"></a></p>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中)</span><br><span class="line">严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);	成功：0；失败：-1，设置errno</span><br><span class="line">参数：</span><br><span class="line">	set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。</span><br><span class="line">	oldset：传出参数，保存旧的信号屏蔽集。</span><br><span class="line">	how参数取值：	假设当前的信号屏蔽字为mask</span><br><span class="line">		1.	SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask &#x3D; mask|set</span><br><span class="line">		2.	SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask &#x3D; mask &amp; ~set</span><br><span class="line">		3.	SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask &#x3D; set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。</span><br></pre></td></tr></table></figure></div>



<h3 id="sigpendiing函数"><a href="#sigpendiing函数" class="headerlink" title="sigpendiing函数"></a>sigpendiing函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读取当前进程的未决信号集</span><br><span class="line">int sigpending(sigset_t *set);	set传出参数。   返回值：成功：0；失败：-1，设置errno</span><br></pre></td></tr></table></figure></div>

<p>练习：编写程序。把所有常规信号的未决状态打印至屏幕。</p>
<p>【sigpending.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printped</span><span class="params">(<span class="keyword">sigset_t</span> *ped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sigismember(ped,i)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>,oldset,ped;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;ped);</span><br><span class="line">        printped(&amp;ped);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210107230517107.png" data-fancybox="group" data-caption="image-20210107230517107" class="fancybox"><img alt="image-20210107230517107" title="image-20210107230517107" data-src="image-20210107230517107.png" class="lazyload"></a></p>
<h2 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h2><h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注册一个信号捕捉函数：</span><br><span class="line">	typedef void (*sighandler_t)(int);</span><br><span class="line">	sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">	该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。</span><br><span class="line">    void (*signal(int signum, void (*sighandler_t)(int))) (int);</span><br><span class="line">    能看出这个函数代表什么意思吗？  注意多在复杂结构中使用typedef。</span><br><span class="line">	函数指针sighandler_t</span><br></pre></td></tr></table></figure></div>

<p>【signal1.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catchsigint</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I catch you---SIGINT\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sighandler_t</span> handler;</span><br><span class="line"></span><br><span class="line">    handler = signal(SIGINT, catchsigint);</span><br><span class="line">    <span class="keyword">if</span> (handler == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">"signal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210108214922129.png" data-fancybox="group" data-caption="image-20210108214922129" class="fancybox"><img alt="image-20210108214922129" title="image-20210108214922129" data-src="image-20210108214922129.png" class="lazyload"></a></p>
<h3 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数）</span><br><span class="line">    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);  成功：0；失败：-1，设置errno</span><br><span class="line">	参数：</span><br><span class="line">		act：传入参数，新的处理方式。</span><br><span class="line">		oldact：传出参数，旧的处理方式。</span><br></pre></td></tr></table></figure></div>

<p><a href="05_%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png" data-fancybox="group" data-caption="05_信号捕捉" class="fancybox"><img alt="05_信号捕捉" title="05_信号捕捉" data-src="05_%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png" class="lazyload"></a></p>
<h4 id="struct-sigaction结构体"><a href="#struct-sigaction结构体" class="headerlink" title="struct sigaction结构体"></a>struct sigaction结构体</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">        void     (*sa_handler)(int);</span><br><span class="line">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">        sigset_t   sa_mask; </span><br><span class="line">        int       sa_flags; </span><br><span class="line">        void     (*sa_restorer)(void);</span><br><span class="line">    &#125;;</span><br><span class="line">	sa_restorer：该元素是过时的，不应该使用，POSIX.1标准将不指定该元素。(弃用)</span><br><span class="line">	sa_sigaction：当sa_flags被指定为SA_SIGINFO标志时，使用该信号处理程序。(很少使用)  </span><br><span class="line">重点掌握：</span><br><span class="line">	1、sa_handler：指定信号捕捉后的处理函数名(即注册函数)。也可赋值为SIG_IGN表忽略 或 SIG_DFL表执行默认动作</span><br><span class="line">	2、sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置。</span><br><span class="line">	3、sa_flags：通常设置为0，表使用默认属性。</span><br></pre></td></tr></table></figure></div>





<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.	进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。</span><br><span class="line">2.	XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。---sa_flag&#x3D;0</span><br><span class="line">3.	阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</span><br><span class="line">理由：信号执行与否看的是未决信号集，该集合只能指示该信号是否被处理，没有记录有多少个信号的功能，所以发送多个同一信号只处理其中一个。</span><br></pre></td></tr></table></figure></div>

<p><strong>练习1</strong>：为某个信号设置捕捉函数</p>
<p>【sigaction1.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  <span class="comment">//默认属性   信号捕捉函数执行期间，自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210109100632318.png" data-fancybox="group" data-caption="image-20210109100632318" class="fancybox"><img alt="image-20210109100632318" title="image-20210109100632318" data-src="image-20210109100632318.png" class="lazyload"></a></p>
<p>如图，内核对SIGINT信号进行捕捉，每一次发送SIGINT(Ctrl+C)信号，捕捉后执行dicatch函数。</p>
<p><strong>练习2</strong>： 验证在信号处理函数执行期间，该信号多次递送，那么只在处理函数之行结束后，处理一次。</p>
<p><strong>练习3</strong>：验证sa_mask在捕捉函数执行期间的屏蔽作用。</p>
<p>【sigaction2.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">docatch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d signal is catched\n"</span>, signo);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----docatch finish------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    act.sa_handler = docatch;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaddset(&amp;act.sa_mask, SIGQUIT);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  <span class="comment">//默认属性   信号捕捉函数执行期间，自动屏蔽本信号</span></span><br><span class="line"></span><br><span class="line">    ret = sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sigaction error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210109102844539.png" data-fancybox="group" data-caption="image-20210109102844539" class="fancybox"><img alt="image-20210109102844539" title="image-20210109102844539" data-src="image-20210109102844539.png" class="lazyload"></a></p>
<p>在函数中设置sleep(10)模拟捕捉程序执行时间，如图，在捕捉到ctrl+c后，这10 s内向进程发送多个ctrl+c程序没有反应，直到前一个信号处理函数执行完成后仅仅执行了一次捕捉函数的调用；之后在信号处理函数执行期间对进程发送多个ctrl+\，由于在信号处理函数执行期间，根据sa_mask的设置对于SIGQUIT信号是屏蔽的，等处理函数执行完毕后，屏蔽字恢复到原来的状态，由于未对SIGQUIT实行屏蔽故执行SIGQUIT的默认处理动作。</p>
<h3 id="内核实现信号捕捉过程"><a href="#内核实现信号捕捉过程" class="headerlink" title="内核实现信号捕捉过程"></a>内核实现信号捕捉过程</h3><p><a href="image-20210109103007490.png" data-fancybox="group" data-caption="image-20210109103007490" class="fancybox"><img alt="image-20210109103007490" title="image-20210109103007490" data-src="image-20210109103007490.png" class="lazyload"></a></p>
<p>程序首先在用户空间执行，由于中断等进入内核处理，看未决信号集中信号是否可以递送，若产生并且抵达而且设置的是捕捉，内核会去调用信号处理函数（回调函数），回到用户区去执行函数内容，执行完后用系统调用sigreturn回到内核（回到主调函数），最后返回用户区往中断位置继续执行。</p>
<p><strong>注意：signal和sigaction都是用于注册信号捕捉函数，执行捕捉是由内核完成的。</strong></p>
<h2 id="竞态条件（时序竞态）"><a href="#竞态条件（时序竞态）" class="headerlink" title="竞态条件（时序竞态）"></a>竞态条件（时序竞态）</h2><h3 id="pause函数"><a href="#pause函数" class="headerlink" title="pause函数"></a>pause函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用该函数可以造成进程主动挂起，等待信号唤醒。调用该系统调用的进程将处于阻塞状态(主动放弃cpu) 直到有信号递达将其唤醒。</span><br><span class="line">   int pause(void);	返回值：-1 并设置errno为EINTR</span><br><span class="line">返回值：</span><br><span class="line">	1、如果信号的默认处理动作是终止进程，则进程终止，pause函数么有机会返回。</span><br><span class="line">	2、如果信号的默认处理动作是忽略，进程继续处于挂起状态，pause函数不返回。</span><br><span class="line">	3、如果信号的处理动作是捕捉，则【调用完信号处理函数之后，pause返回-1】</span><br><span class="line">	   errno设置为EINTR，表示“被信号中断”。想想我们还有哪个函数只有出错返回值。</span><br><span class="line">	4、pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210109111424950.png" data-fancybox="group" data-caption="image-20210109111424950" class="fancybox"><img alt="image-20210109111424950" title="image-20210109111424950" data-src="image-20210109111424950.png" class="lazyload"></a></p>
<p>注意：返回-1表示成功返回</p>
<p><strong>练习</strong>：使用pause和alarm来实现sleep函数。  </p>
<p>注意，unslept = alarm(0)的用法。</p>
<p>例如：睡觉，alarm(10)闹铃。   </p>
<p>正常： 10后闹铃将我唤醒，这时额外设置alarm(0)取消闹铃，不会出错。</p>
<p>异常： 5分钟，被其他事物吵醒，alarm(0)取消闹铃防止打扰。</p>
<p>【mysleep.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* nothing to do */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    alarm(seconds); </span><br><span class="line">    pause();</span><br><span class="line"></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);<span class="comment">//防止在alarm记时未完成pause收到信号，用于结束闹钟并返回剩余时间</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);<span class="comment">//恢复捕捉SIGALRM默认处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3 seconds later\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210109114647803.png" data-fancybox="group" data-caption="image-20210109114647803" class="fancybox"><img alt="image-20210109114647803" title="image-20210109114647803" data-src="image-20210109114647803.png" class="lazyload"></a></p>
<p>模拟sleep函数，提前在pause()即阻塞进程前设置一个alarm，然后注册SIGALRM的捕捉执行信号处理函数，之后进程被唤醒，继续执行接下来的程序，alarm(0)为了防止阻塞提前结束用于结束定时使用。</p>
<h3 id="时序竞态"><a href="#时序竞态" class="headerlink" title="时序竞态"></a>时序竞态</h3><h4 id="前导例"><a href="#前导例" class="headerlink" title="前导例"></a>前导例</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设想如下场景：</span><br><span class="line">	欲睡觉，定闹钟10分钟，希望10分钟后闹铃将自己唤醒。</span><br><span class="line">	正常：定时，睡觉，10分钟后被闹钟唤醒。</span><br><span class="line">	异常：闹钟定好后，被唤走，外出劳动，20分钟后劳动结束。回来继续睡觉计划，但劳动期间闹钟已经响过，不会再将我唤醒。</span><br></pre></td></tr></table></figure></div>

<p>在闹钟计时与pause()执行期间失去了cpu，但是闹钟依旧在计时，等计时完成后内核去调用信号处理函数之后再回到用户态去调用pause，但是SIGALRM已经处理完毕，pause就不会再收到信号唤醒了。</p>
<h4 id="时序问题分析"><a href="#时序问题分析" class="headerlink" title="时序问题分析"></a>时序问题分析</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">回顾，借助pause和alarm实现的mysleep函数。设想如下时序：</span><br><span class="line">	1. 注册SIGALRM信号处理函数 	（sigaction...)</span><br><span class="line">	2. 调用alarm(1) 函数设定闹钟1秒。</span><br><span class="line">	3. 函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。</span><br><span class="line">	4. 1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决)</span><br><span class="line">	5. 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。</span><br><span class="line">	6. 信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒）</span><br><span class="line">	7. SIGALRM信号已经处理完毕，pause不会等到。</span><br></pre></td></tr></table></figure></div>

<h4 id="解决时序问题"><a href="#解决时序问题" class="headerlink" title="解决时序问题"></a>解决时序问题</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以通过设置屏蔽SIGALRM的方法来控制程序执行逻辑，但无论如何设置，程序都有可能在“解除信号屏蔽”与“挂起等待信号”这个两个操作间隙失去cpu资源。除非将这两步骤合并成一个“原子操作”。sigsuspend函数具备这个功能。在对时序要求严格的场合下都应该使用sigsuspend替换pause。 	</span><br><span class="line">int sigsuspend(const sigset_t *mask);	挂起等待信号。</span><br><span class="line">sigsuspend函数调用期间，进程信号屏蔽字由其参数mask指定。</span><br><span class="line">可将某个信号（如SIGALRM）从临时信号屏蔽字mask中删除，这样在调用sigsuspend时将解除对该信号的屏蔽，然后挂起等待，当sigsuspend返回时，进程的信号屏蔽字恢复为原来的值。如果原来对该信号是屏蔽态，sigsuspend函数返回后仍然屏蔽该信号。</span><br></pre></td></tr></table></figure></div>

<p>改进版mysleep</p>
<p>【sigsuspend.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>,<span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> newmask,oldmask,suspmask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line">    </span><br><span class="line">    newact.sa_handler=sig_alrm;</span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags=<span class="number">0</span>;</span><br><span class="line">    sigaction(SIGALRM,&amp;newact,&amp;oldact);</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask,SIGALRM);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);</span><br><span class="line">    </span><br><span class="line">    alarm(nsecs);</span><br><span class="line">    suspmask=oldmask;</span><br><span class="line">    sigdelset(&amp;suspmask,SIGALRM);</span><br><span class="line">    </span><br><span class="line">    sigsuspend(&amp;suspmask);</span><br><span class="line">    unslept=alarm(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    sigaction(SIGALRM,&amp;oldact,<span class="literal">NULL</span>);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;oldmask,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mysleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"3 seconds later\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210109213556136.png" data-fancybox="group" data-caption="image-20210109213556136" class="fancybox"><img alt="image-20210109213556136" title="image-20210109213556136" data-src="image-20210109213556136.png" class="lazyload"></a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">竞态条件，跟系统负载有很紧密的关系，体现出信号的不可靠性。系统负载越严重，信号不可靠性越强。</span><br><span class="line">  	不可靠由其实现原理所致。信号是通过软件方式实现(跟内核调度高度依赖，延时性强)，每次系统调用结束后，或中断处理处理结束后，需通过扫描PCB中的未决信号集，来判断是否应处理某个信号。当系统负载过重时，会出现时序混乱。</span><br><span class="line">这种意外情况只能在编写程序过程中，提早预见，主动规避，而无法通过gdb程序调试等其他手段弥补。且由于该错误不具规律性，后期捕捉和重现十分困难。</span><br></pre></td></tr></table></figure></div>



<h3 id="全局变量异步I-O"><a href="#全局变量异步I-O" class="headerlink" title="全局变量异步I/O"></a>全局变量异步I/O</h3><p>分析如下父子进程交替数数程序。当捕捉函数里面的sleep取消，程序即会出现问题。请分析原因。</p>
<p>【sync_process.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am child  %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_parent</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I am parent %d\t%d\n"</span>, getpid(), n);</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">"fork"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;     </span><br><span class="line">        n = <span class="number">1</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        act.sa_handler = do_sig_parent;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR2, &amp;act, <span class="literal">NULL</span>);<span class="comment">//注册自己的信号捕捉函数  父使用SIGUSR2信号</span></span><br><span class="line">        do_sig_parent(<span class="number">0</span>);						  </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* wait for signal */</span>;</span><br><span class="line">           <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;                         <span class="comment">//父进程数数完成</span></span><br><span class="line">                kill(pid, SIGUSR1);</span><br><span class="line">                flag = <span class="number">0</span>;<span class="comment">//标志已经给子进程发送完信号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;       </span><br><span class="line">        n = <span class="number">2</span>;</span><br><span class="line">        act.sa_handler = do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGUSR1, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* waiting for a signal */</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                kill(getppid(), SIGUSR2);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210110163018339.png" data-fancybox="group" data-caption="image-20210110163018339" class="fancybox"><img alt="image-20210110163018339" title="image-20210110163018339" data-src="image-20210110163018339.png" class="lazyload"></a></p>
<p>将sleep去掉以后，父可能出现在kill命令后失去了cpu，子进程捕捉到信号后执行信号处理函数，之后子进程的flag=1，继续给父进程发送信号，父进行进行捕捉，如何执行父进程的信号处理函数flag=1，现在父进程抢到了cpu，flag=0，无法继续给子进程发送信号， 子进程给父进程的信号也早已发送完毕，故终止。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例中，通过flag变量标记程序实行进度。flag置1表示数数完成。flag置0表示给对方发送信号完成。</span><br><span class="line">问题出现的位置，在父子进程kill函数之后需要紧接着调用 flag，将其置0，标记信号已经发送。但，在这期间很有可能被kernel调度，失去执行权利，而对方获取了执行时间，通过发送信号回调捕捉函数，从而修改了全局的flag。</span><br><span class="line">如何解决该问题呢？可以使用后续课程讲到的“锁”机制。当操作全局变量的时候，通过加锁、解锁来解决该问题。</span><br><span class="line">现阶段，我们在编程期间如若使用全局变量，应在主观上注意全局变量的异步IO可能造成的问题。</span><br></pre></td></tr></table></figure></div>



<h3 id="可-不可重入函数"><a href="#可-不可重入函数" class="headerlink" title="可/不可重入函数"></a>可/不可重入函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种。看如下时序。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210110172138721.png" data-fancybox="group" data-caption="image-20210110172138721" class="fancybox"><img alt="image-20210110172138721" title="image-20210110172138721" data-src="image-20210110172138721.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显然，insert函数是不可重入函数，重入调用，会导致意外结果呈现。究其原因，是该函数内部实现使用了全局变量。</span><br></pre></td></tr></table></figure></div>

<p>由于本来调用两次insert应该新插入了两个节点，但是只有一个，故为不可重入函数，导致insert函数不可重入的原因是，insert还未执行完信号来了又去执行插入操作。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.	定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free</span><br><span class="line">2.	信号捕捉函数应设计为可重入函数</span><br><span class="line">3.	信号处理程序可以调用的可重入函数可参阅man 7 signal </span><br><span class="line">4.	没有包含在上述列表中的函数大多是不可重入的，其原因为：</span><br><span class="line">	a)	使用静态数据结构</span><br><span class="line">	b)	调用了malloc或free</span><br><span class="line">	c)	是标准I&#x2F;O函数</span><br></pre></td></tr></table></figure></div>



<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><h3 id="SIGCHLD的产生条件"><a href="#SIGCHLD的产生条件" class="headerlink" title="SIGCHLD的产生条件"></a>SIGCHLD的产生条件</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子进程终止时</span><br><span class="line">子进程接收到SIGSTOP信号停止时</span><br><span class="line">子进程处在停止态，接受到SIGCONT后唤醒时</span><br></pre></td></tr></table></figure></div>

<p>即在子进程状态发生变化时发出。</p>
<h3 id="借助SIGCHLD信号回收子进程"><a href="#借助SIGCHLD信号回收子进程" class="headerlink" title="借助SIGCHLD信号回收子进程"></a>借助SIGCHLD信号回收子进程</h3><p>​        子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收。</p>
<p>【sigchild.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_sig_child</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid=waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//非阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"----child %d exit %d\n"</span>,pid,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d cancel siganl %d\n"</span>,pid,WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"fork() error"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"chils id:%d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        struct sigaction act;</span><br><span class="line">        act.sa_handler=do_sig_child;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags=<span class="number">0</span>;</span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"parent ID:%d\n"</span>,getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210110201638958.png" data-fancybox="group" data-caption="image-20210110201638958" class="fancybox"><img alt="image-20210110201638958" title="image-20210110201638958" data-src="image-20210110201638958.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果每创建一个子进程后不使用sleep可以吗？可不可以将程序中，捕捉函数内部的while替换为if？为什么？ </span><br><span class="line">	if ((pid &#x3D; waitpid(0, &amp;status, WNOHANG)) &gt; 0) &#123; ... &#125;	</span><br><span class="line">思考：信号不支持排队，当正在执行SIGCHLD捕捉函数时，再过来一个或多个SIGCHLD信号怎么办？</span><br><span class="line">阻塞，只执行其中的一个。</span><br></pre></td></tr></table></figure></div>

<p>在回收子进程的过程中可能存在回收不完全，原因是：在捕捉到SIGCHLD信号后执行信号处理函数时，可能存在一次性发出好几个SIGCHLD信号，但是未决信号集只能记录有无该信号不能记录次数，所以只能随机回收其中一个子进程而忽略其他一起结束的子进程，可以进行如下修改，每次只触发回调函数一次，就while循环回收，直到没有未回收的僵尸进程为止；</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pid=waitpid(<span class="number">0</span>,&amp;status,WNOHANG))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;<span class="comment">//非阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----child %d exit %d\n"</span>,pid,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child %d cancel siganl %d\n"</span>,pid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中设置为非阻塞是因为，只有当子进程结束才会执行这个回调函数，所以不需要阻塞等待。</p>
<p>对于在子进程先于父进程设置信号捕捉前死亡，就无法对子进程进行回收从而产生僵尸进程，未捕捉时对SIGCHLD执行的默认处理动作为忽略，所以可以在注册捕捉函数前先将SIGCHLD阻塞，待注册完成后解除对SIGCHLD的阻塞。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sig_set <span class="built_in">set</span>;</span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">act.sa_handler=do_sig_child;</span><br><span class="line">sigemptyset(&amp;act.sa_mask);</span><br><span class="line">act.sa_flags=<span class="number">0</span>;</span><br><span class="line">sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line">sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></div>



<h3 id="子进程结束status处理方式"><a href="#子进程结束status处理方式" class="headerlink" title="子进程结束status处理方式"></a>子进程结束status处理方式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function">options</span></span><br><span class="line"><span class="function">	WNOHANG</span></span><br><span class="line">		没有子进程结束，立即返回</span><br><span class="line">	WUNTRACED</span><br><span class="line">		如果子进程由于被停止产生的SIGCHLD，waitpid则立即返回</span><br><span class="line">	WCONTINUED</span><br><span class="line">		如果子进程由于被SIGCONT唤醒而产生的SIGCHLD，waitpid则立即返回</span><br><span class="line">获取status</span><br><span class="line">	WIFEXITED(status)</span><br><span class="line">		子进程正常<span class="built_in">exit</span>终止，返回真</span><br><span class="line">			WEXITSTATUS(status)返回子进程正常退出值</span><br><span class="line">	WIFSIGNALED(status)</span><br><span class="line">		子进程被信号终止，返回真</span><br><span class="line">			WTERMSIG(status)返回终止子进程的信号值</span><br><span class="line">	WIFSTOPPED(status)</span><br><span class="line">		子进程被停止，返回真</span><br><span class="line">			WSTOPSIG(status)返回停止子进程的信号值</span><br><span class="line">	WIFCONTINUED(status)</span><br></pre></td></tr></table></figure></div>



<h3 id="SIGCHLD信号注意问题"><a href="#SIGCHLD信号注意问题" class="headerlink" title="SIGCHLD信号注意问题"></a>SIGCHLD信号注意问题</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.	子进程继承了父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集spending。</span><br><span class="line">2.	注意注册信号捕捉函数的位置。</span><br><span class="line">3.	应该在fork之前，阻塞SIGCHLD信号。注册完捕捉函数后解除阻塞。</span><br></pre></td></tr></table></figure></div>



<h2 id="信号传参"><a href="#信号传参" class="headerlink" title="信号传参"></a>信号传参</h2><h3 id="发送信号传参"><a href="#发送信号传参" class="headerlink" title="发送信号传参"></a>发送信号传参</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigqueue函数对应kill函数，但可在向指定进程发送信号的同时携带参数</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;成功：<span class="number">0</span>；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">        <span class="keyword">union</span> sigval &#123;</span><br><span class="line">        <span class="keyword">int</span>   sival_int;</span><br><span class="line">        <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">        &#125;;</span><br><span class="line">	向指定进程发送指定信号的同时，携带数据。但，如传地址，需注意，不同进程之间虚拟地址空间各自独立，将当前进程地址传递给另一进程没有实际意义。</span><br></pre></td></tr></table></figure></div>



<h3 id="捕捉信号传参"><a href="#捕捉信号传参" class="headerlink" title="捕捉信号传参"></a>捕捉信号传参</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">               <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">               <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">               <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">               <span class="keyword">int</span>       sa_flags;</span><br><span class="line">               <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">           &#125;;</span><br><span class="line">	当注册信号捕捉函数，希望获取更多信号相关信息，不应使用sa_handler而应该使用sa_sigaction。但此时的sa_flags必须指定为SA_SIGINFO。<span class="keyword">siginfo_t</span>是一个成员十分丰富的结构体类型，可以携带各种与信号相关的数据。</span><br></pre></td></tr></table></figure></div>



<h2 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">系统调用可分为两类：慢速系统调用和其他系统调用。</span><br><span class="line">	1.	慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait...</span><br><span class="line">	2.	其他系统调用：getpid、getppid、fork...</span><br><span class="line">结合pause，回顾慢速系统调用：</span><br><span class="line">	慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read</span><br><span class="line">		1、想中断pause，信号不能被屏蔽。</span><br><span class="line">		2、信号的处理方式必须是捕捉 (默认、忽略都不可以)</span><br><span class="line">		3、中断后返回-1， 设置errno为EINTR(表“被信号中断”)</span><br><span class="line">	可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启。 SA_RESTART重启。</span><br><span class="line">扩展了解：</span><br><span class="line">	sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。</span><br></pre></td></tr></table></figure></div>



<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端（Controlling Terminal），进程中，控制终端是保存在PCB中的信息，而fork会复制PCB中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。信号中还讲过，在控制终端输入一些特殊的控制键可以给前台进程发信号，例如Ctrl-C表示SIGINT，Ctrl-\表示SIGQUIT。</span><br><span class="line">Alt + Ctrl + F1、F2、F3、F4、F5、F6	字符终端   pts (pseudo terminal slave) 指伪终端。</span><br><span class="line">Alt + F7		图形终端</span><br><span class="line">SSH、Telnet...		网络终端</span><br></pre></td></tr></table></figure></div>

<p>终端是输入输出设备的统称，shell为虚拟终端，输入和输出都在上面完成。</p>
<h3 id="终端的启动流程"><a href="#终端的启动流程" class="headerlink" title="终端的启动流程"></a>终端的启动流程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件与I&#x2F;O中讲过，每个进程都可以通过一个特殊的设备文件&#x2F;dev&#x2F;tty访问它的控制终端。事实上每个终端设备都对应一个不同的设备文件，&#x2F;dev&#x2F;tty提供了一个通用的接口，一个进程要访问它的控制终端既可以通过&#x2F;dev&#x2F;tty也可以通过该终端设备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</span><br><span class="line">简单来说，一个Linux系统启动，大致经历如下的步骤：</span><br><span class="line">init --&gt; fork --&gt; exec --&gt; getty --&gt; 用户输入帐号 --&gt; login --&gt; 输入密码 --&gt; exec --&gt; bash</span><br><span class="line">硬件驱动程序负责读写实际的硬件设备，比如从键盘读入字符和把字符输出到显示器，线路规程像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下Ctrl-z，对应的字符并不会被用户程序的read读到，而是被线路规程截获，解释成SIGTSTP信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111092128226.png" data-fancybox="group" data-caption="image-20210111092128226" class="fancybox"><img alt="image-20210111092128226" title="image-20210111092128226" data-src="image-20210111092128226.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">line disciline: 线路规程，用来过滤键盘输入的内容。</span><br></pre></td></tr></table></figure></div>

<p>通过ps ajx寻找控制终端</p>
<p><a href="image-20210111092546823.png" data-fancybox="group" data-caption="image-20210111092546823" class="fancybox"><img alt="image-20210111092546823" title="image-20210111092546823" data-src="image-20210111092546823.png" class="lazyload"></a></p>
<p><a href="image-20210111092716182.png" data-fancybox="group" data-caption="image-20210111092716182" class="fancybox"><img alt="image-20210111092716182" title="image-20210111092716182" data-src="image-20210111092716182.png" class="lazyload"></a></p>
<p><a href="image-20210111092751031.png" data-fancybox="group" data-caption="image-20210111092751031" class="fancybox"><img alt="image-20210111092751031" title="image-20210111092751031" data-src="image-20210111092751031.png" class="lazyload"></a></p>
<p><a href="image-20210111092845993.png" data-fancybox="group" data-caption="image-20210111092845993" class="fancybox"><img alt="image-20210111092845993" title="image-20210111092845993" data-src="image-20210111092845993.png" class="lazyload"></a></p>
<h3 id="ttyname函数"><a href="#ttyname函数" class="headerlink" title="ttyname函数"></a>ttyname函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">由文件描述符查出对应的文件名</span><br><span class="line">	<span class="function"><span class="keyword">char</span> *<span class="title">ttyname</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;	成功：终端名；失败：<span class="literal">NULL</span>，设置errno		</span><br><span class="line">下面我们借助ttyname函数，通过实验看一下各种不同的终端所对应的设备文件名。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 0: %s\n"</span>, ttyname(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 1: %s\n"</span>, ttyname(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd 2: %s\n"</span>, ttyname(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="网络终端"><a href="#网络终端" class="headerlink" title="网络终端"></a>网络终端</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟终端或串口终端的数目是有限的，虚拟终端(字符控制终端)一般就是&#x2F;dev&#x2F;tty1∼&#x2F;dev&#x2F;tty6六个，串口终端的数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，这是通过伪终端（Pseudo TTY）实现的。一套伪终端由一个主设备（PTY Master）和一个从设备（PTY Slave）组成。主设备在概念上相当于键盘和显示器，只不过它不是真正的硬件而是一个内核模块，操作它的也不是用户而是另外一个进程。从设备和上面介绍的&#x2F;dev&#x2F;tty1这样的终端设备模块类似，只不过它的底层驱动程序不是访问硬件而是访问主设备。网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认为自己的控制终端是伪终端从设备，例如&#x2F;dev&#x2F;pts&#x2F;0、&#x2F;dev&#x2F;pts&#x2F;1等。下面以telnet为例说明网络登录和使用伪终端的过程。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111094714499.png" data-fancybox="group" data-caption="image-20210111094714499" class="fancybox"><img alt="image-20210111094714499" title="image-20210111094714499" data-src="image-20210111094714499.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP&#x2F;IP协议栈：在数据包上添加报头。</span><br><span class="line">如果telnet客户端和服务器之间的网络延迟较大，我们会观察到按下一个键之后要过几秒钟才能回显到屏幕上。这说明我们每按一个键telnet客户端都会立刻把该字符发送给服务器，然后这个字符经过伪终端主设备和从设备之后被Shell进程读取，同时回显到伪终端从设备，回显的字符再经过伪终端主设备、telnetd服务器和网络发回给telnet客户端，显示给用户看。也许你会觉得吃惊，但真的是这样：每按一个键都要在网络上走个来回！</span><br></pre></td></tr></table></figure></div>



<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><h3 id="概念和特性"><a href="#概念和特性" class="headerlink" title="概念和特性"></a>概念和特性</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。</span><br><span class="line">当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID&#x3D;&#x3D;第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID&#x3D;&#x3D;其进程ID</span><br></pre></td></tr></table></figure></div>

<p>可以使用kill -SIGKILL -进程组ID(负的)来将整个进程组内的进程全部杀死。</p>
<p>【kill_multprocess.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./a.out numchild\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">            sys_err(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;        <span class="comment">/* in child */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"I'm child pid = %d, groupid = %d\n"</span>, getpid(), getpgrp());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;      <span class="comment">/* in parent */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">pid_t</span> cpid;</span><br><span class="line">        <span class="keyword">while</span> ((cpid = wait(<span class="literal">NULL</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child %d is over\n"</span>, cpid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111100634874.png" data-fancybox="group" data-caption="image-20210111100634874" class="fancybox"><img alt="image-20210111100634874" title="image-20210111100634874" data-src="image-20210111100634874.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111100807080.png" data-fancybox="group" data-caption="image-20210111100807080" class="fancybox"><img alt="image-20210111100807080" title="image-20210111100807080" data-src="image-20210111100807080.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111100917198.png" data-fancybox="group" data-caption="image-20210111100917198" class="fancybox"><img alt="image-20210111100917198" title="image-20210111100917198" data-src="image-20210111100917198.png" class="lazyload"></a></p>
<p><a href="image-20210111100951543.png" data-fancybox="group" data-caption="image-20210111100951543" class="fancybox"><img alt="image-20210111100951543" title="image-20210111100951543" data-src="image-20210111100951543.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。</span><br><span class="line">进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。</span><br><span class="line">一个进程可以为自己或子进程设置进程组ID</span><br></pre></td></tr></table></figure></div>



<h3 id="进程组操作函数"><a href="#进程组操作函数" class="headerlink" title="进程组操作函数"></a>进程组操作函数</h3><h4 id="getpgrp函数"><a href="#getpgrp函数" class="headerlink" title="getpgrp函数"></a>getpgrp函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取当前进程的进程组ID</span><br><span class="line">	<span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>; 总是返回调用者的进程组ID</span><br></pre></td></tr></table></figure></div>



<h4 id="getpgid函数"><a href="#getpgid函数" class="headerlink" title="getpgid函数"></a>getpgid函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取指定进程的进程组ID</span><br><span class="line">	<span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;	 成功：<span class="number">0</span>；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">如果pid = <span class="number">0</span>，那么该函数作用和getpgrp一样。</span><br><span class="line">    </span><br><span class="line">当设置pid=<span class="number">0</span>时，该函数作用与getpgrp相同</span><br></pre></td></tr></table></figure></div>



<h4 id="setpgid函数"><a href="#setpgid函数" class="headerlink" title="setpgid函数"></a>setpgid函数</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>; 	成功：<span class="number">0</span>；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">	将参<span class="number">1</span>对应的进程，加入参<span class="number">2</span>对应的进程组中。</span><br><span class="line">	注意： </span><br><span class="line">	<span class="number">1.</span> 如改变子进程为新的组，应fork后，exec前。 (因为exec后就不会再回来了)</span><br><span class="line">	<span class="number">2.</span> 权级问题。非root进程只能改变自己创建的子进程，或有权限操作的进程</span><br></pre></td></tr></table></figure></div>

<p>setpgid()可以给自己设置进程组id。</p>
<p><strong>练习</strong>：修改子进程的进程组ID </p>
<p>【setpgid.c】</p>
<p>在子进程睡眠期间父进程修改子进程的进程组ID</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child PID=%d,child group ID=%d\n"</span>,getpid(),getpgid(<span class="number">0</span>));</span><br><span class="line">        sleep(<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----Group ID of child is changed to %d\n"</span>,getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        setpgid(pid,pid);<span class="comment">//子进程的组id为子进程id</span></span><br><span class="line">        sleep(<span class="number">13</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent PID = %d\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent's parentd process PID=%d\n"</span>,getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent Group ID=%d\n"</span>,getpgid(<span class="number">0</span>));</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//改变父进程所属进程组ID为其父进程ID</span></span><br><span class="line">        setpgid(getpid(),getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n-----Group ID of parent id changed to %d\n"</span>,getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111104026447.png" data-fancybox="group" data-caption="image-20210111104026447" class="fancybox"><img alt="image-20210111104026447" title="image-20210111104026447" data-src="image-20210111104026447.png" class="lazyload"></a></p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建一个会话需要注意以下6点注意事项：</span><br><span class="line">	1.	调用进程不能是进程组组长，该进程变成新会话首进程(session header)</span><br><span class="line">	2.	该进程成为一个新进程组的组长进程。</span><br><span class="line">	3.	需有root权限(ubuntu不需要)</span><br><span class="line">	4.	新会话丢弃原有的控制终端，该会话没有控制终端</span><br><span class="line">	5.	该调用进程是组长进程，则出错返回</span><br><span class="line">	6.	建立新会话时，先调用fork, 父进程终止，子进程调用setsid</span><br></pre></td></tr></table></figure></div>



<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取进程所属的会话ID</span><br><span class="line">	<span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>; 成功：返回调用进程的会话ID；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">	pid为<span class="number">0</span>表示察看当前进程session ID</span><br><span class="line">	ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。</span><br><span class="line">	组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。</span><br></pre></td></tr></table></figure></div>



<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。</span><br><span class="line">	<span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  成功：返回调用进程的会话ID；失败：<span class="number">-1</span>，设置errno</span><br><span class="line">	调用了setsid函数的进程，既是新的会长，也是新的组长。</span><br></pre></td></tr></table></figure></div>

<p>练习：fork一个子进程，并使其创建一个新会话。查看进程组ID、会话ID前后变化 </p>
<p>【session.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork())&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process PID is %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Group ID of child is %d\n"</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Session ID of child is %d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        setsid();       <span class="comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Changed:\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process PID is %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Group ID of child is %d\n"</span>, getpgid(<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Session ID of child is %d\n"</span>, getsid(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111110355518.png" data-fancybox="group" data-caption="image-20210111110355518" class="fancybox"><img alt="image-20210111110355518" title="image-20210111110355518" data-src="image-20210111110355518.png" class="lazyload"></a></p>
<p>将非组长进程设置新会话，子进程既是组长又是会长。之前进程的组长并不是bash，当创建出来后就自立门户改变了自己的进程组id。</p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。</span><br><span class="line">Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。</span><br><span class="line">   创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。</span><br></pre></td></tr></table></figure></div>



<h3 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.	创建子进程，父进程退出</span><br><span class="line">	所有工作在子进程中进行形式上脱离了控制终端</span><br><span class="line">2.	在子进程中创建新会话</span><br><span class="line">　　	setsid()函数</span><br><span class="line">　　	使子进程完全独立出来，脱离控制</span><br><span class="line">3.	改变当前目录为根目录</span><br><span class="line">　　	chdir()函数</span><br><span class="line">　　	防止占用可卸载的文件系统</span><br><span class="line">　　	也可以换成其它路径</span><br><span class="line">4.	重设文件权限掩码</span><br><span class="line">　　	umask()函数</span><br><span class="line">　　	防止继承的文件创建屏蔽字拒绝某些权限</span><br><span class="line">　　	增加守护进程灵活性</span><br><span class="line">5.	关闭文件描述符</span><br><span class="line">　　 继承的打开文件不会用到，浪费系统资源，无法卸载</span><br><span class="line">6.	开始执行守护进程核心工作</span><br><span class="line">7.	守护进程退出处理程序模型</span><br></pre></td></tr></table></figure></div>

<p>【mydaemond.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mydaemond</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pit_t</span> pid,sid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork() err"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sid=setsid();<span class="comment">//创建新会话,脱离控制终端</span></span><br><span class="line">        <span class="keyword">int</span> ret=chdir(<span class="string">"/home/yujiao"</span>);<span class="comment">//设置当前目录</span></span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"chdir() err"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        umask(<span class="number">0022</span>);</span><br><span class="line">        <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">        <span class="built_in">open</span>(<span class="string">"/dev/null"</span>,O_RDWR);</span><br><span class="line">        dup2(<span class="number">0</span>,STDOUT_FILENO);</span><br><span class="line">        dup2(<span class="number">0</span>,STDERR_FILENO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mydaemond();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111115941066.png" data-fancybox="group" data-caption="image-20210111115941066" class="fancybox"><img alt="image-20210111115941066" title="image-20210111115941066" data-src="image-20210111115941066.png" class="lazyload"></a></p>
<p>后续学习进程需安装</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装线程man page，命令：sudo apt-get install manpages-posix-dev</span><br><span class="line">安装完成，使用man -k pthread如能看到线程函数列表则表明安装成功。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111114739244.png" data-fancybox="group" data-caption="image-20210111114739244" class="fancybox"><img alt="image-20210111114739244" title="image-20210111114739244" data-src="image-20210111114739244.png" class="lazyload"></a></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6</span></div></a></div><div class="next-post pull_right"><a href="/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day2/Day2/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Linux学习笔记/linux服务器开发二-系统编程/Day2/Day2</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Lucky</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>