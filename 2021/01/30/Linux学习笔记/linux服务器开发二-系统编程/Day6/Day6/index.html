<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6 | Lucky's Blog</title><meta name="description" content="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6"><meta name="author" content="Lucky"><meta name="copyright" content="Lucky"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6"><meta name="twitter:description" content="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6"><meta property="og:url" content="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"><meta property="og:site_name" content="Lucky's Blog"><meta property="og:description" content="Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day6/Day6/"><link rel="prev" title="Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day7/Day7/"><link rel="next" title="Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4" href="http://yoursite.com/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day4/Day4/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Lucky's Blog" type="application/atom+xml">
</head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Lucky's Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">31</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程概念"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">线程概念</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#什么是线程"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">什么是线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Linux内核线程实现原理"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Linux内核线程实现原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程共享资源"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">线程共享资源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程非共享资源"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">线程非共享资源</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程优缺点"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">线程优缺点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程控制原语"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">线程控制原语</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-self函数"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">pthread_self函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-create函数"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">pthread_create函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#线程与共享"><span class="toc_mobile_items-number">2.2.1.</span> <span class="toc_mobile_items-text">线程与共享</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-exit函数"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">pthread_exit函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-join函数"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">pthread_join函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-detach函数"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">pthread_detach函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-cancel函数"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">pthread_cancel函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#终止线程方式"><span class="toc_mobile_items-number">2.6.1.</span> <span class="toc_mobile_items-text">终止线程方式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#pthread-equal函数"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">pthread_equal函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#控制原语对比"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">控制原语对比</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程属性"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">线程属性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程属性初始化"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">线程属性初始化</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程的分离状态"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">线程的分离状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程的栈地址"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">线程的栈地址</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程的栈大小"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">线程的栈大小</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程的属性控制示例"><span class="toc_mobile_items-number">3.5.</span> <span class="toc_mobile_items-text">线程的属性控制示例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#NPTL"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">NPTL</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#线程使用注意事项"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">线程使用注意事项</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程概念"><span class="toc-number">1.</span> <span class="toc-text">线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程"><span class="toc-number">1.1.</span> <span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux内核线程实现原理"><span class="toc-number">1.2.</span> <span class="toc-text">Linux内核线程实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程共享资源"><span class="toc-number">1.3.</span> <span class="toc-text">线程共享资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程非共享资源"><span class="toc-number">1.4.</span> <span class="toc-text">线程非共享资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程优缺点"><span class="toc-number">1.5.</span> <span class="toc-text">线程优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程控制原语"><span class="toc-number">2.</span> <span class="toc-text">线程控制原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-self函数"><span class="toc-number">2.1.</span> <span class="toc-text">pthread_self函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-create函数"><span class="toc-number">2.2.</span> <span class="toc-text">pthread_create函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程与共享"><span class="toc-number">2.2.1.</span> <span class="toc-text">线程与共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-exit函数"><span class="toc-number">2.3.</span> <span class="toc-text">pthread_exit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-join函数"><span class="toc-number">2.4.</span> <span class="toc-text">pthread_join函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-detach函数"><span class="toc-number">2.5.</span> <span class="toc-text">pthread_detach函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-cancel函数"><span class="toc-number">2.6.</span> <span class="toc-text">pthread_cancel函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#终止线程方式"><span class="toc-number">2.6.1.</span> <span class="toc-text">终止线程方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pthread-equal函数"><span class="toc-number">2.7.</span> <span class="toc-text">pthread_equal函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制原语对比"><span class="toc-number">2.8.</span> <span class="toc-text">控制原语对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程属性"><span class="toc-number">3.</span> <span class="toc-text">线程属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程属性初始化"><span class="toc-number">3.1.</span> <span class="toc-text">线程属性初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的分离状态"><span class="toc-number">3.2.</span> <span class="toc-text">线程的分离状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的栈地址"><span class="toc-number">3.3.</span> <span class="toc-text">线程的栈地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的栈大小"><span class="toc-number">3.4.</span> <span class="toc-text">线程的栈大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的属性控制示例"><span class="toc-number">3.5.</span> <span class="toc-text">线程的属性控制示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPTL"><span class="toc-number">4.</span> <span class="toc-text">NPTL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程使用注意事项"><span class="toc-number">5.</span> <span class="toc-text">线程使用注意事项</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Linux学习笔记/linux服务器开发二-系统编程/Day6/Day6</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2021-01-30<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-01-22</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</span><br><span class="line">进程：独立地址空间，拥有PCB</span><br><span class="line">线程：也有PCB，但没有独立的地址空间(共享)</span><br><span class="line">区别：在于是否共享地址空间。	独居(进程)；合租(线程)。</span><br><span class="line">Linux下：	线程：最小的执行单位</span><br><span class="line">         进程：最小分配资源单位，可看成是只有一个线程的进程。</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111200002778.png" data-fancybox="group" data-caption="image-20210111200002778" class="fancybox"><img alt="image-20210111200002778" title="image-20210111200002778" data-src="image-20210111200002778.png" class="lazyload"></a></p>
<p><a href="02_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" data-fancybox="group" data-caption="02_进程和线程" class="fancybox"><img alt="02_进程和线程" title="02_进程和线程" data-src="02_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" class="lazyload"></a></p>
<p>有3个进程，相当于要把cpu分成三份，同时去抢夺cpu资源，若第一个进程变成了5个线程就相当于cpu要将自己分成5+2=7部分，进程1获得cpu的概率要大一些，故多线程可以提高程序的执行效率。若存在线程则与进程处于相同的地位，把线程的指令直接给cpu去执行，故线程为最小执行单元，不管多少个线程，使用的地址空间就只有一份都是0-4G的地址空间，使用进程未最小分配资源单位。</p>
<h3 id="Linux内核线程实现原理"><a href="#Linux内核线程实现原理" class="headerlink" title="Linux内核线程实现原理"></a>Linux内核线程实现原理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</span><br><span class="line">	1. 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone（即大部分资源都是从父进程赋值而来的）</span><br><span class="line">	2. 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的</span><br><span class="line">	3. 进程可以蜕变成线程</span><br><span class="line">	4. 线程可看做寄存器和栈的集合</span><br><span class="line">	5. 在linux下，线程最是小的执行单位；进程是最小的分配资源单位</span><br><span class="line">察看LWP号：ps –Lf pid 查看指定线程的lwp号。</span><br></pre></td></tr></table></figure></div>

<p><a href="03_%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84.png" data-fancybox="group" data-caption="03_三级映射" class="fancybox"><img alt="03_三级映射" title="03_三级映射" data-src="03_%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84.png" class="lazyload"></a></p>
<p>在PCB中有一个成员变量，是一个指针，指向一片空间（页目录  4K），页目录中有一条条的目录项，每个目录项都是一个指针，指向页表，页表中也对应一条条的子内容，该指针指向物理页面，里面存的是内存单元；每个进程都有一张映射表保存在内核空间，MMU通过映射表再映射到物理内存。线程间PCD指向页目录的指针相同。</p>
<p><a href="05_%E6%A0%88%E7%A9%BA%E9%97%B4.png" data-fancybox="group" data-caption="05_栈空间" class="fancybox"><img alt="05_栈空间" title="05_栈空间" data-src="05_%E6%A0%88%E7%A9%BA%E9%97%B4.png" class="lazyload"></a></p>
<p>每调用一个函数就会本来在一起的esp和ebp指针就会拉开距离，esp后移产生一块栈帧空间，再一次调用就继续后移，但是栈帧再向下一块栈帧空间移动的时候会将当前的esp和ebp保存再进行移动，显然每个线程对于用户这块栈区间不共享，若一样则线程和线程之间无法进行区分。</p>
<p>内核区的栈用于保存寄存器的值，由于进程间的切换，cpu给不同的进程分配时间轮片，保存以 用于后续的恢复，所以对于内核区的栈线程间也不一样，所以线程可看做寄存器和栈的集合。</p>
<p><strong>查看firefox浏览器有多少个线程？</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep firefox</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111204303061.png" data-fancybox="group" data-caption="image-20210111204303061" class="fancybox"><img alt="image-20210111204303061" title="image-20210111204303061" data-src="image-20210111204303061.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -Lf 12242</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210111204357523.png" data-fancybox="group" data-caption="image-20210111204357523" class="fancybox"><img alt="image-20210111204357523" title="image-20210111204357523" data-src="image-20210111204357523.png" class="lazyload"></a></p>
<p>LWP线程号的作用：cpu分配时间轮片的依据</p>
<p>线程ID：用于进程内部区分线程</p>
<p><a href="image-20210111204708425.png" data-fancybox="group" data-caption="image-20210111204708425" class="fancybox"><img alt="image-20210111204708425" title="image-20210111204708425" data-src="image-20210111204708425.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">三级映射：进程PCB --&gt; 页目录(可看成数组，首地址位于PCB中) --&gt; 页表 --&gt; 物理页面 --&gt; 内存单元</span><br><span class="line"></span><br><span class="line">	对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。</span><br><span class="line">但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。</span><br><span class="line">	实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。</span><br><span class="line">	如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。</span><br><span class="line">	因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。</span><br></pre></td></tr></table></figure></div>

<h3 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.文件描述符表</span><br><span class="line">2.每种信号的处理方式</span><br><span class="line">3.当前工作目录</span><br><span class="line">4.用户ID和组ID</span><br><span class="line">5.内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</span><br></pre></td></tr></table></figure></div>



<h3 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.线程id</span><br><span class="line">2.处理器现场和栈指针(内核栈)</span><br><span class="line">3.独立的栈空间(用户空间栈)</span><br><span class="line">4.errno变量</span><br><span class="line">5.信号屏蔽字</span><br><span class="line">6.调度优先级</span><br></pre></td></tr></table></figure></div>



<h3 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：	1. 提高程序并发性	2. 开销小	3. 数据通信、共享数据方便</span><br><span class="line">缺点：	1. 库函数，不稳定	2. 调试、编写困难、gdb不支持	3. 对信号支持不好</span><br><span class="line">优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</span><br></pre></td></tr></table></figure></div>



<h2 id="线程控制原语"><a href="#线程控制原语" class="headerlink" title="线程控制原语"></a>线程控制原语</h2><h3 id="pthread-self函数"><a href="#pthread-self函数" class="headerlink" title="pthread_self函数"></a>pthread_self函数</h3><p><a href="image-20210111210743448.png" data-fancybox="group" data-caption="image-20210111210743448" class="fancybox"><img alt="image-20210111210743448" title="image-20210111210743448" data-src="image-20210111210743448.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取线程ID。其作用对应进程中 getpid() 函数。</span><br><span class="line">	pthread_t pthread_self(void);	返回值：成功：0；	失败：无！</span><br><span class="line">	线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现</span><br><span class="line">	线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)</span><br><span class="line">	注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</span><br></pre></td></tr></table></figure></div>



<h3 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h3><p><a href="image-20210111210931650.png" data-fancybox="group" data-caption="image-20210111210931650" class="fancybox"><img alt="image-20210111210931650" title="image-20210111210931650" data-src="image-20210111210931650.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建一个新线程。		其作用，对应进程中fork() 函数。</span><br><span class="line">	int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="line">	返回值：成功：0；	失败：错误号	-----Linux环境下，所有线程特点，失败均直接返回错误号。</span><br><span class="line">参数：	</span><br><span class="line">	pthread_t：当前Linux中可理解为：typedef  unsigned long int  pthread_t;</span><br><span class="line">参数1：传出参数，保存系统为我们分配好的线程ID</span><br><span class="line">	参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。</span><br><span class="line">	参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。</span><br><span class="line">	参数4：线程主函数执行期间所使用的参数。</span><br><span class="line">	在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。</span><br><span class="line">	pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。</span><br><span class="line">	attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。</span><br></pre></td></tr></table></figure></div>

<p>【练习】：创建一个新线程，打印线程ID。注意：链接线程库 -lpthread</p>
<p>【pthrd_crt.c】</p>
<p>由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止，我们在main函数return之前延时1秒，这只是一种权宜之计，即使主线程等待1秒，内核也不一定会调度新创建的线程执行，下一节我们会看到更好的办法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In thread :thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    </span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将其打印到标准错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main2:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112094350992.png" data-fancybox="group" data-caption="image-20210112094350992" class="fancybox"><img alt="image-20210112094350992" title="image-20210112094350992" data-src="image-20210112094350992.png" class="lazyload"></a></p>
<p>如图，主线程的线程id没变，所有的线程的进程id都一样。</p>
<p>【练习】：循环创建多个线程，每个线程打印自己是第几个被创建的线程。(类似于进程循环创建子进程) </p>
<p>【more_pthrd.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dth thread :thread id=%lu,pid=%u\n"</span>,i+<span class="number">1</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将其打印到标准错误</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112101728306.png" data-fancybox="group" data-caption="image-20210112101728306" class="fancybox"><img alt="image-20210112101728306" title="image-20210112101728306" data-src="image-20210112101728306.png" class="lazyload"></a></p>
<p>如图，不会出现像fork创建进程一样，出现子进程创建子进程的现象，因为每次创建线程创建成功后会调用自己的回调函数，而创建子线程是在main函数中进行，代码逻辑不同。对于(void*)i，在32位系统中，将int类型转换为void类型的指针，都是4字节，因此不会出错，在64位系统中int（4字节）转换为void指针（8字节）提升精度，高位提升，之后void指针截断为int也是高位截断也不会出错。</p>
<p>拓展思考：将pthread_create函数参4修改为(void <em>)&amp;i, 将线程主函数内改为 i=</em>((int *)arg) 是否可以？</p>
<p><a href="image-20210112102657631.png" data-fancybox="group" data-caption="image-20210112102657631" class="fancybox"><img alt="image-20210112102657631" title="image-20210112102657631" data-src="image-20210112102657631.png" class="lazyload"></a></p>
<p>不可以，因为5个线程几乎同时创建，每个线程保存的是i的地址，在对i取值的过程中，i的值可能早就变了。如图一条子线程的数据都没有打印，每次情况都不定。</p>
<h4 id="线程与共享"><a href="#线程与共享" class="headerlink" title="线程与共享"></a>线程与共享</h4><p><strong>线程间共享全局变量！</strong></p>
<p>【<strong>牢记</strong>】：线程默认共享数据段、代码段等地址空间，常用的是全局变量。而进程不共享全局变量，只能借助mmap。</p>
<p>【练习】：设计程序，验证线程之间共享全局数据。</p>
<p>【glb_var_pthrd.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"At first var=%d\n"</span>,var);</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after pthread_create,var=%d\n"</span>,var);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112103449535.png" data-fancybox="group" data-caption="image-20210112103449535" class="fancybox"><img alt="image-20210112103449535" title="image-20210112103449535" data-src="image-20210112103449535.png" class="lazyload"></a></p>
<h3 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将单个线程退出</span><br><span class="line">	void pthread_exit(void *retval);	参数：retval表示线程退出状态，通常传NULL</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112104825952.png" data-fancybox="group" data-caption="image-20210112104825952" class="fancybox"><img alt="image-20210112104825952" title="image-20210112104825952" data-src="image-20210112104825952.png" class="lazyload"></a></p>
<p>思考：使用exit将指定线程退出，可以吗？ </p>
<p>【pthrd_exit.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In thread :thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    </span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将其打印到标准错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main2:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112104912783.png" data-fancybox="group" data-caption="image-20210112104912783" class="fancybox"><img alt="image-20210112104912783" title="image-20210112104912783" data-src="image-20210112104912783.png" class="lazyload"></a>    </p>
<p>如图，没有sleep子线程也可以正常打印输出，如果是return或exit，函数结束就整个进程都结束了。</p>
<p> 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。</span><br><span class="line"></span><br><span class="line">所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。</span><br><span class="line"></span><br><span class="line">另注意，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</span><br></pre></td></tr></table></figure></div>

<p>【练习】：编写多线程程序，总结exit、return、pthread_exit各自退出效果。</p>
<p>​     return：返回到调用者那里去。</p>
<p>​     pthread_exit()：将调用该函数的线程          </p>
<p>​     exit: 将进程退出。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">   <span class="comment">//exit(1);</span></span><br><span class="line">    <span class="comment">//pthread_exit(NULL);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        func(<span class="number">888</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dth thread :thread id=%lu,pid=%u\n"</span>,i+<span class="number">1</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//获取线程ID和进程ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main1:thread id=%lu,pid=%u\n"</span>,pthread_self(),getpid());</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将其打印到标准错误</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>1、return a</p>
<p><a href="image-20210112110351952.png" data-fancybox="group" data-caption="image-20210112110351952" class="fancybox"><img alt="image-20210112110351952" title="image-20210112110351952" data-src="image-20210112110351952.png" class="lazyload"></a></p>
<p>所有线程成功打印输出，因为return表示返回调用处。</p>
<p>2、exit(1)</p>
<p><a href="image-20210112110454767.png" data-fancybox="group" data-caption="image-20210112110454767" class="fancybox"><img alt="image-20210112110454767" title="image-20210112110454767" data-src="image-20210112110454767.png" class="lazyload"></a></p>
<p>如图未打印完全，exit(1)表示退出进程，在第3个线程的时候退出了，好几个线程可能产生但没来得及打印。</p>
<p>3、pthread_exit(NULL)</p>
<p><a href="image-20210112110639903.png" data-fancybox="group" data-caption="image-20210112110639903" class="fancybox"><img alt="image-20210112110639903" title="image-20210112110639903" data-src="image-20210112110639903.png" class="lazyload"></a></p>
<p>如图只有第3个线程为被打印，由于调用函数，函数执行pthread_exit(1)，只退出来第3个线程。</p>
<h3 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">阻塞等待线程退出，获取线程退出状态		其作用，对应进程中 waitpid() 函数。</span><br><span class="line">	int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号</span><br><span class="line">	参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。</span><br><span class="line">	对比记忆：</span><br><span class="line">		进程中：main返回值、exit参数--&gt;int；等待子进程结束 wait 函数参数--&gt;int *</span><br><span class="line">		线程中：线程主函数返回值、pthread_exit--&gt;void *；等待线程结束 pthread_join 函数参数--&gt;void **</span><br></pre></td></tr></table></figure></div>

<p>【练习】：参数 retval 非空用法。</p>
<p>【pthrd_exit_join.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;<span class="keyword">exit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">tfn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">exit_t</span>* ret=(<span class="keyword">exit_t</span>*)arg;</span><br><span class="line">    ret-&gt;a=<span class="number">100</span>;</span><br><span class="line">    ret-&gt;b=<span class="number">300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">exit_t</span> *retval;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    retval=(<span class="keyword">exit_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">exit_t</span>));</span><br><span class="line">    ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="keyword">void</span>*)retval);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将其打印到标准错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,retval-&gt;a,retval-&gt;b);</span><br><span class="line">    <span class="built_in">free</span>(retval);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112151049642.png" data-fancybox="group" data-caption="image-20210112151049642" class="fancybox"><img alt="image-20210112151049642" title="image-20210112151049642" data-src="image-20210112151049642.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用该函数的线程将挂起等待，直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下：</span><br><span class="line">1.	如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。</span><br><span class="line">2.	如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。</span><br><span class="line">3.	如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。</span><br><span class="line">4.	如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。</span><br></pre></td></tr></table></figure></div>

<p>【练习】：使用pthread_join函数将循环创建的多个子线程回收。</p>
<p>【pthrd_loop_join.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var=<span class="number">333</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"var=%d\n"</span>,var);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)var;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        var=<span class="number">777</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm %dth pthread,pthread_id=%lu,var=%d\n"</span>,i+<span class="number">1</span>,pthread_self(),var);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)var);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm %dth pthread,pthread_id=%lu,var=%d\n"</span>,i+<span class="number">1</span>,pthread_self(),var);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)var);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span>* ret[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i],<span class="literal">NULL</span>,tnf,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i],(<span class="keyword">void</span>**)&amp;ret[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d's ret = %d\n"</span>,i,(<span class="keyword">int</span>)ret[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112153751348.png" data-fancybox="group" data-caption="image-20210112153751348" class="fancybox"><img alt="image-20210112153751348" title="image-20210112153751348" data-src="image-20210112153751348.png" class="lazyload"></a></p>
<h3 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实现线程分离</span><br><span class="line">	int pthread_detach(pthread_t thread);	成功：0；失败：错误号</span><br><span class="line">	线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</span><br><span class="line">	进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</span><br><span class="line">	也可使用 pthread_create函数参2(线程属性)来设置线程分离。</span><br></pre></td></tr></table></figure></div>

<p>【练习】：使用pthread_detach函数实现线程分离</p>
<p>【pthrd_detach.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread count %d\n"</span>,n);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">void</span>* tret;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        err=pthread_join(tid,&amp;tret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"----err=%d\n"</span>,err);</span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread_join error:%s\n"</span>,strerror(err));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"thread_join exit code:%d\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112160015254.png" data-fancybox="group" data-caption="image-20210112160015254" class="fancybox"><img alt="image-20210112160015254" title="image-20210112160015254" data-src="image-20210112160015254.png" class="lazyload"></a></p>
<p>如图，线程分离后，主线程就无法对子线程进行回收，所以报错，并且主线程与子线程抢夺cpu，因为数字打印和错误打印轮流，本来pthread_join为阻塞回收，但分离线程不需要被回收所以互相抢夺。</p>
<p>将程序做如下修改（注释分离操作）:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf,<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//pthread_detach(tid);</span></span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112160403348.png" data-fancybox="group" data-caption="image-20210112160403348" class="fancybox"><img alt="image-20210112160403348" title="image-20210112160403348" data-src="image-20210112160403348.png" class="lazyload"></a></p>
<p>如图，主线程阻塞等子线程结束后进行回收并成功返回1，线程已被回收再继续进行回收报错。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，线程终止后，其终止状态一直保留到其它线程调用pthread_join获取它的状态为止。但是线程也可以被置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。也就是说，如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了。</span><br></pre></td></tr></table></figure></div>



<h3 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">杀死(取消)线程			其作用，对应进程中 kill() 函数。</span><br><span class="line">	int pthread_cancel(pthread_t thread);	成功：0；失败：错误号</span><br><span class="line">	【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</span><br><span class="line">	类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</span><br><span class="line">	取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</span><br><span class="line">	可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthread_testcancel函数自行设置一个取消点。</span><br><span class="line">	被取消的线程，	退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为-1。</span><br></pre></td></tr></table></figure></div>

<p>【练习】：终止线程的三种方法。注意“取消点”的概念。</p>
<p>【pthrd_endof3.c】 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf1</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1:I am returning\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf2</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2:I am exiting\n"</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf3</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread3:I am going to be killed\n"</span>);</span><br><span class="line">        pthread_testcancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span>* tret;</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 exit code:%d\n\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread2 exit code:%d\n\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">    </span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tnf3,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread3 exit code:%d\n\n"</span>,(<span class="keyword">int</span>)tret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112162620343.png" data-fancybox="group" data-caption="image-20210112162620343" class="fancybox"><img alt="image-20210112162620343" title="image-20210112162620343" data-src="image-20210112162620343.png" class="lazyload"></a></p>
<p>如图，线程被杀死后退出返回-1，而且待被杀死的线程里面必须存在返回点（系统调用等），如线程中没有取消点，可以通过调用pthread_testcancel函数自行设置一个取消点,否则无法退出，如下图所示:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tnf3</span><span class="params">(<span class="keyword">void</span>* arc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line">        <span class="comment">//printf("thread3:I am going to be killed\n");</span></span><br><span class="line">        <span class="comment">//pthread_testcancel();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112162935751.png" data-fancybox="group" data-caption="image-20210112162935751" class="fancybox"><img alt="image-20210112162935751" title="image-20210112162935751" data-src="image-20210112162935751.png" class="lazyload"></a></p>
<p>第三个线程由于没有取消点，无法被杀死。</p>
<h4 id="终止线程方式"><a href="#终止线程方式" class="headerlink" title="终止线程方式"></a>终止线程方式</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">总结：终止某个线程而不终止整个进程，有三种方法：</span><br><span class="line">	1.	从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。</span><br><span class="line">	2.	一个线程可以调用pthread_cancel终止同一进程中的另一个线程。</span><br><span class="line">	3.	线程可以调用pthread_exit终止自己。</span><br></pre></td></tr></table></figure></div>



<h3 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a>pthread_equal函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比较两个线程ID是否相等。</span><br><span class="line">	int pthread_equal(pthread_t t1, pthread_t t2);</span><br><span class="line">	有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</span><br></pre></td></tr></table></figure></div>

<p>由于现在Linux的线程为整型，可以通过==进行判断。</p>
<h3 id="控制原语对比"><a href="#控制原语对比" class="headerlink" title="控制原语对比"></a>控制原语对比</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程			线程</span><br><span class="line">fork		pthread_create</span><br><span class="line">exit		pthread_exit</span><br><span class="line">wait		pthread_join</span><br><span class="line">kill		pthread_cancel</span><br><span class="line">getpid		pthread_self		命名空间</span><br></pre></td></tr></table></figure></div>

<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	本节作为指引性介绍，linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。</span><br><span class="line">    typedef struct</span><br><span class="line">    &#123;</span><br><span class="line">    int 				etachstate; 	&#x2F;&#x2F;线程的分离状态</span><br><span class="line">    int 				schedpolicy; 	&#x2F;&#x2F;线程调度策略</span><br><span class="line">    struct sched_param	schedparam; 	&#x2F;&#x2F;线程的调度参数</span><br><span class="line">    int 				inheritsched; 	&#x2F;&#x2F;线程的继承性</span><br><span class="line">    int 				scope; 		&#x2F;&#x2F;线程的作用域</span><br><span class="line">    size_t 				guardsize; 	&#x2F;&#x2F;线程栈末尾的警戒缓冲区大小</span><br><span class="line">    int					stackaddr_set; &#x2F;&#x2F;线程的栈设置</span><br><span class="line">    void* 				stackaddr; 	&#x2F;&#x2F;线程栈的位置</span><br><span class="line">    size_t 				stacksize; 	&#x2F;&#x2F;线程栈的大小</span><br><span class="line">    &#125; pthread_attr_t; </span><br><span class="line">    </span><br><span class="line">主要结构体成员：</span><br><span class="line">	1. 线程分离状态</span><br><span class="line">	2. 线程栈大小（默认平均分配）</span><br><span class="line">	3. 线程栈警戒缓冲区大小（位于栈末尾）</span><br><span class="line">	属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。</span><br><span class="line">	线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</span><br></pre></td></tr></table></figure></div>



<h3 id="线程属性初始化"><a href="#线程属性初始化" class="headerlink" title="线程属性初始化"></a>线程属性初始化</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：应先初始化线程属性，再pthread_create创建线程</span><br><span class="line">初始化线程属性</span><br><span class="line">	int pthread_attr_init(pthread_attr_t *attr); 成功：0；失败：错误号</span><br><span class="line">销毁线程属性所占用的资源</span><br><span class="line">	int pthread_attr_destroy(pthread_attr_t *attr); 成功：0；失败：错误号</span><br></pre></td></tr></table></figure></div>



<h3 id="线程的分离状态"><a href="#线程的分离状态" class="headerlink" title="线程的分离状态"></a>线程的分离状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">线程的分离状态决定一个线程以什么样的方式来终止自己。</span><br><span class="line">非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</span><br><span class="line">分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。</span><br><span class="line">线程分离状态的函数：</span><br><span class="line">设置线程属性，分离or非分离</span><br><span class="line">	int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); </span><br><span class="line">获取程属性，分离or非分离</span><br><span class="line">		int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate); </span><br><span class="line">参数：	attr：已初始化的线程属性</span><br><span class="line">	  detachstate：	PTHREAD_CREATE_DETACHED（分离线程）</span><br><span class="line">         PTHREAD _CREATE_JOINABLE（非分离线程）</span><br><span class="line">这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</span><br></pre></td></tr></table></figure></div>

<p>【thrd_attr.c】</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">77</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    </span><br><span class="line">    ret=pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_init_error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    ret=pthread_create(&amp;tid,&amp;attr,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_create_error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret=pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_join_error:%s\n"</span>,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"--------join ret=%d\n"</span>,(<span class="keyword">int</span>)retval);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112204359113.png" data-fancybox="group" data-caption="image-20210112204359113" class="fancybox"><img alt="image-20210112204359113" title="image-20210112204359113" data-src="image-20210112204359113.png" class="lazyload"></a></p>
<p>回收出错，由于线程属于分离态，无需对其进行回收。</p>
<h3 id="线程的栈地址"><a href="#线程的栈地址" class="headerlink" title="线程的栈地址"></a>线程的栈地址</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POSIX.1定义了两个常量_POSIX_THREAD_ATTR_STACKADDR 和_POSIX_THREAD_ATTR_STACKSIZE检测系统是否支持栈属性。也可以给sysconf函数传递_SC_THREAD_ATTR_STACKADDR或 _SC_THREAD_ATTR_STACKSIZE来进行检测。</span><br><span class="line">当进程栈地址空间不够用时，指定新建线程使用由malloc分配的空间作为自己的栈空间。通过pthread_attr_setstack和pthread_attr_getstack两个函数分别设置和获取线程的栈地址。</span><br><span class="line">int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize); 成功：0；失败：错误号</span><br><span class="line">int pthread_attr_getstack(pthread_attr_t *attr, void **stackaddr, size_t *stacksize); 成功：0；失败：错误号</span><br><span class="line">参数：	attr：指向一个线程属性的指针</span><br><span class="line">         stackaddr：返回获取的栈地址</span><br><span class="line">         stacksize：返回获取的栈大小</span><br></pre></td></tr></table></figure></div>

<p>进程默认栈空间大小8kB</p>
<p>测试某进程最多可以创建多少个线程？</p>
<p>不停的循环创建线程并且不结束即可</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret=pthread_create(&amp;tid,<span class="literal">NULL</span>,thrd_func,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"pthread_creat error\n"</span>,strerror(ret));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----%d\n"</span>,count);</span><br><span class="line">        count++;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112205728832.png" data-fancybox="group" data-caption="image-20210112205728832" class="fancybox"><img alt="image-20210112205728832" title="image-20210112205728832" data-src="image-20210112205728832.png" class="lazyload"></a></p>
<p>如图，大概可以创建7444个线程。</p>
<h3 id="线程的栈大小"><a href="#线程的栈大小" class="headerlink" title="线程的栈大小"></a>线程的栈大小</h3><p><a href="image-20210112210539358.png" data-fancybox="group" data-caption="image-20210112210539358" class="fancybox"><img alt="image-20210112210539358" title="image-20210112210539358" data-src="image-20210112210539358.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当系统中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用，当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</span><br><span class="line">函数pthread_attr_getstacksize和 pthread_attr_setstacksize提供设置。</span><br><span class="line">int pthread_attr_setstacksize(pthread_attr_t *attr,void* stackaddr, size_t stacksize); 成功：0；失败：错误号</span><br><span class="line">int pthread_attr_getstacksize(pthread_attr_t *attr, void* *stackaddr,size_t *stacksize); 成功：0；失败：错误号</span><br><span class="line">参数：	attr：指向一个线程属性的指针</span><br><span class="line">         stacksize：返回线程的堆栈大小</span><br></pre></td></tr></table></figure></div>



<h3 id="线程的属性控制示例"><a href="#线程的属性控制示例" class="headerlink" title="线程的属性控制示例"></a>线程的属性控制示例</h3><p>循环将线程的栈空间开辟在堆区，程序的操作包含设置线程为分离态，修改线程的栈大小和地址：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 0x1000000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err,detachstate,i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">size_t</span> stacksize;<span class="comment">//typedef size_t unisigned int</span></span><br><span class="line">    <span class="keyword">void</span>* stackaddr;</span><br><span class="line">    </span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstack(&amp;attr,&amp;stackaddr,&amp;stacksize);</span><br><span class="line">    pthread_attr_getdetachstate(&amp;attr,&amp;detachstate);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(detachstate==PTHREAD_CREATE_DETACHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread detached\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(detachstate==PTHREAD_CREATE_JOINABLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread join\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread unknow\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stackaddr=<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        <span class="keyword">if</span>(stackaddr==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">"malloc"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stacksize=SIZE;</span><br><span class="line">        pthread_attr_setstack(&amp;attr,stackaddr,stacksize);</span><br><span class="line">        </span><br><span class="line">        err=pthread_create(&amp;tid,&amp;attr,th_func,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i++);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112214357459.png" data-fancybox="group" data-caption="image-20210112214357459" class="fancybox"><img alt="image-20210112214357459" title="image-20210112214357459" data-src="image-20210112214357459.png" class="lazyload"></a></p>
<h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.察看当前pthread库版本getconf GNU_LIBPTHREAD_VERSION</span><br><span class="line">2.NPTL实现机制(POSIX)，Native POSIX Thread Library</span><br><span class="line">3.使用线程库时gcc指定 –lpthread</span><br></pre></td></tr></table></figure></div>

<p><a href="image-20210112214729387.png" data-fancybox="group" data-caption="image-20210112214729387" class="fancybox"><img alt="image-20210112214729387" title="image-20210112214729387" data-src="image-20210112214729387.png" class="lazyload"></a></p>
<h2 id="线程使用注意事项"><a href="#线程使用注意事项" class="headerlink" title="线程使用注意事项"></a>线程使用注意事项</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.	主线程退出其他线程不退出，主线程应调用pthread_exit</span><br><span class="line">2.	避免僵尸线程</span><br><span class="line">	pthread_join</span><br><span class="line">	pthread_detach</span><br><span class="line">	pthread_create指定分离属性</span><br><span class="line">	被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线	程栈中的值;</span><br><span class="line">3.	malloc和mmap申请的内存可以被其他线程释放 </span><br><span class="line">4.	应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit</span><br><span class="line">5.	信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</span><br></pre></td></tr></table></figure></div>

<p><a href="04_%E9%80%80%E5%87%BA%E5%80%BC.png" data-fancybox="group" data-caption="04_退出值" class="fancybox"><img alt="04_退出值" title="04_退出值" data-src="04_%E9%80%80%E5%87%BA%E5%80%BC.png" class="lazyload"></a></p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day7/Day7/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Linux学习笔记/linux服务器开发二-系统编程/Day7/Day7</span></div></a></div><div class="next-post pull_right"><a href="/2021/01/30/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Day4/Day4/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Linux学习笔记/linux服务器开发二-系统编程/Day4/Day4</span></div></a></div></nav></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Lucky</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>